<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","actioncontroller","src","grpc","mod.rs"],"content":"pub mod receiver;\npub mod sender;\n\nuse std::sync::Arc;\n\nuse tonic::transport::Server;\n\n/// Initialize the gRPC communication system for ActionController\n///\n/// Sets up the gRPC server to receive requests from FilterGateway and StateManager,\n/// and establishes client connections to communicate with PolicyManager and NodeAgent.\n///\n/// # Returns\n///\n/// * `Ok(())` if initialization was successful\n/// * `Err(...)` if the initialization failed\n///\n/// # Errors\n///\n/// Returns an error if:\n/// - Server address binding fails\n/// - Client connection establishment fails\npub async fn init(manager: crate::manager::ActionControllerManager) -\u003e common::Result\u003c()\u003e {\n    let arc_manager = Arc::new(manager);\n    let grpc_server = receiver::ActionControllerReceiver::new(arc_manager.clone());\n\n    let addr = common::actioncontroller::open_server().parse()?;\n    println!(\"Starting gRPC server on {}\", addr);\n\n    tokio::spawn(async move {\n        if let Err(e) = Server::builder()\n            .add_service(grpc_server.into_service())\n            .serve(addr)\n            .await\n        {\n            eprintln!(\"gRPC server error: {}\", e);\n        }\n    });\n\n    println!(\"gRPC server started and listening\");\n\n    Ok(())\n}\n\n//UNIT TEST\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::manager::ActionControllerManager;\n    use tokio::time::{sleep, timeout, Duration};\n\n    #[tokio::test]\n    async fn test_open_server_returns_valid_address() {\n        let addr = common::actioncontroller::open_server();\n        println!(\"open_server() returned: {}\", addr);\n\n        // Just check it contains \":\" (host:port format)\n        assert!(addr.contains(':'), \"Address should be in host:port format\");\n    }\n\n    #[tokio::test]\n    async fn test_connect_server_returns_valid_url() {\n        let url = common::actioncontroller::connect_server();\n        println!(\"connect_server() returned: {}\", url);\n\n        // Should start with http:// and contain \":\"\n        assert!(url.starts_with(\"http://\"));\n        assert!(url.contains(':'));\n    }\n\n    #[tokio::test]\n    async fn test_init_starts_server_and_is_cancelled_safely() {\n        let manager = ActionControllerManager::new();\n\n        // Spawn init() in a task so we can cancel later\n        let task = tokio::spawn(async move {\n            let result = init(manager).await;\n            // We don't expect it to return unless we forcefully cancel\n            assert!(result.is_ok() || result.is_err());\n        });\n\n        // Allow init to start up briefly\n        sleep(Duration::from_millis(300)).await;\n\n        // Abort task so we don't get stuck\n        task.abort();\n    }\n}\n","traces":[{"line":23,"address":[1747262,1747355,1748309,1748333,1747232,1747377],"length":1,"stats":{"Line":4}},{"line":24,"address":[1747343,1747426],"length":1,"stats":{"Line":2}},{"line":25,"address":[1747442,1747504],"length":1,"stats":{"Line":2}},{"line":27,"address":[1747602,1747537,1748233],"length":1,"stats":{"Line":2}},{"line":28,"address":[1747868],"length":1,"stats":{"Line":1}},{"line":30,"address":[1748498,1748834,1749405,1748393,1749318,1748368,1747964],"length":1,"stats":{"Line":3}},{"line":31,"address":[1748784,1748757,1748698,1748446,1749155,1748989,1748591,1749074],"length":1,"stats":{"Line":7}},{"line":32,"address":[1748608],"length":1,"stats":{"Line":1}},{"line":33,"address":[1748705],"length":1,"stats":{"Line":1}},{"line":34,"address":[1748777,1748860,1748525,1749055,1748811],"length":1,"stats":{"Line":3}},{"line":36,"address":[1749204,1749148],"length":1,"stats":{"Line":2}},{"line":40,"address":[1748085],"length":1,"stats":{"Line":1}},{"line":42,"address":[1748130],"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","actioncontroller","src","grpc","receiver.rs"],"content":"use std::sync::Arc;\nuse tonic::{Request, Response, Status};\n\n// Import the generated protobuf code\nuse common::actioncontroller::{\n    action_controller_connection_server::{\n        ActionControllerConnection, ActionControllerConnectionServer,\n    },\n    ReconcileRequest, ReconcileResponse, Status as ActionStatus, TriggerActionRequest,\n    TriggerActionResponse,\n};\n\n/// Receiver for handling incoming gRPC requests for ActionController\n///\n/// Implements the ActionControllerConnection gRPC service defined in\n/// the protobuf specification. Handles incoming requests from:\n/// - FilterGateway (trigger_action)\n/// - StateManager (reconcile)\npub struct ActionControllerReceiver {\n    /// Reference to the ActionController manager\n    manager: Arc\u003ccrate::manager::ActionControllerManager\u003e,\n}\n\nimpl ActionControllerReceiver {\n    /// Create a new ActionControllerReceiver instance\n    ///\n    /// # Arguments\n    ///\n    /// * `manager` - Shared reference to the ActionController manager\n    ///\n    /// # Returns\n    ///\n    /// A new ActionControllerReceiver instance\n    pub fn new(manager: Arc\u003ccrate::manager::ActionControllerManager\u003e) -\u003e Self {\n        Self { manager }\n    }\n\n    /// Get a gRPC server for this receiver\n    ///\n    /// # Returns\n    ///\n    /// A configured ActionControllerConnectionServer\n    pub fn into_service(self) -\u003e ActionControllerConnectionServer\u003cSelf\u003e {\n        ActionControllerConnectionServer::new(self)\n    }\n}\n\n#[tonic::async_trait]\nimpl ActionControllerConnection for ActionControllerReceiver {\n    /// Handle trigger action requests from FilterGateway\n    ///\n    /// # Arguments\n    ///\n    /// * `request` - gRPC request containing scenario name to trigger\n    ///\n    /// # Returns\n    ///\n    /// * `Response\u003cTriggerActionResponse\u003e` - gRPC response with status and description\n    /// * `Status` - gRPC status error if the request fails\n    async fn trigger_action(\n        \u0026self,\n        request: Request\u003cTriggerActionRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cTriggerActionResponse\u003e, Status\u003e {\n        // TODO: Implementation\n        println!(\"trigger_action in grpc receiver\");\n\n        let scenario_name = request.into_inner().scenario_name;\n        println!(\"trigger_action scenario: {}\", scenario_name);\n\n        match self.manager.trigger_manager_action(\u0026scenario_name).await {\n            Ok(_) =\u003e Ok(Response::new(TriggerActionResponse {\n                status: 0,\n                desc: \"Action triggered successfully\".to_string(),\n            })),\n\n            Err(e) =\u003e {\n                let err_msg = e.to_string();\n\n                // Decide gRPC error code based on error content\n                let grpc_status = if err_msg.contains(\"Invalid scenario name\") {\n                    Status::invalid_argument(err_msg)\n                } else if err_msg.contains(\"not found\") {\n                    Status::not_found(err_msg)\n                } else if err_msg.contains(\"Failed to parse\") {\n                    Status::invalid_argument(err_msg)\n                } else if err_msg.contains(\"Failed to start workload\")\n                    || err_msg.contains(\"Failed to stop workload\")\n                {\n                    Status::internal(err_msg)\n                } else {\n                    // fallback to Unknown error code\n                    Status::unknown(err_msg)\n                };\n\n                // Return the gRPC error status instead of success response with error status code\n                Err(grpc_status)\n            }\n        }\n    }\n\n    /// Handle reconcile requests from StateManager\n    ///\n    /// # Arguments\n    ///\n    /// * `request` - gRPC request containing scenario name and state information\n    ///\n    /// # Returns\n    ///\n    /// * `Response\u003cReconcileResponse\u003e` - gRPC response with status and description\n    /// * `Status` - gRPC status error if the request fails\n    async fn reconcile(\n        \u0026self,\n        request: Request\u003cReconcileRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cReconcileResponse\u003e, Status\u003e {\n        // TODO: Implementation\n        let req = request.into_inner();\n        let scenario_name = req.scenario_name;\n\n        let current = i32_to_status(req.current);\n        let desired = i32_to_status(req.desired);\n\n        if current == desired {\n            return Ok(Response::new(ReconcileResponse {\n                status: 0, // Success\n                desc: \"Current and desired states are equal\".to_string(),\n            }));\n        }\n\n        match self\n            .manager\n            .reconcile_do(scenario_name, current, desired)\n            .await\n        {\n            Ok(_) =\u003e Ok(Response::new(ReconcileResponse {\n                status: 0, // Success\n                desc: \"Reconciliation completed successfully\".to_string(),\n            })),\n            // If reconcile_do returns an error, convert it into a gRPC Status::internal error\n            // and propagate it. This allows gRPC clients to receive a proper error status.\n            Err(e) =\u003e {\n                eprintln!(\"Reconciliation failed: {:?}\", e); // Log the error for debugging\n                Err(Status::internal(format!(\"Failed to reconcile: {}\", e)))\n            }\n        }\n    }\n}\n\nfn i32_to_status(value: i32) -\u003e ActionStatus {\n    match value {\n        0 =\u003e ActionStatus::None,\n        1 =\u003e ActionStatus::Init,\n        2 =\u003e ActionStatus::Ready,\n        3 =\u003e ActionStatus::Running,\n        4 =\u003e ActionStatus::Done,\n        5 =\u003e ActionStatus::Failed,\n        _ =\u003e ActionStatus::Unknown,\n    }\n}\n\n//UNIT TEST\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::manager::ActionControllerManager;\n    use common::actioncontroller::{ReconcileRequest, TriggerActionRequest};\n    use std::sync::Arc;\n    use tonic::Request;\n\n    #[tokio::test]\n    async fn test_reconcile_success_when_states_differ() {\n        // Pre-populate etcd keys\n\n        let scenario_yaml = r#\"\n        apiVersion: v1\n        kind: Scenario\n        metadata:\n            name: antipinch-enable\n        spec:\n            condition:\n            action: update\n            target: antipinch-enable\n        \"#;\n        common::etcd::put(\"scenario/antipinch-enable\", scenario_yaml)\n            .await\n            .unwrap();\n\n        let package_yaml = r#\"\n        apiVersion: v1\n        kind: Package\n        metadata:\n            label: null\n            name: antipinch-enable\n        spec:\n            pattern:\n              - type: plain\n            models:\n              - name: antipinch-enable-core\n                node: HPC\n                resources:\n                    volume: antipinch-volume\n                    network: antipinch-network\n        \"#;\n        common::etcd::put(\"package/antipinch-enable\", package_yaml)\n            .await\n            .unwrap();\n\n        let manager = Arc::new(ActionControllerManager::new());\n        let receiver = ActionControllerReceiver::new(manager.clone());\n\n        let request = Request::new(ReconcileRequest {\n            scenario_name: \"antipinch-enable\".to_string(),\n            current: common::actioncontroller::Status::Init as i32, // This is 1\n            desired: common::actioncontroller::Status::Ready as i32, // This is 2\n        });\n\n        let response_result = receiver.reconcile(request).await;\n\n        let response = response_result.unwrap();\n        assert_eq!(\n            response.get_ref().status,\n            0,\n            \"Expected status 0 (success), got {}\",\n            response.get_ref().status\n        );\n        assert_eq!(\n            response.get_ref().desc,\n            \"Reconciliation completed successfully\",\n            \"Expected success message, got: '{}'\",\n            response.get_ref().desc\n        );\n        common::etcd::delete(\"scenario/antipinch-enable\")\n            .await\n            .unwrap();\n        common::etcd::delete(\"package/antipinch-enable\")\n            .await\n            .unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_trigger_action_failure() {\n        let manager = Arc::new(ActionControllerManager::new());\n        let receiver = ActionControllerReceiver::new(manager.clone());\n\n        let request = Request::new(TriggerActionRequest {\n            scenario_name: \"invalid_scenario\".to_string(),\n        });\n\n        let response = receiver.trigger_action(request).await.unwrap_err();\n        assert!(response.message().contains(\"not found\"));\n    }\n\n    #[tokio::test]\n    async fn test_reconcile_when_states_equal() {\n        let manager = Arc::new(ActionControllerManager::new());\n        let receiver = ActionControllerReceiver::new(manager.clone());\n\n        let request = Request::new(ReconcileRequest {\n            scenario_name: \"test_scenario\".to_string(),\n            current: 3, // RUNNING\n            desired: 3, // RUNNING\n        });\n\n        let response = receiver.reconcile(request).await.unwrap();\n        assert_eq!(response.get_ref().status, 0);\n        assert_eq!(\n            response.get_ref().desc,\n            \"Current and desired states are equal\"\n        );\n    }\n\n    #[tokio::test]\n    async fn test_trigger_action_success() {\n        let manager = Arc::new(ActionControllerManager::new());\n        let receiver = ActionControllerReceiver::new(manager.clone());\n\n        let scenario_yaml = r#\"\n        apiVersion: v1\n        kind: Scenario\n        metadata:\n            name: antipinch-enable\n        spec:\n            condition:\n            action: update\n            target: antipinch-enable\n        \"#;\n\n        common::etcd::put(\"scenario/antipinch-enable\", scenario_yaml)\n            .await\n            .unwrap();\n\n        let package_yaml = r#\"\n        apiVersion: v1\n        kind: Package\n        metadata:\n            label: null\n            name: antipinch-enable\n        spec:\n            pattern:\n              - type: plain\n            models:\n              - name: antipinch-enable-core\n                node: HPC\n                resources:\n                    volume: antipinch-volume\n                    network: antipinch-network\n        \"#;\n\n        common::etcd::put(\"package/antipinch-enable\", package_yaml)\n            .await\n            .unwrap();\n\n        let request = Request::new(TriggerActionRequest {\n            scenario_name: \"antipinch-enable\".to_string(),\n        });\n\n        let response = receiver.trigger_action(request).await.unwrap();\n        assert_eq!(response.get_ref().status, 0);\n\n        let _ = common::etcd::delete(\"scenario/antipinch-enable\").await;\n        let _ = common::etcd::delete(\"package/antipinch-enable\").await;\n    }\n\n    #[tokio::test]\n    async fn test_reconcile_failure_invalid_scenario() {\n        let manager = Arc::new(ActionControllerManager::new());\n        let receiver = ActionControllerReceiver::new(manager.clone());\n\n        let request = Request::new(ReconcileRequest {\n            scenario_name: \"invalid_scenario\".to_string(),\n            current: 0,\n            desired: 3,\n        });\n\n        let response = receiver.reconcile(request).await.unwrap_err();\n        assert!(response.message().contains(\"Failed to reconcile\"));\n    }\n\n    #[test]\n    fn test_i32_to_status_all_variants() {\n        assert_eq!(i32_to_status(0), ActionStatus::None);\n        assert_eq!(i32_to_status(1), ActionStatus::Init);\n        assert_eq!(i32_to_status(2), ActionStatus::Ready);\n        assert_eq!(i32_to_status(3), ActionStatus::Running);\n        assert_eq!(i32_to_status(4), ActionStatus::Done);\n        assert_eq!(i32_to_status(5), ActionStatus::Failed);\n        assert_eq!(i32_to_status(999), ActionStatus::Unknown);\n        assert_eq!(i32_to_status(-1), ActionStatus::Unknown);\n    }\n\n    #[test]\n    fn test_receiver_new_and_into_service() {\n        let manager = Arc::new(ActionControllerManager::new());\n        let receiver = ActionControllerReceiver::new(manager);\n        let _service = receiver.into_service();\n    }\n}\n","traces":[{"line":34,"address":[2186880],"length":1,"stats":{"Line":5}},{"line":43,"address":[2186896],"length":1,"stats":{"Line":1}},{"line":44,"address":[2186913],"length":1,"stats":{"Line":1}},{"line":65,"address":[1846267,1846341],"length":1,"stats":{"Line":2}},{"line":67,"address":[1846360],"length":1,"stats":{"Line":1}},{"line":68,"address":[1846649,1846564],"length":1,"stats":{"Line":2}},{"line":70,"address":[1846792,1847281,1846726,1847038,1846913,1845806],"length":1,"stats":{"Line":5}},{"line":71,"address":[1847452],"length":1,"stats":{"Line":1}},{"line":73,"address":[1847370],"length":1,"stats":{"Line":1}},{"line":76,"address":[1847312],"length":1,"stats":{"Line":1}},{"line":77,"address":[1847641,1847360],"length":1,"stats":{"Line":2}},{"line":80,"address":[1847657,1847734],"length":1,"stats":{"Line":2}},{"line":81,"address":[1847796,1848500],"length":1,"stats":{"Line":0}},{"line":82,"address":[1847779,1847872],"length":1,"stats":{"Line":2}},{"line":83,"address":[1847934,1848498],"length":1,"stats":{"Line":2}},{"line":84,"address":[1848010,1847917],"length":1,"stats":{"Line":0}},{"line":85,"address":[1848496,1848072],"length":1,"stats":{"Line":0}},{"line":86,"address":[1848055,1848148],"length":1,"stats":{"Line":0}},{"line":87,"address":[1848290,1848193],"length":1,"stats":{"Line":0}},{"line":89,"address":[1848494,1848210],"length":1,"stats":{"Line":0}},{"line":92,"address":[1848327],"length":1,"stats":{"Line":0}},{"line":96,"address":[1848438],"length":1,"stats":{"Line":1}},{"line":116,"address":[1849063],"length":1,"stats":{"Line":2}},{"line":117,"address":[1849070],"length":1,"stats":{"Line":2}},{"line":119,"address":[1849197,1849110],"length":1,"stats":{"Line":4}},{"line":120,"address":[1849199],"length":1,"stats":{"Line":2}},{"line":122,"address":[1849244],"length":1,"stats":{"Line":2}},{"line":123,"address":[1849583],"length":1,"stats":{"Line":1}},{"line":125,"address":[1849304],"length":1,"stats":{"Line":1}},{"line":129,"address":[1849488,1850014,1849292,1850100,1849458],"length":1,"stats":{"Line":5}},{"line":131,"address":[1849384],"length":1,"stats":{"Line":1}},{"line":132,"address":[1848837,1849481,1849518,1850046,1849891],"length":1,"stats":{"Line":4}},{"line":134,"address":[1850255],"length":1,"stats":{"Line":1}},{"line":136,"address":[1850189],"length":1,"stats":{"Line":1}},{"line":140,"address":[1850131],"length":1,"stats":{"Line":1}},{"line":141,"address":[1850446,1850179],"length":1,"stats":{"Line":2}},{"line":142,"address":[1850531],"length":1,"stats":{"Line":1}},{"line":148,"address":[2186928],"length":1,"stats":{"Line":1}},{"line":149,"address":[2186932],"length":1,"stats":{"Line":1}},{"line":150,"address":[2186975],"length":1,"stats":{"Line":1}},{"line":151,"address":[2186985],"length":1,"stats":{"Line":1}},{"line":152,"address":[2186995],"length":1,"stats":{"Line":1}},{"line":153,"address":[2187005],"length":1,"stats":{"Line":1}},{"line":154,"address":[2187015],"length":1,"stats":{"Line":1}},{"line":155,"address":[2187025],"length":1,"stats":{"Line":1}},{"line":156,"address":[2186965],"length":1,"stats":{"Line":1}}],"covered":39,"coverable":46},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","actioncontroller","src","grpc","sender.rs"],"content":"use common::nodeagent::{\n    node_agent_connection_client::NodeAgentConnectionClient, HandleYamlRequest,\n};\nuse common::policymanager::{\n    policy_manager_connection_client::PolicyManagerConnectionClient, CheckPolicyRequest,\n};\nuse common::Result;\nuse tonic::Request;\n\n/// Check if a scenario is allowed by policy\n///\n/// Makes a gRPC request to PolicyManager to check if the scenario\n/// meets the current policy requirements.\n///\n/// # Arguments\n///\n/// * `scenario_name` - The name of the scenario to check\n///\n/// # Returns\n///\n/// * `Ok(())` if the policy check passes\n/// * `Err(...)` if the policy check fails or the request fails\n///\n/// # Errors\n///\n/// Returns an error if:\n/// - The connection to PolicyManager is not established\n/// - The gRPC request fails (e.g., PolicyManager returns a gRPC Status error)\n/// - The policy check fails (application-level failure indicated by gRPC Status)\npub async fn check_policy(scenario_name: String) -\u003e Result\u003c()\u003e {\n    // Change return type\n    if scenario_name.trim().is_empty() {\n        return Err(\"Invalid scenario name: cannot be empty\".into());\n    }\n\n    let addr = common::policymanager::connect_server();\n    let mut client = PolicyManagerConnectionClient::connect(addr)\n        .await\n        .map_err(|e| format!(\"Failed to connect to PolicyManager: {}\", e))?;\n    let request = tonic::Request::new(CheckPolicyRequest {\n        scenario_name: scenario_name.clone(),\n    }); // Clone scenario_name if needed later for error messages\n    let response = client.check_policy(request).await?;\n    let response_inner = response.into_inner();\n\n    // Check application-level status from the response payload *only if* the gRPC call was successful\n    if response_inner.status == 0 {\n        println!(\n            \"Policy check successful for '{}': {}\",\n            scenario_name, response_inner.desc\n        );\n        Ok(()) // Policy passed\n    } else {\n        // This block would only be reached if the server sent a successful gRPC status (OK)\n        // but included an application-level error code (non-0 status) in the payload.\n        // Given our recommended `receiver.rs`, this path should ideally not be taken for errors.\n        // It's more robust to rely on the gRPC `Status` for errors.\n        println!(\n            \"Policy check failed for '{}' (Application Status: {}): {}\",\n            scenario_name, response_inner.status, response_inner.desc\n        );\n        Err(format!(\n            \"Policy check failed for scenario '{}' with status {}: {}\",\n            scenario_name, response_inner.status, response_inner.desc\n        )\n        .into())\n    }\n}\n\n/// Send a workload handling request to NodeAgent\n///\n/// Makes a gRPC request to NodeAgent to perform an action on a workload\n/// (create, delete, start, stop, etc.)\n///\n/// # Arguments\n///\n/// * `workload_name` - The name of the workload to handle\n/// * `action` - The action to perform (numeric code)\n/// * `description` - Additional information about the action\n///\n/// # Returns\n///\n/// * `Ok(())` if the request was successful\n/// * `Err(...)` if the request failed\n///\n/// # Errors\n///\n/// Returns an error if:\n/// - The connection to NodeAgent is not established\n/// - The gRPC request fails\n/// - The workload handling operation fails\npub async fn handle_yaml(workload_name: String) -\u003e Result\u003cbool\u003e {\n    if workload_name.trim().is_empty() {\n        return Err(\"Invalid input: workload name and description cannot be empty\".into());\n    }\n\n    let addr = common::nodeagent::connect_server();\n    let mut client = NodeAgentConnectionClient::connect(addr).await.unwrap();\n    let request = Request::new(HandleYamlRequest {\n        yaml: workload_name,\n    });\n    let response: tonic::Response\u003ccommon::nodeagent::HandleYamlResponse\u003e =\n        client.handle_yaml(request).await?;\n    let response_inner = response.into_inner();\n\n    println!(\"Error: {}\", response_inner.desc);\n    Ok(response_inner.status)\n}\n\n// ===========================\n// UNIT TESTS\n// ===========================\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_check_policy_failure_invalid_scenario() {\n        // Sending invalid scenario_name to simulate policy check failure\n        let scenario_name = \"\".to_string(); // Empty string is invalid\n\n        let result = check_policy(scenario_name).await;\n        assert!(result.is_err());\n    }\n\n    // #[tokio::test]\n    // async fn test_handle_workload_success() {\n    //     let workload_name = \"test-workload\".to_string();\n    //     let action = 1;\n    //     let description = \"example description\".to_string();\n\n    //     let result = handle_yaml(workload_name).await;\n    //     if let Err(ref e) = result {\n    //         println!(\"Error in test_handle_workload_success: {:?}\", e);\n    //     } else {\n    //         println!(\"test_handle_workload_success successful\");\n    //     }\n    //     assert!(result.is_ok());\n    // }\n\n    #[tokio::test]\n    async fn test_handle_workload_failure_invalid_workload() {\n        // Sending invalid workload_name and invalid action to trigger failure\n        let workload_name = \"\".to_string(); // Invalid empty workload\n        let action = -999; // Invalid action code\n        let description = \"\".to_string(); // Empty description\n\n        let result = handle_yaml(workload_name).await;\n\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":30,"address":[2488048,2488798,2490050,2487424,2487501,2487629],"length":1,"stats":{"Line":4}},{"line":32,"address":[2487757,2487594],"length":1,"stats":{"Line":2}},{"line":33,"address":[2487842,2488006],"length":1,"stats":{"Line":2}},{"line":36,"address":[2487823],"length":1,"stats":{"Line":0}},{"line":37,"address":[2487930,2488285,2488375,2488777,2488248,2487900],"length":1,"stats":{"Line":0}},{"line":38,"address":[1967929],"length":1,"stats":{"Line":0}},{"line":39,"address":[2490240,2490266,2488343],"length":1,"stats":{"Line":0}},{"line":40,"address":[2488559],"length":1,"stats":{"Line":0}},{"line":41,"address":[2488484],"length":1,"stats":{"Line":0}},{"line":43,"address":[1967944],"length":1,"stats":{"Line":0}},{"line":44,"address":[2489218],"length":1,"stats":{"Line":0}},{"line":47,"address":[2489995,2489302],"length":1,"stats":{"Line":0}},{"line":48,"address":[2489421,2489312],"length":1,"stats":{"Line":0}},{"line":52,"address":[2489533],"length":1,"stats":{"Line":0}},{"line":58,"address":[2489567,2489343],"length":1,"stats":{"Line":0}},{"line":62,"address":[2489722],"length":1,"stats":{"Line":0}},{"line":92,"address":[2490509,2490432,2491026,2491571,2492461,2490655],"length":1,"stats":{"Line":4}},{"line":93,"address":[2490774,2490626],"length":1,"stats":{"Line":2}},{"line":94,"address":[2490987,2490841],"length":1,"stats":{"Line":2}},{"line":97,"address":[2490822],"length":1,"stats":{"Line":0}},{"line":98,"address":[1967001],"length":1,"stats":{"Line":0}},{"line":99,"address":[2491322],"length":1,"stats":{"Line":0}},{"line":100,"address":[2491278],"length":1,"stats":{"Line":0}},{"line":102,"address":[1967016],"length":1,"stats":{"Line":0}},{"line":104,"address":[2491989],"length":1,"stats":{"Line":0}},{"line":106,"address":[2492073,2492141],"length":1,"stats":{"Line":0}},{"line":107,"address":[2492210],"length":1,"stats":{"Line":0}}],"covered":6,"coverable":27},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","actioncontroller","src","main.rs"],"content":"use std::error::Error;\n\nmod grpc;\nmod manager;\nmod runtime;\n\n/// Initialize the ActionController component\n///\n/// Reads node information from `settings.yaml` file, distinguishes between\n/// Bluechi nodes and NodeAgent nodes, and sets up the initial configuration\n/// for the component to start processing workload orchestration requests.\n///\n/// # Errors\n///\n/// Returns an error if:\n/// - Configuration files cannot be read\n/// - Node information is invalid\n/// - gRPC server setup fails\nasync fn initialize(skip_grpc: bool) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    // TODO: Implementation\n    let manager = manager::ActionControllerManager::new();\n    //Production code will not effect by this change\n    if !skip_grpc {\n        grpc::init(manager).await?;\n    }\n\n    Ok(())\n}\n\n/// Main function for the ActionController component\n///\n/// Sets up and runs the ActionController service which:\n/// 1. Receives events from FilterGateway and StateManager\n/// 2. Manages workloads via Bluechi Controller API or NodeAgent API\n/// 3. Orchestrates node operations based on scenario requirements\n///\n/// # Errors\n///\n/// Returns an error if the service fails to start or encounters a\n/// critical error during operation.\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    println!(\"Starting ActionController...\");\n\n    // Initialize the controller\n    initialize(false).await?;\n\n    // TODO: Set up gRPC server\n\n    // Keep the application running\n    tokio::signal::ctrl_c().await?;\n    println!(\"Shutting down ActionController...\");\n\n    Ok(())\n}\n\n//UNIT TEST\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Positive test: initialize should succeed when skip_grpc is true\n    #[tokio::test]\n    async fn test_initialize_success() {\n        let result = initialize(true).await;\n        assert!(\n            result.is_ok(),\n            \"Expected initialize() to return Ok(), got Err: {:?}\",\n            result.err()\n        );\n    }\n\n    // Negative test (edge case): double initialization (should not panic or fail)\n    #[tokio::test]\n    async fn test_double_initialize() {\n        let first = initialize(true).await;\n        let second = initialize(true).await;\n\n        assert!(first.is_ok(), \"First initialize() should succeed\");\n        assert!(second.is_ok(), \"Second initialize() should succeed\");\n    }\n}\n","traces":[{"line":19,"address":[1893648,1893683,1894055,1894511,1893773,1893822],"length":1,"stats":{"Line":8}},{"line":21,"address":[1893766],"length":1,"stats":{"Line":2}},{"line":23,"address":[1893870,1894388],"length":1,"stats":{"Line":2}},{"line":24,"address":[1893883,1894081,1894008,1893800,1894484],"length":1,"stats":{"Line":0}},{"line":27,"address":[1893960],"length":1,"stats":{"Line":2}},{"line":42,"address":[2122802,2122796,2122320],"length":1,"stats":{"Line":0}},{"line":43,"address":[1894760,1894630],"length":1,"stats":{"Line":0}},{"line":46,"address":[1894899,1895337,1894683,1894789],"length":1,"stats":{"Line":0}},{"line":51,"address":[1895425,1894701,1895228,1895802],"length":1,"stats":{"Line":0}},{"line":52,"address":[1895730],"length":1,"stats":{"Line":0}},{"line":54,"address":[1895775],"length":1,"stats":{"Line":0}}],"covered":4,"coverable":11},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","actioncontroller","src","manager.rs"],"content":"use std::{thread, time::Duration};\n\nuse crate::runtime::bluechi;\nuse common::{\n    actioncontroller::Status,\n    spec::artifact::{Package, Scenario},\n    Result,\n};\n\n/// Manager for coordinating scenario actions and workload operations\n///\n/// Responsible for:\n/// - Processing scenario requests from gRPC receivers\n/// - Determining appropriate actions based on scenario definitions\n/// - Delegating workload operations to the appropriate runtime (Bluechi or NodeAgent)\n/// - Handling state reconciliation for scenario workloads\npub struct ActionControllerManager {\n    /// List of nodes managed by Bluechi\n    pub bluechi_nodes: Vec\u003cString\u003e,\n    /// List of nodes managed by NodeAgent\n    pub nodeagent_nodes: Vec\u003cString\u003e,\n    // Add other fields as needed\n}\n\nimpl ActionControllerManager {\n    /// Creates a new ActionControllerManager instance\n    ///\n    /// Initializes the manager with empty node lists. Node information\n    /// should be populated after creation.\n    ///\n    /// # Returns\n    ///\n    /// A new ActionControllerManager instance\n    pub fn new() -\u003e Self {\n        let mut bluechi_nodes = Vec::new();\n        let mut nodeagent_nodes = Vec::new();\n        let settings = common::setting::get_config();\n\n        if settings.host.r#type == \"bluechi\" {\n            bluechi_nodes.push(settings.host.name.clone());\n        } else if settings.host.r#type == \"nodeagent\" {\n            nodeagent_nodes.push(settings.host.name.clone());\n        }\n\n        if let Some(guests) = \u0026settings.guest {\n            for guest in guests {\n                if guest.r#type == \"bluechi\" {\n                    bluechi_nodes.push(guest.name.clone());\n                } else if guest.r#type == \"nodeagent\" {\n                    nodeagent_nodes.push(guest.name.clone());\n                }\n            }\n        }\n\n        Self {\n            bluechi_nodes,\n            nodeagent_nodes,\n        }\n    }\n\n    /// Processes a trigger action request for a specific scenario\n    ///\n    /// Retrieves scenario information from ETCD and performs the\n    /// appropriate actions based on the scenario definition.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario to trigger\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if the action was triggered successfully\n    /// * `Err(...)` if the action could not be triggered\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The scenario does not exist\n    /// - The scenario is not allowed by policy\n    /// - The runtime operation fails\n    pub async fn trigger_manager_action(\u0026self, scenario_name: \u0026str) -\u003e Result\u003c()\u003e {\n        println!(\"trigger_manager_action in manager {:?}\", scenario_name);\n        if scenario_name.trim().is_empty() {\n            return Err(format!(\"Scenario '{}' is invalid: cannot be empty\", scenario_name).into());\n        }\n        let etcd_scenario_key = format!(\"Scenario/{}\", scenario_name);\n        let scenario_str: String = match common::etcd::get(\u0026etcd_scenario_key).await {\n            Ok(value) =\u003e value,\n            Err(e) =\u003e {\n                return Err(format!(\"Scenario '{}' not found: {}\", scenario_name, e).into());\n            }\n        };\n        let scenario: Scenario = serde_yaml::from_str(\u0026scenario_str)\n            .map_err(|e| format!(\"Failed to parse scenario '{}': {}\", scenario_name, e))?;\n\n        let action: String = scenario.get_actions();\n\n        let etcd_package_key = format!(\"Package/{}\", scenario.get_targets());\n        let package_str = match common::etcd::get(\u0026etcd_package_key).await {\n            Ok(value) =\u003e value,\n            Err(e) =\u003e {\n                return Err(format!(\"Package key '{}' not found: {}\", etcd_package_key, e).into());\n            }\n        };\n\n        let package: Package = serde_yaml::from_str(\u0026package_str).map_err(|e| {\n            format!(\n                \"Failed to parse package '{}': {}\",\n                scenario.get_targets(),\n                e\n            )\n        })?;\n\n        for mi in package.get_models() {\n            let model_name = format!(\"{}.service\", mi.get_name());\n            let model_node = mi.get_node();\n            let node_type = if self.bluechi_nodes.contains(\u0026model_node) {\n                println!(\"Node {} is bluechi\", model_node);\n                \"bluechi\"\n            } else if self.nodeagent_nodes.contains(\u0026model_node) {\n                println!(\"Node {} is nodeagent\", model_node);\n                \"nodeagent\"\n            } else {\n                continue; // Skip unknown node types\n            };\n            println!(\n                \"Processing model '{}' on node '{}' with action '{}'\",\n                model_name, model_node, action\n            );\n            match action.as_str() {\n                \"launch\" =\u003e {\n                    self.reload_all_node(\u0026model_name, \u0026model_node).await?;\n                    self.start_workload(\u0026model_name, \u0026model_node, \u0026node_type)\n                        .await\n                        .map_err(|e| format!(\"Failed to start workload '{}': {}\", model_name, e))?;\n                }\n                \"terminate\" =\u003e {\n                    self.reload_all_node(\u0026model_name, \u0026model_node).await?;\n                    self.stop_workload(\u0026model_name, \u0026model_node, \u0026node_type)\n                        .await\n                        .map_err(|e| format!(\"Failed to stop workload '{}': {}\", model_name, e))?;\n                }\n                \"update\" | \"rollback\" =\u003e {\n                    self.reload_all_node(\u0026model_name, \u0026model_node).await?;\n                    self.stop_workload(\u0026model_name, \u0026model_node, \u0026node_type)\n                        .await\n                        .map_err(|e| format!(\"Failed to stop workload '{}': {}\", model_name, e))?;\n\n                    self.reload_all_node(\u0026model_name, \u0026model_node).await?;\n                    self.start_workload(\u0026model_name, \u0026model_node, \u0026node_type)\n                        .await\n                        .map_err(|e| format!(\"Failed to start workload '{}': {}\", model_name, e))?;\n                }\n                _ =\u003e {\n                    // Ignore unknown action for now, or optionally return error:\n                    // return Err(format!(\"Unknown action '{}'\", action).into());\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Reconciles current and desired states for a scenario\n    ///\n    /// Compares the current state with the desired state for a given scenario\n    /// and performs the necessary actions to align them.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    /// * `current` - Current state value\n    /// * `desired` - Desired state value\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if the reconciliation was successful\n    /// * `Err(...)` if the reconciliation failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The scenario does not exist\n    /// - The reconciliation action fails\n    pub async fn reconcile_do(\n        \u0026self,\n        scenario_name: String,\n        current: Status,\n        desired: Status,\n    ) -\u003e Result\u003c()\u003e {\n        if current == desired {\n            return Ok(());\n        }\n\n        if matches!(current, Status::None | Status::Failed | Status::Unknown) {\n            return Err(format!(\n                \"Invalid current status: {:?}. Cannot reconcile from this state\",\n                current\n            )\n            .into());\n        }\n\n        if matches!(desired, Status::None | Status::Failed | Status::Unknown) {\n            return Err(format!(\n                \"Invalid desired status: {:?}. Cannot set this as target state\",\n                desired\n            )\n            .into());\n        }\n\n        let etcd_scenario_key: String = format!(\"scenario/{}\", scenario_name);\n        let scenario_str = common::etcd::get(\u0026etcd_scenario_key).await?;\n        let scenario: Scenario = serde_yaml::from_str(\u0026scenario_str)?;\n\n        let etcd_package_key = format!(\"package/{}\", scenario.get_targets());\n        let package_str = common::etcd::get(\u0026etcd_package_key).await?;\n        let package: Package = serde_yaml::from_str(\u0026package_str)?;\n\n        for mi in package.get_models() {\n            let model_name = format!(\"{}.service\", mi.get_name());\n            let model_node = mi.get_node();\n            let node_type = if self.bluechi_nodes.contains(\u0026model_node) {\n                \"bluechi\"\n            } else if self.nodeagent_nodes.contains(\u0026model_node) {\n                \"nodeagent\"\n            } else {\n                continue; // Skip if node type is unknown\n            };\n\n            if desired == Status::Running {\n                self.start_workload(\u0026model_name, \u0026model_node, \u0026node_type)\n                    .await?;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Creates a new workload for the specified scenario\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if the workload was created successfully\n    /// * `Err(...)` if the workload creation failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The scenario does not exist\n    /// - The workload already exists\n    /// - The runtime operation fails\n    pub async fn create_workload(\u0026self, scenario_name: String) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        Ok(())\n    }\n\n    /// Deletes an existing workload for the specified scenario\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if the workload was deleted successfully\n    /// * `Err(...)` if the workload deletion failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The scenario does not exist\n    /// - The workload does not exist\n    /// - The runtime operation fails\n    pub async fn delete_workload(\u0026self, scenario_name: String) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        Ok(())\n    }\n\n    /// Restarts an existing workload for the specified scenario\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if the workload was restarted successfully\n    /// * `Err(...)` if the workload restart failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The scenario does not exist\n    /// - The workload does not exist\n    /// - The runtime operation fails\n    pub async fn restart_workload(\u0026self, scenario_name: String) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        Ok(())\n    }\n\n    /// Pauses an active workload for the specified scenario\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if the workload was paused successfully\n    /// * `Err(...)` if the workload pause failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The scenario does not exist\n    /// - The workload does not exist\n    /// - The workload is not in a pausable state\n    /// - The runtime operation fails\n    pub async fn pause_workload(\u0026self, scenario_name: String) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        Ok(())\n    }\n\n    /// Starts a paused or stopped workload for the specified scenario\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if the workload was started successfully\n    /// * `Err(...)` if the workload start failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The scenario does not exist\n    /// - The workload does not exist\n    /// - The workload is not in a startable state\n    /// - The runtime operation fails\n    pub async fn start_workload(\n        \u0026self,\n        model_name: \u0026str,\n        node_name: \u0026str,\n        node_type: \u0026str,\n    ) -\u003e Result\u003c()\u003e {\n        match node_type {\n            \"bluechi\" =\u003e {\n                let cmd = bluechi::BluechiCmd {\n                    command: bluechi::Command::UnitStart,\n                };\n                bluechi::handle_bluechi_cmd(\u0026model_name, \u0026node_name, cmd).await?;\n            }\n            \"nodeagent\" =\u003e {\n                // let runtime = crate::runtime::nodeagent::NodeAgentRuntime::new();\n                // runtime.start_workload(model_name).await?;\n            }\n            _ =\u003e {\n                return Err(format!(\n                    \"Unsupported node type '{}' for workload '{}' on node '{}'\",\n                    node_type, model_name, node_name\n                )\n                .into());\n            }\n        }\n        Ok(())\n    }\n\n    /// Stops an active workload for the specified scenario\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if the workload was stopped successfully\n    /// * `Err(...)` if the workload stop failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The scenario does not exist\n    /// - The workload does not exist\n    /// - The workload is already stopped\n    /// - The runtime operation fails\n    pub async fn stop_workload(\n        \u0026self,\n        model_name: \u0026str,\n        node_name: \u0026str,\n        node_type: \u0026str,\n    ) -\u003e Result\u003c()\u003e {\n        match node_type {\n            \"bluechi\" =\u003e {\n                let cmd = bluechi::BluechiCmd {\n                    command: bluechi::Command::UnitStop,\n                };\n                bluechi::handle_bluechi_cmd(\u0026model_name, \u0026node_name, cmd).await?;\n            }\n            \"nodeagent\" =\u003e {\n                // let runtime = crate::runtime::nodeagent::NodeAgentRuntime::new();\n                // runtime.start_workload(model_name).await?;\n            }\n            _ =\u003e {\n                return Err(format!(\n                    \"Unsupported node type '{}' for workload '{}' on node '{}'\",\n                    node_type, model_name, node_name\n                )\n                .into());\n            }\n        }\n        Ok(())\n    }\n\n    pub async fn reload_all_node(\u0026self, model_name: \u0026str, model_node: \u0026str) -\u003e Result\u003c()\u003e {\n        let cmd = bluechi::BluechiCmd {\n            command: bluechi::Command::ControllerReloadAllNodes,\n        };\n        bluechi::handle_bluechi_cmd(model_name, model_node, cmd).await?;\n        thread::sleep(Duration::from_millis(100));\n        Ok(())\n    }\n}\n\n//UNIT TEST SKELTON\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use common::actioncontroller::Status;\n    use std::error::Error;\n\n    #[tokio::test]\n    async fn test_reconcile_do_with_valid_status() {\n        // Valid scenario where reconcile_do transitions status successfully\n        let manager = ActionControllerManager {\n            bluechi_nodes: vec![\"HPC\".to_string()],\n            nodeagent_nodes: vec![],\n        };\n        let result = manager\n            .reconcile_do(\"antipinch-enable\".into(), Status::Running, Status::Running)\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_trigger_manager_action_with_valid_data() {\n        // Insert mock Scenario YAML into etcd\n        common::etcd::put(\n            \"Scenario/antipinch-enable\",\n            r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: antipinch-enable\nspec:\n  condition:\n  action: update\n  target: antipinch-enable\n\"#,\n        )\n        .await\n        .unwrap();\n\n        // Insert mock Package YAML into etcd\n        common::etcd::put(\n            \"Package/antipinch-enable\",\n            r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  label: null\n  name: antipinch-enable\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: helloworld-core\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#,\n        )\n        .await\n        .unwrap();\n\n        let manager = ActionControllerManager {\n            bluechi_nodes: vec![\"HPC\".to_string()],\n            nodeagent_nodes: vec![],\n        };\n\n        let result = manager.trigger_manager_action(\"antipinch-enable\").await;\n\n        if let Err(ref e) = result {\n            println!(\"Error in trigger_manager_action: {:?}\", e);\n        } else {\n            println!(\"trigger_manager_action successful\");\n        }\n\n        assert!(result.is_ok());\n\n        // Cleanup after test\n        common::etcd::delete(\"Scenario/antipinch-enable\")\n            .await\n            .unwrap();\n        common::etcd::delete(\"Package/antipinch-enable\")\n            .await\n            .unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_trigger_manager_action_invalid_scenario() {\n        // Negative case: nonexistent scenario key\n        let manager: ActionControllerManager = ActionControllerManager {\n            bluechi_nodes: vec![\"HPC\".to_string()],\n            nodeagent_nodes: vec![],\n        };\n\n        let result = manager.trigger_manager_action(\"invalid_scenario\").await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_reconcile_do_invalid_scenario_key() {\n        // Negative case: nonexistent scenario key returns error\n        let manager = ActionControllerManager {\n            bluechi_nodes: vec![\"HPC\".to_string()],\n            nodeagent_nodes: vec![],\n        };\n\n        let result = manager\n            .reconcile_do(\"invalid_scenario\".into(), Status::None, Status::Running)\n            .await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_start_workload_invalid_node_type() {\n        // Negative case: unknown node type returns Ok but does nothing\n        let manager = ActionControllerManager {\n            bluechi_nodes: vec![\"HPC\".to_string()],\n            nodeagent_nodes: vec![],\n        };\n\n        let result: std::result::Result\u003c(), Box\u003cdyn Error\u003e\u003e = manager\n            .start_workload(\"antipinch-enable\", \"HPC\", \"invalid_type\")\n            .await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_stop_workload_invalid_node_type() {\n        // Negative case: unknown node type returns Ok but does nothing\n        let manager: ActionControllerManager = ActionControllerManager {\n            bluechi_nodes: vec![\"HPC\".to_string()],\n            nodeagent_nodes: vec![],\n        };\n\n        let result = manager\n            .stop_workload(\"antipinch-enable\", \"HPC\", \"invalid_type\")\n            .await;\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_manager_initializes_nodes() {\n        // Ensures new() returns manager with non-empty nodes\n        let manager = ActionControllerManager::new();\n        assert!(!manager.bluechi_nodes.is_empty() || !manager.nodeagent_nodes.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_create_delete_restart_pause_are_noops() {\n        // All of these are currently no-op, so they should succeed regardless of input\n        let manager = ActionControllerManager {\n            bluechi_nodes: vec![],\n            nodeagent_nodes: vec![],\n        };\n\n        assert!(manager.create_workload(\"test\".into()).await.is_ok());\n        assert!(manager.delete_workload(\"test\".into()).await.is_ok());\n        assert!(manager.restart_workload(\"test\".into()).await.is_ok());\n        assert!(manager.pause_workload(\"test\".into()).await.is_ok());\n    }\n}\n","traces":[{"line":34,"address":[2429786,2428848,2429792],"length":1,"stats":{"Line":5}},{"line":35,"address":[2428865],"length":1,"stats":{"Line":5}},{"line":36,"address":[2428897],"length":1,"stats":{"Line":5}},{"line":37,"address":[2429004,2428942],"length":1,"stats":{"Line":10}},{"line":39,"address":[2429012],"length":1,"stats":{"Line":5}},{"line":40,"address":[2429231,2429076],"length":1,"stats":{"Line":10}},{"line":41,"address":[2429106,2429049],"length":1,"stats":{"Line":0}},{"line":42,"address":[2429172],"length":1,"stats":{"Line":0}},{"line":45,"address":[2429117,2429272],"length":1,"stats":{"Line":5}},{"line":46,"address":[2429486,2429280],"length":1,"stats":{"Line":0}},{"line":47,"address":[2429591],"length":1,"stats":{"Line":0}},{"line":48,"address":[2429750,2429655],"length":1,"stats":{"Line":0}},{"line":49,"address":[2429678,2429628],"length":1,"stats":{"Line":0}},{"line":50,"address":[2429692],"length":1,"stats":{"Line":0}},{"line":81,"address":[2034864,2037580,2035356,2034986,2036173,2035124],"length":1,"stats":{"Line":4}},{"line":82,"address":[2035406,2035090],"length":1,"stats":{"Line":2}},{"line":83,"address":[2035475],"length":1,"stats":{"Line":1}},{"line":84,"address":[2035588,2035933],"length":1,"stats":{"Line":0}},{"line":86,"address":[2035557,2035622],"length":1,"stats":{"Line":3}},{"line":87,"address":[2035825,2035726,2036199,2035154],"length":1,"stats":{"Line":5}},{"line":88,"address":[2036499],"length":1,"stats":{"Line":1}},{"line":89,"address":[2036463],"length":1,"stats":{"Line":2}},{"line":90,"address":[2036465,2037704],"length":1,"stats":{"Line":4}},{"line":93,"address":[2036563,2036670,2037602,2036705,2036804],"length":1,"stats":{"Line":3}},{"line":94,"address":[2036677,2046832,2046859,2036772],"length":1,"stats":{"Line":1}},{"line":96,"address":[2036937],"length":1,"stats":{"Line":1}},{"line":98,"address":[2037018,2037097],"length":1,"stats":{"Line":2}},{"line":99,"address":[2035175,2037942,2037472,2037367],"length":1,"stats":{"Line":3}},{"line":100,"address":[2038245],"length":1,"stats":{"Line":1}},{"line":101,"address":[2038206],"length":1,"stats":{"Line":0}},{"line":102,"address":[2039010,2038208],"length":1,"stats":{"Line":0}},{"line":106,"address":[2047471,2038428,2038315,2047477,2038905,2047088,2038562],"length":1,"stats":{"Line":2}},{"line":107,"address":[2047179],"length":1,"stats":{"Line":0}},{"line":109,"address":[2047114],"length":1,"stats":{"Line":0}},{"line":114,"address":[2038791,2038852,2040070,2038698],"length":1,"stats":{"Line":6}},{"line":115,"address":[2040343,2040133],"length":1,"stats":{"Line":4}},{"line":116,"address":[2040624],"length":1,"stats":{"Line":2}},{"line":117,"address":[2041319,2040701,2040804],"length":1,"stats":{"Line":5}},{"line":118,"address":[2040893,2041217],"length":1,"stats":{"Line":3}},{"line":119,"address":[2041286],"length":1,"stats":{"Line":1}},{"line":120,"address":[2041150,2040946,2040850],"length":1,"stats":{"Line":0}},{"line":121,"address":[2041081,2041018],"length":1,"stats":{"Line":0}},{"line":126,"address":[2041183,2041324],"length":1,"stats":{"Line":4}},{"line":130,"address":[2041493],"length":1,"stats":{"Line":1}},{"line":131,"address":[2041569,2046607],"length":1,"stats":{"Line":1}},{"line":132,"address":[1928512],"length":1,"stats":{"Line":0}},{"line":133,"address":[2046575,2046622,2046199,2046472,2046011,2046375],"length":1,"stats":{"Line":0}},{"line":134,"address":[1928534],"length":1,"stats":{"Line":0}},{"line":135,"address":[2046449,2047535,2046543,2047504],"length":1,"stats":{"Line":0}},{"line":137,"address":[2041710,2041624,2045377],"length":1,"stats":{"Line":3}},{"line":138,"address":[2039317,2041758,2044192,2035238,2044346,2045435],"length":1,"stats":{"Line":0}},{"line":139,"address":[2044951,2045236,2045398,2045339,2044721,2045127],"length":1,"stats":{"Line":0}},{"line":140,"address":[2045175,2035259,2044989,2044984,2039350,2044944],"length":1,"stats":{"Line":0}},{"line":141,"address":[2045213,2047760,2045307,2047791],"length":1,"stats":{"Line":0}},{"line":143,"address":[2041818,2041923,2039954,2041732],"length":1,"stats":{"Line":4}},{"line":144,"address":[1928600],"length":1,"stats":{"Line":3}},{"line":145,"address":[2044108,2042899,2042723,2043111,2042493,2043008],"length":1,"stats":{"Line":4}},{"line":146,"address":[2042756,2042761,2035301,2042947,2039416,2042716],"length":1,"stats":{"Line":4}},{"line":147,"address":[2042985,2048047,2043079,2048016],"length":1,"stats":{"Line":1}},{"line":149,"address":[2039449,2044047,2043152,2035322,2043388],"length":1,"stats":{"Line":2}},{"line":150,"address":[2043993,2046690,2039913,2039810,2043763,2039650],"length":1,"stats":{"Line":4}},{"line":151,"address":[1928666],"length":1,"stats":{"Line":4}},{"line":152,"address":[2039787,2048272,2048303,2039881],"length":1,"stats":{"Line":1}},{"line":161,"address":[2040155],"length":1,"stats":{"Line":1}},{"line":185,"address":[2429856],"length":1,"stats":{"Line":1}},{"line":191,"address":[2048788,2048970],"length":1,"stats":{"Line":2}},{"line":192,"address":[2049020],"length":1,"stats":{"Line":1}},{"line":195,"address":[2048976,2049037],"length":1,"stats":{"Line":2}},{"line":196,"address":[2049741,2049109],"length":1,"stats":{"Line":2}},{"line":203,"address":[2049142,2049065],"length":1,"stats":{"Line":2}},{"line":204,"address":[2049545,2049201],"length":1,"stats":{"Line":0}},{"line":211,"address":[2049170,2049234],"length":1,"stats":{"Line":2}},{"line":212,"address":[1923247],"length":1,"stats":{"Line":3}},{"line":213,"address":[2051243,2050451,2050344],"length":1,"stats":{"Line":2}},{"line":215,"address":[2050738,2050659],"length":1,"stats":{"Line":2}},{"line":216,"address":[2051340,2051008,2048881,2052337,2051113],"length":1,"stats":{"Line":3}},{"line":217,"address":[2051861,2052279,2051748],"length":1,"stats":{"Line":2}},{"line":219,"address":[2052072,2052954,2052226,2052165],"length":1,"stats":{"Line":4}},{"line":220,"address":[2053341,2053017],"length":1,"stats":{"Line":2}},{"line":221,"address":[2053622],"length":1,"stats":{"Line":1}},{"line":222,"address":[2053648,2053801,2053915],"length":1,"stats":{"Line":2}},{"line":223,"address":[2053768],"length":1,"stats":{"Line":1}},{"line":224,"address":[2053816,2053731,2053882],"length":1,"stats":{"Line":0}},{"line":230,"address":[2053946,2052838],"length":1,"stats":{"Line":1}},{"line":231,"address":[2052550,2053992,2054180,2054234,2052805,2052687],"length":1,"stats":{"Line":0}},{"line":232,"address":[2052412,2052773,2052382,2054173,2054213,2052598,2048902],"length":1,"stats":{"Line":0}},{"line":236,"address":[2053039],"length":1,"stats":{"Line":1}},{"line":256,"address":[2054368,2054486,2054391,2054502,2054585],"length":1,"stats":{"Line":4}},{"line":258,"address":[2054461],"length":1,"stats":{"Line":1}},{"line":278,"address":[2054742,2054624,2054758,2054647,2054841],"length":1,"stats":{"Line":4}},{"line":280,"address":[2054717],"length":1,"stats":{"Line":1}},{"line":300,"address":[2054880,2054903,2055014,2054998,2055097],"length":1,"stats":{"Line":4}},{"line":302,"address":[2054973],"length":1,"stats":{"Line":1}},{"line":323,"address":[2055136,2055159,2055353,2055254,2055270],"length":1,"stats":{"Line":4}},{"line":325,"address":[2055229],"length":1,"stats":{"Line":1}},{"line":346,"address":[2430112],"length":1,"stats":{"Line":1}},{"line":353,"address":[2055567,2055697],"length":1,"stats":{"Line":2}},{"line":357,"address":[2056185,2055750,2055633,2056599,2056266,2055769],"length":1,"stats":{"Line":3}},{"line":359,"address":[2055703,2055812],"length":1,"stats":{"Line":2}},{"line":364,"address":[2055818,2055862],"length":1,"stats":{"Line":2}},{"line":371,"address":[2055845],"length":1,"stats":{"Line":1}},{"line":392,"address":[2430224],"length":1,"stats":{"Line":1}},{"line":399,"address":[2056815,2056945],"length":1,"stats":{"Line":2}},{"line":403,"address":[1924201],"length":1,"stats":{"Line":3}},{"line":405,"address":[2056951,2057060],"length":1,"stats":{"Line":2}},{"line":410,"address":[2057066,2057110],"length":1,"stats":{"Line":2}},{"line":417,"address":[2057093],"length":1,"stats":{"Line":1}},{"line":420,"address":[2058083,2057923,2057888,2058120,2058235,2058706],"length":1,"stats":{"Line":4}},{"line":424,"address":[1925462],"length":1,"stats":{"Line":3}},{"line":425,"address":[2058572],"length":1,"stats":{"Line":1}},{"line":426,"address":[2058608],"length":1,"stats":{"Line":1}}],"covered":85,"coverable":111},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","actioncontroller","src","runtime","bluechi","mod.rs"],"content":"use common::Result;\nuse dbus::blocking::{Connection, Proxy};\nuse dbus::Path;\nuse std::time::Duration;\n\nconst DEST: \u0026str = \"org.eclipse.bluechi\";\nconst PATH: \u0026str = \"/org/eclipse/bluechi\";\nconst DEST_CONTROLLER: \u0026str = \"org.eclipse.bluechi.Controller\";\nconst DEST_NODE: \u0026str = \"org.eclipse.bluechi.Node\";\n\n/// Command structure for Bluechi operations\n///\n/// Contains the command type to execute and optional node and unit\n/// information needed to target specific components.\npub struct BluechiCmd {\n    pub command: Command,\n}\n\n/// Commands supported by the Bluechi runtime\n///\n/// Represents the various operations that can be performed\n/// on the Bluechi controller, nodes, and units.\npub enum Command {\n    ControllerReloadAllNodes,\n    UnitStart,\n    UnitStop,\n    UnitRestart,\n    UnitReload,\n}\n\nimpl Command {\n    /// Convert command enum to the corresponding D-Bus method name\n    ///\n    /// Maps each command type to its corresponding Bluechi D-Bus method name\n    /// that will be used in the actual method call.\n    ///\n    /// # Returns\n    ///\n    /// The D-Bus method name as a string slice\n    fn to_method_name(\u0026self) -\u003e \u0026str {\n        match self {\n            Command::UnitStart =\u003e \"StartUnit\",\n            Command::UnitStop =\u003e \"StopUnit\",\n            Command::UnitRestart =\u003e \"RestartUnit\",\n            Command::UnitReload =\u003e \"ReloadUnit\",\n            Command::ControllerReloadAllNodes =\u003e \"ReloadAllNodes\",\n            _ =\u003e \"Unknown\",\n        }\n    }\n}\n\n/// Handle Bluechi commands for operations\n///\n/// This function processes a single Bluechi command by:\n/// 1. Establishing a D-Bus connection to the Bluechi controller\n/// 2. Executing the appropriate operation based on the command type\n///\n/// # Arguments\n///\n/// * `scenario_name` - Name of the scenario to operate on\n/// * `node` - Name of the node to target\n/// * `bluechi_cmd` - The Bluechi command to execute\npub async fn handle_bluechi_cmd(\n    scenario_name: \u0026str,\n    node: \u0026str,\n    bluechi_cmd: BluechiCmd,\n) -\u003e Result\u003c()\u003e {\n    let conn = Connection::new_system().unwrap();\n    let bluechi = conn.with_proxy(DEST, PATH, Duration::from_millis(5000));\n    print!(\"handle_bluechi_cmd ...\\n\");\n    match bluechi_cmd.command {\n        Command::ControllerReloadAllNodes =\u003e {\n            let _ = reload_all_nodes(\u0026bluechi);\n        }\n        Command::UnitStart | Command::UnitStop | Command::UnitRestart | Command::UnitReload =\u003e {\n            let _ = workload_run(\n                \u0026conn,\n                bluechi_cmd.command.to_method_name(),\n                node,\n                \u0026bluechi,\n                scenario_name,\n            );\n        }\n    }\n    Ok(())\n}\n\n/// Execute a unit-related operation on a Bluechi node\n///\n/// Calls the specified D-Bus method on the given node proxy to perform\n/// operations like starting, stopping, restarting, or reloading a unit.\n///\n/// # Arguments\n///\n/// * `method` - The D-Bus method name to call (e.g., \"StartUnit\", \"StopUnit\")\n/// * `node_proxy` - The proxy to the Bluechi node where the unit is located\n/// * `unit_name` - The name of the unit to operate on\n///\n/// # Returns\n///\n/// * `Ok(String)` - A successful result message including the job path\n/// * `Err(...)` - If the D-Bus call fails\npub fn workload_run(\n    conn: \u0026Connection,\n    method: \u0026str,\n    node_name: \u0026str,\n    proxy: \u0026Proxy\u003c'_, \u0026Connection\u003e,\n    unit_name: \u0026str,\n) -\u003e Result\u003cString\u003e {\n    print!(\"workload_run ...\\n\");\n    let (node,): (Path,) = proxy.method_call(DEST_CONTROLLER, \"GetNode\", (\u0026node_name,))?;\n\n    let node_proxy = conn.with_proxy(DEST, node, Duration::from_millis(5000));\n\n    let (job_path,): (Path,) = node_proxy.method_call(DEST_NODE, method, (unit_name, \"replace\"))?;\n\n    Ok(format!(\"{method} '{unit_name}' : {job_path}\\n\"))\n}\n\n/// Reload all nodes managed by the Bluechi controller\n///\n/// This function:\n/// 1. Lists all nodes registered with the controller\n/// 2. Creates a proxy for each node\n/// 3. Calls the Reload method on each node\n/// 4. Collects status information for reporting\n///\n/// # Arguments\n///\n/// * `proxy` - The proxy to the Bluechi controller\n///\n/// # Returns\n///\n/// * `Ok(String)` - A successful result message listing all reloaded nodes\n/// * `Err(...)` - If any of the D-Bus calls fail\npub fn reload_all_nodes(proxy: \u0026Proxy\u003c'_, \u0026Connection\u003e) -\u003e Result\u003cString\u003e {\n    print!(\"Reloading all nodes...\\n\");\n    let (nodes,): (Vec\u003c(String, dbus::Path, String)\u003e,) =\n        proxy.method_call(DEST_CONTROLLER, \"ListNodes\", ())?;\n\n    let conn = Connection::new_system()?;\n    let mut result = String::new();\n    for (node_name, _, _) in nodes {\n        let (node,): (Path,) = proxy.method_call(DEST_CONTROLLER, \"GetNode\", (\u0026node_name,))?;\n\n        let node_proxy = conn.with_proxy(DEST, node, Duration::from_millis(5000));\n        node_proxy.method_call::\u003c(), _, _, _\u003e(DEST_NODE, \"Reload\", ())?;\n\n        result.push_str(\u0026format!(\"Node - {} is reloaded.\\n\", \u0026node_name));\n    }\n    Ok(result)\n}\n\n//UNIT TEST\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use dbus::blocking::Connection;\n    use std::time::Duration;\n\n    /// Dummy Connection (session bus)\n    fn dummy_connection() -\u003e Connection {\n        Connection::new_system().unwrap()\n    }\n\n    /// Check if BlueChi D-Bus service is available (only for tests)\n    fn is_bluechi_service_available(conn: \u0026Connection) -\u003e bool {\n        let proxy = conn.with_proxy(\n            \"org.freedesktop.DBus\",\n            \"/org/freedesktop/DBus\",\n            Duration::from_millis(5000),\n        );\n\n        let result: core::result::Result\u003c(bool,), Box\u003cdyn std::error::Error\u003e\u003e = proxy\n            .method_call(\"org.freedesktop.DBus\", \"NameHasOwner\", (DEST,))\n            .map_err(|e| Box::new(e) as Box\u003cdyn std::error::Error\u003e);\n\n        match result {\n            Ok((has_owner,)) =\u003e has_owner,\n            Err(_) =\u003e false,\n        }\n    }\n\n    /// Test handle_bluechi_cmd() with ControllerReloadAllNodes command (positive)\n    #[tokio::test]\n    async fn test_handle_bluechi_cmd_controller_reload() {\n        let scenario = \"test-scenario\";\n        let node = \"node1\";\n        let cmd = BluechiCmd {\n            command: Command::ControllerReloadAllNodes,\n        };\n\n        let result = handle_bluechi_cmd(scenario, node, cmd).await;\n        assert!(result.is_ok());\n    }\n\n    /// Test handle_bluechi_cmd() with UnitStart command (positive)\n    #[tokio::test]\n    async fn test_handle_bluechi_cmd_unit_start() {\n        let scenario = \"test-scenario\";\n        let node = \"node1\";\n        let cmd = BluechiCmd {\n            command: Command::UnitStart,\n        };\n\n        let result = handle_bluechi_cmd(scenario, node, cmd).await;\n        assert!(result.is_ok());\n    }\n\n    /// Test Command::to_method_name() for all command variants (sync test)\n    #[tokio::test]\n    async fn test_command_to_method_name() {\n        assert_eq!(Command::UnitStart.to_method_name(), \"StartUnit\");\n        assert_eq!(Command::UnitStop.to_method_name(), \"StopUnit\");\n        assert_eq!(Command::UnitRestart.to_method_name(), \"RestartUnit\");\n        assert_eq!(Command::UnitReload.to_method_name(), \"ReloadUnit\");\n\n        let unknown_cmd = Command::ControllerReloadAllNodes;\n        assert_eq!(unknown_cmd.to_method_name(), \"ReloadAllNodes\");\n    }\n\n    // ------------------- NEGATIVE TESTS -------------------\n\n    /// Negative: workload_run() with invalid node name\n    #[tokio::test]\n    async fn test_workload_run_invalid_node() {\n        let conn = dummy_connection();\n\n        if !is_bluechi_service_available(\u0026conn) {\n            println!(\"Skipping test_workload_run_invalid_node — BlueChi service unavailable.\");\n            return;\n        }\n\n        let invalid_node = \"nonexistent-node\";\n        let unit_name = \"unitA\";\n\n        let bluechi_proxy = conn.with_proxy(DEST, PATH, Duration::from_millis(5000));\n\n        let result = workload_run(\u0026conn, \"StartUnit\", invalid_node, \u0026bluechi_proxy, unit_name);\n        assert!(result.is_err());\n    }\n\n    /// Negative: workload_run() with invalid method\n    #[tokio::test]\n    async fn test_workload_run_invalid_method() {\n        let conn = dummy_connection();\n\n        if !is_bluechi_service_available(\u0026conn) {\n            println!(\"Skipping test_workload_run_invalid_method — BlueChi service unavailable.\");\n            return;\n        }\n\n        let node = \"node1\";\n        let unit_name = \"unitA\";\n        let invalid_method = \"NonExistentMethod\";\n\n        let bluechi_proxy = conn.with_proxy(DEST, PATH, Duration::from_millis(5000));\n\n        let result = workload_run(\u0026conn, invalid_method, node, \u0026bluechi_proxy, unit_name);\n        assert!(result.is_err());\n    }\n\n    /// Negative: reload_all_nodes() with missing service\n    #[tokio::test]\n    async fn test_reload_all_nodes_service_missing() {\n        let conn = dummy_connection();\n\n        // Intentionally use a WRONG DEST to simulate service missing\n        let fake_dest = \"org.eclipse.fakebluechi\";\n        let proxy = conn.with_proxy(fake_dest, PATH, Duration::from_millis(5000));\n\n        let result = reload_all_nodes(\u0026proxy);\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":40,"address":[2216610,2216576],"length":1,"stats":{"Line":1}},{"line":41,"address":[2216581],"length":1,"stats":{"Line":1}},{"line":42,"address":[2216635],"length":1,"stats":{"Line":1}},{"line":43,"address":[2216658],"length":1,"stats":{"Line":1}},{"line":44,"address":[2216681],"length":1,"stats":{"Line":1}},{"line":45,"address":[2216704],"length":1,"stats":{"Line":1}},{"line":46,"address":[2216612],"length":1,"stats":{"Line":1}},{"line":63,"address":[2216736],"length":1,"stats":{"Line":1}},{"line":68,"address":[2536833,2536748],"length":1,"stats":{"Line":2}},{"line":69,"address":[2536868,2536934],"length":1,"stats":{"Line":2}},{"line":70,"address":[2536991,2537061],"length":1,"stats":{"Line":2}},{"line":71,"address":[2537080],"length":1,"stats":{"Line":2}},{"line":73,"address":[2537113,2537153],"length":1,"stats":{"Line":2}},{"line":78,"address":[2537128],"length":1,"stats":{"Line":1}},{"line":85,"address":[2537160],"length":1,"stats":{"Line":1}},{"line":103,"address":[2218118,2218172,2216832],"length":1,"stats":{"Line":1}},{"line":110,"address":[2216947],"length":1,"stats":{"Line":1}},{"line":111,"address":[2217003],"length":1,"stats":{"Line":1}},{"line":113,"address":[2217251,2217320,2218153],"length":1,"stats":{"Line":0}},{"line":115,"address":[2217603,2217431],"length":1,"stats":{"Line":0}},{"line":117,"address":[2217750,2217818],"length":1,"stats":{"Line":0}},{"line":136,"address":[2220525,2218208,2220875],"length":1,"stats":{"Line":1}},{"line":137,"address":[2218238],"length":1,"stats":{"Line":1}},{"line":138,"address":[2218296],"length":1,"stats":{"Line":1}},{"line":141,"address":[2218532,2220848,2218608],"length":1,"stats":{"Line":2}},{"line":142,"address":[2218872],"length":1,"stats":{"Line":1}},{"line":143,"address":[2219151,2218923,2219024],"length":1,"stats":{"Line":3}},{"line":144,"address":[2219225,2220621,2219457],"length":1,"stats":{"Line":2}},{"line":146,"address":[2220577,2219681,2219612],"length":1,"stats":{"Line":1}},{"line":147,"address":[2219795,2219887],"length":1,"stats":{"Line":2}},{"line":149,"address":[2219998],"length":1,"stats":{"Line":0}},{"line":151,"address":[2219302],"length":1,"stats":{"Line":0}}],"covered":27,"coverable":32},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","actioncontroller","src","runtime","mod.rs"],"content":"pub mod bluechi;\npub mod nodeagent;\n\n/// Initialize the runtime module for workload operations\n///\n/// Sets up the runtime components for interacting with both Bluechi and NodeAgent\n/// backends. This function ensures that the appropriate runtime modules are\n/// ready to handle workload operations for their respective node types.\n///\n/// # Returns\n///\n/// * `Ok(())` if initialization was successful\n/// * `Err(...)` if initialization failed\n///\n/// # Errors\n///\n/// Returns an error if:\n/// - Configuration for either runtime system is invalid\n/// - Connection to runtime systems fails\npub async fn init() -\u003e common::Result\u003c()\u003e {\n    // TODO: Implementation\n    Ok(())\n}\n\n//UNIT TEST\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::runtime::init;\n    // Positive test case for init() function\n    #[tokio::test]\n    async fn test_init_success() {\n        let result = init().await;\n        assert!(\n            result.is_ok(),\n            \"Expected init() to succeed, got: {:?}\",\n            result\n        );\n    }\n\n    // Negative test case (This will be based on our production logic in future)\n    #[tokio::test]\n    async fn test_init_failure() {\n        // We Have to Modify our init() function to return a failure under specific conditions\n        // For now, it's a placeholder assuming it always returns Ok.\n        // This test will assert that the result is an error (which isn't true yet)\n        let result = init().await;\n\n        // Assuming When we modify the init function later to return an error:\n        // assert!(result.is_err(), \"Expected init() to fail, got: {:?}\", result);\n    }\n}\n","traces":[{"line":20,"address":[1845520],"length":1,"stats":{"Line":3}},{"line":22,"address":[2869577],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","actioncontroller","src","runtime","nodeagent","mod.rs"],"content":"use common::Result;\nuse std::collections::HashMap;\n\n/// Runtime implementation for NodeAgent API interactions\n///\n/// Handles workload operations for nodes managed by NodeAgent,\n/// making gRPC calls to the NodeAgent service to perform\n/// operations like creating, starting, stopping, and deleting workloads.\n\npub struct NodeAgentRuntime {\n    /// Connection information for each NodeAgent\n    node_connections: HashMap\u003cString, String\u003e,\n    /// Cache of workload information per node\n    workload_cache: HashMap\u003cString, String\u003e,\n}\n\nimpl NodeAgentRuntime {\n    /// Create a new NodeAgentRuntime instance\n    ///\n    /// Initializes a runtime handler for NodeAgent operations with empty\n    /// node connection and workload cache maps.\n    ///\n    /// # Returns\n    ///\n    /// A new NodeAgentRuntime instance\n    pub fn new() -\u003e Self {\n        Self {\n            node_connections: HashMap::new(),\n            workload_cache: HashMap::new(),\n        }\n    }\n\n    /// Initialize connection information for NodeAgent nodes\n    ///\n    /// # Arguments\n    ///\n    /// * `nodes` - List of node names to initialize connections for\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if initialization was successful\n    /// * `Err(...)` if initialization failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - Node information is invalid\n    /// - Connection setup fails\n    async fn init(\u0026mut self) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        Ok(())\n    }\n\n    /// Create a workload using NodeAgent API\n    ///\n    /// Reads the scenario definition and creates the corresponding workload\n    /// using the NodeAgent API.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario to create workload for\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if workload creation was successful\n    /// * `Err(...)` if workload creation failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The scenario definition is invalid\n    /// - The NodeAgent API call fails\n    /// - The workload already exists\n    async fn create_workload(\u0026self, scenario_name: \u0026str) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        Ok(())\n    }\n\n    /// Delete a workload using NodeAgent API\n    ///\n    /// Removes an existing workload through the NodeAgent API.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario that owns the workload\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if workload deletion was successful\n    /// * `Err(...)` if workload deletion failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The workload does not exist\n    /// - The NodeAgent API call fails\n    async fn delete_workload(\u0026self, scenario_name: \u0026str) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n\n        Ok(())\n    }\n\n    /// Restart a workload using NodeAgent API\n    ///\n    /// Restarts an existing workload through the NodeAgent API.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario that owns the workload\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if workload restart was successful\n    /// * `Err(...)` if workload restart failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The workload does not exist\n    /// - The NodeAgent API call fails\n    async fn restart_workload(\u0026self, scenario_name: \u0026str) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        Ok(())\n    }\n\n    /// Pause a workload using NodeAgent API\n    ///\n    /// Suspends execution of a workload through the NodeAgent API.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario that owns the workload\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if workload pause was successful\n    /// * `Err(...)` if workload pause failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The workload does not exist\n    /// - The workload is not in a pausable state\n    /// - The NodeAgent API call fails\n    async fn pause_workload(\u0026self, scenario_name: \u0026str) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        Ok(())\n    }\n\n    /// Start a workload using NodeAgent API\n    ///\n    /// Starts an existing workload through the NodeAgent API.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario that owns the workload\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if workload start was successful\n    /// * `Err(...)` if workload start failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The workload does not exist\n    /// - The workload is already running\n    /// - The NodeAgent API call fails\n    pub async fn start_workload(\u0026self, scenario_name: \u0026str) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        Ok(())\n    }\n\n    /// Stop a workload using NodeAgent API\n    ///\n    /// Stops an existing workload through the NodeAgent API.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario that owns the workload\n    ///\n    /// # Returns\n    ///\n    /// * `Ok(())` if workload stop was successful\n    /// * `Err(...)` if workload stop failed\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if:\n    /// - The workload does not exist\n    /// - The workload is already stopped\n    /// - The NodeAgent API call fails\n    pub async fn stop_workload(\u0026self, scenario_name: \u0026str) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        Ok(())\n    }\n}\n\n//UNIT TEST\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use common::Result;\n\n    use tokio;\n\n    #[tokio::test]\n    async fn test_new_initializes_empty() {\n        let runtime = NodeAgentRuntime::new();\n        assert!(\n            runtime.node_connections.is_empty(),\n            \"node_connections should be empty\"\n        );\n        assert!(\n            runtime.workload_cache.is_empty(),\n            \"workload_cache should be empty\"\n        );\n    }\n\n    // ------------------------- init() -------------------------\n\n    #[tokio::test]\n    async fn test_init_returns_ok() {\n        let mut runtime = NodeAgentRuntime::new();\n        let result = runtime.init().await;\n        assert!(result.is_ok(), \"init() should return Ok\");\n    }\n\n    #[tokio::test]\n    async fn test_init_invalid_node_should_fail() {\n        let mut runtime = NodeAgentRuntime::new();\n\n        // Simulate invalid node info if implementation later checks connections\n        runtime\n            .node_connections\n            .insert(\"invalid_node\".to_string(), \"\".to_string());\n\n        let result = runtime.init().await;\n        // Replace this is_ok() with is_err() once real validation exists\n        assert!(\n            result.is_ok(),\n            \"TODO: expect Err once init validates node info\"\n        );\n    }\n\n    // ------------------------- create_workload() -------------------------\n\n    #[tokio::test]\n    async fn test_create_workload_returns_ok() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.create_workload(\"test_scenario\").await;\n        assert!(result.is_ok(), \"create_workload() should return Ok\");\n    }\n\n    #[tokio::test]\n    async fn test_create_workload_invalid_scenario_should_fail() {\n        let runtime = NodeAgentRuntime::new();\n\n        let result = runtime.create_workload(\"\").await; // Empty scenario = invalid\n        assert!(\n            result.is_ok(),\n            \"TODO: expect Err once create_workload validates input\"\n        );\n    }\n\n    // ------------------------- delete_workload() -------------------------\n\n    #[tokio::test]\n    async fn test_delete_workload_returns_ok() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.delete_workload(\"test_scenario\").await;\n        assert!(result.is_ok(), \"delete_workload() should return Ok\");\n    }\n\n    #[tokio::test]\n    async fn test_delete_workload_nonexistent_should_fail() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.delete_workload(\"nonexistent_scenario\").await;\n        assert!(\n            result.is_ok(),\n            \"TODO: expect Err when workload does not exist\"\n        );\n    }\n\n    // ------------------------- restart_workload() -------------------------\n\n    #[tokio::test]\n    async fn test_restart_workload_returns_ok() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.restart_workload(\"test_scenario\").await;\n        assert!(result.is_ok(), \"restart_workload() should return Ok\");\n    }\n\n    #[tokio::test]\n    async fn test_restart_workload_nonexistent_should_fail() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.restart_workload(\"nonexistent_scenario\").await;\n        assert!(\n            result.is_ok(),\n            \"TODO: expect Err when workload does not exist\"\n        );\n    }\n\n    // ------------------------- pause_workload() -------------------------\n\n    #[tokio::test]\n    async fn test_pause_workload_returns_ok() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.pause_workload(\"test_scenario\").await;\n        assert!(result.is_ok(), \"pause_workload() should return Ok\");\n    }\n\n    #[tokio::test]\n    async fn test_pause_workload_nonexistent_should_fail() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.pause_workload(\"nonexistent_scenario\").await;\n        assert!(\n            result.is_ok(),\n            \"TODO: expect Err when workload does not exist\"\n        );\n    }\n\n    // ------------------------- start_workload() -------------------------\n\n    #[tokio::test]\n    async fn test_start_workload_returns_ok() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.start_workload(\"test_scenario\").await;\n        assert!(result.is_ok(), \"start_workload() should return Ok\");\n    }\n\n    #[tokio::test]\n    async fn test_start_workload_nonexistent_should_fail() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.start_workload(\"nonexistent_scenario\").await;\n        assert!(\n            result.is_ok(),\n            \"TODO: expect Err when workload does not exist\"\n        );\n    }\n\n    // ------------------------- stop_workload() -------------------------\n\n    #[tokio::test]\n    async fn test_stop_workload_returns_ok() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.stop_workload(\"test_scenario\").await;\n        assert!(result.is_ok(), \"stop_workload() should return Ok\");\n    }\n\n    #[tokio::test]\n    async fn test_stop_workload_nonexistent_should_fail() {\n        let runtime = NodeAgentRuntime::new();\n        let result = runtime.stop_workload(\"nonexistent_scenario\").await;\n        assert!(\n            result.is_ok(),\n            \"TODO: expect Err when workload does not exist\"\n        );\n    }\n}\n","traces":[{"line":26,"address":[2088481,2088336,2088475],"length":1,"stats":{"Line":2}},{"line":28,"address":[2088352],"length":1,"stats":{"Line":1}},{"line":29,"address":[2088381],"length":1,"stats":{"Line":3}},{"line":49,"address":[2088496,2088504],"length":1,"stats":{"Line":4}},{"line":51,"address":[2851749],"length":1,"stats":{"Line":1}},{"line":74,"address":[2088512,2088530],"length":1,"stats":{"Line":8}},{"line":76,"address":[2851916],"length":1,"stats":{"Line":2}},{"line":97,"address":[2088578,2088560],"length":1,"stats":{"Line":4}},{"line":100,"address":[2852076],"length":1,"stats":{"Line":1}},{"line":121,"address":[2088608,2088626],"length":1,"stats":{"Line":7}},{"line":123,"address":[2852236],"length":1,"stats":{"Line":2}},{"line":145,"address":[2088656,2088674],"length":1,"stats":{"Line":4}},{"line":147,"address":[2852396],"length":1,"stats":{"Line":1}},{"line":169,"address":[2088704,2088722],"length":1,"stats":{"Line":4}},{"line":171,"address":[2852556],"length":1,"stats":{"Line":1}},{"line":193,"address":[2088752,2088770],"length":1,"stats":{"Line":4}},{"line":195,"address":[2852716],"length":1,"stats":{"Line":1}}],"covered":17,"coverable":17},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","build.rs"],"content":"// Refactored build.rs file - Modular structure\nuse std::env;\nuse std::fs;\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\n\n// Include modules\nmod build_scripts;\n\nuse build_scripts::generator::{\n    create_empty_modules, generate_dds_module, generate_type_metadata_registry,\n    generate_type_registry,\n};\nuse build_scripts::idl::collect_idl_files;\nuse build_scripts::settings::load_dds_settings;\n\nfn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    println!(\"cargo:rerun-if-changed=src/vehicle/dds/idl\");\n    // Ensure build script reruns if settings.yaml changes (relative to project root)\n    let manifest_dir = env::var(\"CARGO_MANIFEST_DIR\").expect(\"CARGO_MANIFEST_DIR not set\");\n    let settings_path = PathBuf::from(\u0026manifest_dir)\n        .parent() // go up to 'player'\n        .and_then(|p| p.parent()) // go up to 'src'\n        .and_then(|p| p.parent()) // go up to 'pullpiri'\n        .map(|p| p.join(\"src/settings.yaml\"))\n        .ok_or(\"Failed to resolve project root for settings.yaml\")?;\n    println!(\"cargo:rerun-if-changed={}\", settings_path.display());\n\n    // Check current working directory (project root)\n    let current_dir = env::current_dir().expect(\"Cannot determine current directory\");\n    println!(\"Current working directory: {:?}\", current_dir);\n\n    // Load settings\n    let (rel_idl_dir, domain_id, custom_out_dir) = load_dds_settings()?;\n\n    // Convert relative path to absolute path based on current working directory\n    let idl_dir = current_dir.join(\u0026rel_idl_dir);\n    println!(\"IDL directory (absolute): {:?}\", idl_dir);\n    println!(\"Domain ID: {}\", domain_id);\n\n    // Check IDL directory (do not create if not exists)\n    if !idl_dir.exists() {\n        println!(\"Warning: IDL directory doesn't exist: {:?}\", idl_dir);\n        println!(\"No files will be processed\");\n    } else {\n        // Output absolute path (for debugging)\n        if let Ok(abs_path) = idl_dir.canonicalize() {\n            println!(\"IDL directory absolute path: {:?}\", abs_path);\n        }\n    }\n\n    // Configure output directory (use the one specified in settings.yaml if provided)\n    let out_dir = match custom_out_dir {\n        Some(dir) =\u003e {\n            // Use custom directory if specified\n            let path = PathBuf::from(\u0026dir);\n            println!(\"Using custom output directory: {}\", path.display());\n\n            // Create directory if it doesn't exist\n            if !path.exists() {\n                println!(\"Creating custom output directory\");\n                fs::create_dir_all(\u0026path)?;\n            }\n\n            // Set environment variable OUT_DIR (so other build scripts can use it too)\n            println!(\"cargo:rustc-env=OUT_DIR={}\", path.display());\n\n            dir\n        }\n        None =\u003e {\n            // Use default OUT_DIR environment variable\n            let dir = env::var(\"OUT_DIR\").expect(\"OUT_DIR environment variable not found\");\n            println!(\"Using default OUT_DIR: {}\", dir);\n            dir\n        }\n    };\n\n    // Generate DDS module files (process only existing IDL files)\n    println!(\"\\n=== Generating DDS modules ===\");\n    match generate_dds_module(\u0026out_dir, \u0026idl_dir) {\n        Ok(_) =\u003e println!(\"Successfully generated DDS modules\"),\n        Err(e) =\u003e {\n            println!(\"Error generating DDS modules: {:?}\", e);\n            // Continue with build process even on failure (create empty modules)\n            let modules_path = Path::new(\u0026out_dir).join(\"dds_modules.rs\");\n            let types_path = Path::new(\u0026out_dir).join(\"dds_types.rs\");\n            if !modules_path.exists() || !types_path.exists() {\n                create_empty_modules(\u0026out_dir)?;\n            }\n        }\n    }\n\n    // Create build information file\n    let info_path = Path::new(\u0026out_dir).join(\"dds_build_info.txt\");\n    let mut info_file = fs::File::create(info_path)?;\n    writeln!(info_file, \"DDS Build Information\")?;\n    writeln!(info_file, \"--------------------\")?;\n    writeln!(info_file, \"IDL Directory: {:?}\", idl_dir)?;\n    writeln!(info_file, \"Output Directory: {}\", out_dir)?;\n    writeln!(info_file, \"Domain ID: {}\", domain_id)?;\n\n    if idl_dir.exists() {\n        let idl_files = collect_idl_files(\u0026idl_dir)?;\n\n        generate_type_metadata_registry(\u0026out_dir, \u0026idl_files)?;\n        // Generate DDS type registry based on IDL files\n        generate_type_registry(\u0026out_dir, \u0026idl_files)?;\n\n        // Enable feature flag indicating type registry exists\n        println!(\"cargo:rustc-cfg=feature=\\\"dds_type_registry_exists\\\"\");\n\n        writeln!(info_file, \"Found IDL Files: {}\", idl_files.len())?;\n        for file in \u0026idl_files {\n            writeln!(info_file, \"  - {:?}\", file)?;\n        }\n    } else {\n        writeln!(info_file, \"IDL Directory does not exist\")?;\n    }\n\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","build_scripts","generator.rs"],"content":"// Code generation module\nuse std::collections::HashMap;\nuse std::fs;\nuse std::io::Write;\nuse std::path::{Path, PathBuf};\n\nuse crate::build_scripts::idl::{collect_idl_files, IdlParser};\nuse crate::build_scripts::types::idl_to_rust_type;\n\n/// Function to generate struct file\npub fn generate_struct_file(\n    out_dir: \u0026str,\n    file_name: \u0026str,\n    struct_name: \u0026str,\n    fields: \u0026HashMap\u003cString, String\u003e,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let output_path = Path::new(out_dir).join(format!(\"{}.rs\", file_name));\n    let mut file = fs::File::create(output_path)?;\n\n    // Write struct header with updated derive attributes\n    writeln!(file, \"use serde::{{Deserialize, Serialize}};\")?;\n    writeln!(\n        file,\n        \"use dust_dds::topic_definition::type_support::{{DdsType, DdsSerialize, DdsDeserialize}};\"\n    )?;\n    writeln!(file, \"\")?;\n    writeln!(\n        file,\n        \"#[derive(Debug, Clone, Serialize, Deserialize, DdsType, Default)]\"\n    )?;\n    writeln!(file, \"pub struct {} {{\", struct_name)?;\n\n    // Write fields\n    for (name, field_type) in fields {\n        let rust_type = idl_to_rust_type(field_type);\n        writeln!(file, \"    pub {}: {},\", name, rust_type)?;\n    }\n\n    // Close struct (removed manual impl of DdsType)\n    writeln!(file, \"}}\")?;\n\n    Ok(())\n}\n\n/// 타입 레지스트리 생성 함수\npub fn generate_type_registry(\n    out_dir: \u0026str,\n    idl_files: \u0026[PathBuf],\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let registry_path = Path::new(out_dir).join(\"dds_type_registry.rs\");\n    let mut registry_file = fs::File::create(\u0026registry_path)?;\n\n    writeln!(registry_file, \"// Auto-generated DDS type registry\")?;\n    writeln!(registry_file, \"// build.rs에 의해 생성됨\")?;\n    writeln!(registry_file, \"\")?;\n    writeln!(\n        registry_file,\n        \"use dust_dds::topic_definition::type_support::{{DdsType, DdsSerialize, DdsDeserialize}};\"\n    )?;\n    writeln!(registry_file, \"use serde::{{Deserialize, Serialize}};\")?;\n    writeln!(registry_file, \"use super::dds_types::*;\")?;\n    writeln!(registry_file, \"use std::sync::Arc;\")?;\n    writeln!(\n        registry_file,\n        \"use crate::vehicle::dds::listener::GenericTopicListener;\"\n    )?;\n    writeln!(registry_file, \"use crate::vehicle::dds::DdsData;\")?;\n    writeln!(registry_file, \"\")?;\n\n    // 타입별 리스너 생성 함수\n    writeln!(registry_file, \"pub fn create_typed_listener(type_name: \u0026str, topic_name: String, tx: Sender\u003cDdsData\u003e, domain_id: i32) -\u003e Option\u003cBox\u003cdyn DdsTopicListener\u003e\u003e {{\")?;\n    writeln!(\n        registry_file,\n        \"    println!(\\\"Generated - Creating listener for type: {{}}\\\", type_name);\"\n    )?;\n    writeln!(registry_file, \"    match type_name {{\")?;\n\n    // 각 IDL 파일에 대한 매핑 생성\n    for idl_file in idl_files {\n        if let Some(file_stem) = idl_file.file_stem() {\n            let module_name = file_stem.to_string_lossy();\n\n            // IDL 파일 파싱\n            if let Ok(dds_data) = IdlParser::parse_idl_file(idl_file) {\n                let struct_name = \u0026dds_data.name;\n\n                // 타입 매핑 추가\n                writeln!(registry_file, \"        \\\"{}\\\" =\u003e {{\", struct_name)?;\n                writeln!(\n                    registry_file,\n                    \"            let listener = Box::new(GenericTopicListener::\u003c{}::{}\u003e::new(\",\n                    module_name, struct_name\n                )?;\n                writeln!(registry_file, \"                topic_name,\")?;\n                writeln!(registry_file, \"                type_name.to_string(),\")?;\n                writeln!(registry_file, \"                tx,\")?;\n                writeln!(registry_file, \"                domain_id,\")?;\n                writeln!(registry_file, \"            ));\")?;\n                writeln!(registry_file, \"            Some(listener)\")?;\n                writeln!(registry_file, \"        }},\")?;\n            }\n        }\n    }\n\n    // 기본 매핑 종료\n    writeln!(registry_file, \"        _ =\u003e None,\")?;\n    writeln!(registry_file, \"    }}\")?;\n    writeln!(registry_file, \"}}\")?;\n\n    Ok(())\n}\n\n/// Function to generate DDS module - processes only existing files\npub fn generate_dds_module(\n    out_dir: \u0026str,\n    idl_dir: \u0026Path,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    use crate::build_scripts::idl::get_idl_files;\n\n    // *** 여기서 get_idl_files를 명시적으로 호출 ***\n    println!(\"Collecting IDL files using get_idl_files...\");\n    let idl_type_paths = get_idl_files(idl_dir)?;\n\n    // 파일 경로 추출\n    let idl_files: Vec\u003cPathBuf\u003e = idl_type_paths\n        .iter()\n        .map(|(_, path)| PathBuf::from(path))\n        .collect();\n\n    println!(\"Found {} IDL files from get_idl_files\", idl_files.len());\n\n    if idl_files.is_empty() {\n        println!(\"No IDL files to process, creating minimal empty module structure\");\n\n        // Create module file (empty module, no placeholders)\n        let modules_path = Path::new(out_dir).join(\"dds_modules.rs\");\n        let mut modules_file = fs::File::create(\u0026modules_path)?;\n\n        writeln!(modules_file, \"// Auto-generated DDS module file\")?;\n        writeln!(modules_file, \"// Generated by build.rs\")?;\n        writeln!(modules_file, \"// Warning: No available IDL files\")?;\n\n        // Create type module (no placeholder types)\n        let types_path = Path::new(out_dir).join(\"dds_types.rs\");\n        let mut types_file = fs::File::create(\u0026types_path)?;\n\n        writeln!(types_file, \"// Auto-generated DDS type module\")?;\n        writeln!(types_file, \"// Generated by build.rs\")?;\n        writeln!(types_file, \"// Warning: No available IDL files\")?;\n        writeln!(types_file, \"// This is an empty module\")?;\n        writeln!(types_file, \"include!(\\\"dds_modules.rs\\\");\")?;\n\n        return Ok(());\n    }\n\n    // 모듈 파일 생성\n    let modules_path = Path::new(out_dir).join(\"dds_modules.rs\");\n    let mut modules_file = fs::File::create(\u0026modules_path)?;\n\n    writeln!(modules_file, \"// Auto-generated DDS module file\")?;\n    writeln!(modules_file, \"// build.rs에 의해 생성됨\")?;\n    writeln!(modules_file, \"\")?;\n\n    // 각 IDL 파일에 대한 모듈 생성\n    for idl_file in \u0026idl_files {\n        println!(\"Processing IDL file: {:?}\", idl_file);\n        let file_stem = idl_file.file_stem().unwrap().to_string_lossy();\n\n        // IDL 파일 파싱\n        let dds_data = match IdlParser::parse_idl_file(idl_file) {\n            Ok(data) =\u003e {\n                println!(\n                    \"Successfully parsed IDL file: {} (struct: {})\",\n                    file_stem, data.name\n                );\n                data\n            }\n            Err(e) =\u003e {\n                println!(\"Error parsing IDL file {}: {:?}\", file_stem, e);\n                continue;\n            }\n        };\n\n        if dds_data.fields.is_empty() {\n            println!(\"Warning: No fields found in struct {}\", dds_data.name);\n        }\n\n        // 구조체 파일 생성\n        if let Err(e) = generate_struct_file(out_dir, \u0026file_stem, \u0026dds_data.name, \u0026dds_data.fields)\n        {\n            println!(\"Error generating struct file for {}: {:?}\", file_stem, e);\n            continue;\n        }\n\n        // 모듈에 추가\n        writeln!(modules_file, \"pub mod {} {{\", file_stem)?;\n        writeln!(modules_file, \"    include!(\\\"{}.rs\\\");\", file_stem)?;\n        writeln!(modules_file, \"}}\")?;\n    }\n\n    // Create a types module that includes all the generated modules\n    let types_path = Path::new(out_dir).join(\"dds_types.rs\");\n    let mut types_file = fs::File::create(\u0026types_path)?;\n\n    writeln!(types_file, \"// Auto-generated DDS type module\")?;\n    writeln!(types_file, \"// build.rs에 의해 생성됨\")?;\n    writeln!(types_file, \"\")?;\n    writeln!(types_file, \"// Include generated modules\")?;\n    writeln!(types_file, \"include!(\\\"dds_modules.rs\\\");\")?;\n\n    println!(\"Successfully generated DDS modules in {}\", out_dir);\n\n    // 생성된 파일 검증\n    verify_generated_files(out_dir, \u0026modules_path, \u0026types_path)?;\n\n    Ok(())\n}\n\n/// 타입 메타데이터 레지스트리 생성\npub fn generate_type_metadata_registry(\n    out_dir: \u0026str,\n    idl_files: \u0026[PathBuf],\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    let registry_path = Path::new(out_dir).join(\"dds_type_metadata.rs\");\n    let mut registry_file = fs::File::create(\u0026registry_path)?;\n\n    writeln!(registry_file, \"// Auto-generated DDS type metadata\")?;\n    writeln!(registry_file, \"use std::collections::HashMap;\")?;\n    writeln!(registry_file, \"\")?;\n    writeln!(registry_file, \"pub struct TypeMetadata {{\")?;\n    writeln!(registry_file, \"    pub name: String,\")?;\n    writeln!(registry_file, \"    pub module: String,\")?;\n    writeln!(registry_file, \"    pub fields: HashMap\u003cString, String\u003e,\")?;\n    writeln!(registry_file, \"}}\")?;\n    writeln!(registry_file, \"\")?;\n\n    writeln!(\n        registry_file,\n        \"pub fn get_type_metadata() -\u003e HashMap\u003cString, TypeMetadata\u003e {{\"\n    )?;\n    writeln!(registry_file, \"    let mut metadata = HashMap::new();\")?;\n    writeln!(registry_file, \"    let mut fields;\")?;\n\n    // 각 타입에 대한 메타데이터 추가\n    for idl_file in idl_files {\n        if let Some(file_stem) = idl_file.file_stem() {\n            let module_name = file_stem.to_string_lossy();\n\n            // IDL 파일 파싱\n            if let Ok(dds_data) = IdlParser::parse_idl_file(idl_file) {\n                let struct_name = \u0026dds_data.name;\n\n                writeln!(registry_file, \"    fields = HashMap::new();\")?;\n\n                // 필드 정보 추가\n                for (field_name, field_type) in \u0026dds_data.fields {\n                    let rust_type = idl_to_rust_type(field_type);\n                    writeln!(\n                        registry_file,\n                        \"    fields.insert(\\\"{}\\\".to_string(), \\\"{}\\\".to_string());\",\n                        field_name, rust_type\n                    )?;\n                }\n\n                // 메타데이터 객체 추가\n                writeln!(\n                    registry_file,\n                    \"    metadata.insert(\\\"{}\\\".to_string(), TypeMetadata {{\",\n                    struct_name\n                )?;\n                writeln!(\n                    registry_file,\n                    \"        name: \\\"{}\\\".to_string(),\",\n                    struct_name\n                )?;\n                writeln!(\n                    registry_file,\n                    \"        module: \\\"{}\\\".to_string(),\",\n                    module_name\n                )?;\n                writeln!(registry_file, \"        fields,\")?;\n                writeln!(registry_file, \"    }});\")?;\n            }\n        }\n    }\n\n    writeln!(registry_file, \"    metadata\")?;\n    writeln!(registry_file, \"}}\")?;\n\n    Ok(())\n}\n\n/// 생성된 파일 검증\npub fn verify_generated_files(\n    out_dir: \u0026str,\n    modules_path: \u0026Path,\n    types_path: \u0026Path,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // 파일 존재 확인\n    if !modules_path.exists() || !types_path.exists() {\n        println!(\"Warning: Expected output files were not created:\");\n        println!(\"  dds_modules.rs exists: {}\", modules_path.exists());\n        println!(\"  dds_types.rs exists: {}\", types_path.exists());\n        return Err(\"Output files were not created properly\".into());\n    }\n\n    // 모듈 파일 내용 확인\n    let modules_content = fs::read_to_string(modules_path)?;\n    println!(\"dds_modules.rs size: {} bytes\", modules_content.len());\n    if modules_content.lines().count() \u003c 5 {\n        println!(\n            \"Warning: dds_modules.rs seems too short (only {} lines)\",\n            modules_content.lines().count()\n        );\n    }\n\n    // 출력 디렉토리 내용 확인\n    println!(\"Files in output directory:\");\n    for entry in fs::read_dir(Path::new(out_dir))? {\n        let entry = entry?;\n        println!(\"  {:?}\", entry.path());\n    }\n\n    Ok(())\n}\n\n/// Create empty module files - no placeholders or temporary structs\npub fn create_empty_modules(out_dir: \u0026str) -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Create dds_modules.rs\n    let modules_path = Path::new(out_dir).join(\"dds_modules.rs\");\n    let mut modules_file = fs::File::create(\u0026modules_path)?;\n\n    writeln!(modules_file, \"// Empty module (No IDL files found)\")?;\n    writeln!(modules_file, \"// No types defined\")?;\n\n    // Create dds_types.rs\n    let types_path = Path::new(out_dir).join(\"dds_types.rs\");\n    let mut types_file = fs::File::create(\u0026types_path)?;\n\n    writeln!(types_file, \"// Empty type module (No IDL files found)\")?;\n    writeln!(types_file, \"include!(\\\"dds_modules.rs\\\");\")?;\n\n    // Create dds_type_registry.rs (empty registry)\n    let registry_path = Path::new(out_dir).join(\"dds_type_registry.rs\");\n    let mut registry_file = fs::File::create(\u0026registry_path)?;\n\n    writeln!(\n        registry_file,\n        \"// Empty DDS type registry (No IDL files found)\"\n    )?;\n    writeln!(\n        registry_file,\n        \"use dust_dds::topic_definition::type_support::{{DdsType, DdsSerialize, DdsDeserialize}};\"\n    )?;\n    writeln!(registry_file, \"use serde::{{Deserialize, Serialize}};\")?;\n    writeln!(registry_file, \"use std::sync::Arc;\")?;\n    writeln!(\n        registry_file,\n        \"use crate::vehicle::dds::listener::GenericTopicListener;\"\n    )?;\n    writeln!(registry_file, \"use crate::vehicle::dds::DdsData;\")?;\n    writeln!(registry_file, \"\")?;\n    writeln!(registry_file, \"pub fn create_typed_listener(type_name: \u0026str, topic_name: String, tx: Sender\u003cDdsData\u003e, domain_id: i32) -\u003e Option\u003cBox\u003cdyn DdsTopicListener\u003e\u003e {{\")?;\n    writeln!(registry_file, \"    // Empty registry - always returns None\")?;\n    writeln!(registry_file, \"    match type_name {{\")?;\n    writeln!(registry_file, \"        _ =\u003e None,\")?;\n    writeln!(registry_file, \"    }}\")?;\n    writeln!(registry_file, \"}}\")?;\n    writeln!(registry_file, \"\")?;\n\n    // Create dds_type_metadata.rs (empty metadata)\n    let metadata_path = Path::new(out_dir).join(\"dds_type_metadata.rs\");\n    let mut metadata_file = fs::File::create(\u0026metadata_path)?;\n\n    writeln!(\n        metadata_file,\n        \"// Empty DDS type metadata (No IDL files found)\"\n    )?;\n    writeln!(metadata_file, \"use std::collections::HashMap;\")?;\n    writeln!(metadata_file, \"\")?;\n    writeln!(metadata_file, \"pub struct TypeMetadata {{\")?;\n    writeln!(metadata_file, \"    pub name: String,\")?;\n    writeln!(metadata_file, \"    pub module: String,\")?;\n    writeln!(metadata_file, \"    pub fields: HashMap\u003cString, String\u003e,\")?;\n    writeln!(metadata_file, \"}}\")?;\n    writeln!(metadata_file, \"\")?;\n    writeln!(\n        metadata_file,\n        \"pub fn get_type_metadata() -\u003e HashMap\u003cString, TypeMetadata\u003e {{\"\n    )?;\n    writeln!(metadata_file, \"    HashMap::new()  // Empty metadata\")?;\n    writeln!(metadata_file, \"}}\")?;\n\n    println!(\"Created empty module files (no placeholder types)\");\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","build_scripts","idl.rs"],"content":"// Module for IDL parsing\nuse crate::build_scripts::types::DdsData;\nuse std::fs;\nuse std::path::{Path, PathBuf};\n\n/// IDL parser implementation\npub struct IdlParser;\n\nimpl IdlParser {\n    /// Parse IDL file\n    pub fn parse_idl_file(file_path: \u0026Path) -\u003e Result\u003cDdsData, Box\u003cdyn std::error::Error\u003e\u003e {\n        let content = fs::read_to_string(file_path)?;\n        let mut lines = content.lines();\n\n        // Struct name extraction\n        let mut struct_name = String::new();\n        let mut fields = std::collections::HashMap::new();\n\n        // Find struct definition\n        while let Some(line) = lines.next() {\n            let line = line.trim();\n\n            // Look for struct definition\n            if let Some(pos) = line.find(\"struct\") {\n                let remaining = \u0026line[pos + \"struct\".len()..].trim();\n                if let Some(end_pos) = remaining.find('{') {\n                    struct_name = remaining[..end_pos].trim().to_string();\n                    break;\n                } else {\n                    struct_name = remaining.to_string();\n                    break;\n                }\n            }\n        }\n\n        // Find fields\n        let mut inside_struct = false;\n        for line in content.lines() {\n            let line = line.trim();\n\n            // Skip empty lines and comments\n            if line.is_empty() || line.starts_with(\"//\") {\n                continue;\n            }\n\n            if !inside_struct \u0026\u0026 line.contains('{') {\n                inside_struct = true;\n                continue;\n            }\n\n            if inside_struct {\n                if line.contains('}') {\n                    break;\n                }\n\n                // Parse field\n                let line = line.trim_end_matches(';');\n                let parts: Vec\u003c\u0026str\u003e = line.split_whitespace().collect();\n                if parts.len() \u003e= 2 {\n                    let field_type = parts[0].to_string();\n                    let field_name = parts[1].to_string();\n                    fields.insert(field_name, field_type);\n                }\n            }\n        }\n\n        Ok(DdsData {\n            name: struct_name,\n            value: \"{}\".to_string(), // Default empty JSON\n            fields,\n        })\n    }\n}\n\n/// IDL 파일 수집 함수 - 존재하는 파일만 읽음, 생성하지 않음\npub fn collect_idl_files(dir: \u0026Path) -\u003e Result\u003cVec\u003cPathBuf\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    let mut idl_files = Vec::new();\n\n    if !dir.exists() {\n        println!(\"IDL directory does not exist: {:?}\", dir);\n        return Ok(idl_files); // 디렉토리가 없으면 빈 벡터 반환\n    }\n\n    if dir.is_dir() {\n        for entry in fs::read_dir(dir)? {\n            let entry = entry?;\n            let path = entry.path();\n\n            if path.is_file() \u0026\u0026 path.extension().map_or(false, |ext| ext == \"idl\") {\n                println!(\"Found IDL file: {:?}\", path);\n                idl_files.push(path);\n            }\n        }\n    }\n\n    if idl_files.is_empty() {\n        println!(\"No IDL files found in directory: {:?}\", dir);\n    } else {\n        println!(\n            \"Found {} IDL files in directory: {:?}\",\n            idl_files.len(),\n            dir\n        );\n    }\n\n    Ok(idl_files)\n}\n\n/// IDL 파일 메타데이터 가져오기\npub fn get_idl_files(dir: \u0026Path) -\u003e Result\u003cVec\u003c(String, String)\u003e, Box\u003cdyn std::error::Error\u003e\u003e {\n    let mut result = Vec::new();\n\n    println!(\n        \"*** get_idl_files is being called for directory: {:?} ***\",\n        dir\n    );\n\n    if !dir.exists() {\n        println!(\"Directory does not exist: {:?}\", dir);\n        return Ok(result);\n    }\n\n    // 디렉토리 내용 출력\n    println!(\"Directory contents:\");\n    for entry in fs::read_dir(dir)? {\n        let entry = entry?;\n        let path = entry.path();\n        println!(\"  - {:?} (is_file: {})\", path, path.is_file());\n\n        if path.is_file() \u0026\u0026 path.extension().map_or(false, |ext| ext == \"idl\") {\n            if let Some(stem) = path.file_stem() {\n                let type_name = stem.to_string_lossy().to_string();\n                let file_path = path.to_string_lossy().to_string();\n                println!(\"  * Found IDL file: {} at {}\", type_name, file_path);\n                result.push((type_name, file_path));\n            }\n        }\n    }\n\n    println!(\"*** get_idl_files found {} IDL files ***\", result.len());\n    Ok(result)\n}\n\n/// IDL 파일을 로드하여 DdsData 구조체로 반환\npub fn load_idl_file(path: \u0026Path) -\u003e Result\u003cDdsData, Box\u003cdyn std::error::Error\u003e\u003e {\n    IdlParser::parse_idl_file(path)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","build_scripts","mod.rs"],"content":"// Module for DDS build scripts\n// Exports modules separated by functionality\n\npub mod generator;\npub mod idl;\npub mod settings;\npub mod types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","build_scripts","settings.rs"],"content":"// Module for loading DDS settings\nuse serde_yaml;\nuse std::fs;\nuse std::path::PathBuf;\n\n/// Load DDS settings from settings.yaml (during build)\npub fn load_dds_settings() -\u003e Result\u003c(PathBuf, i32, Option\u003cString\u003e), Box\u003cdyn std::error::Error\u003e\u003e {\n    // Set default values (used when no settings file exists)\n    // Path relative to project root\n    let default_idl_dir = PathBuf::from(\"src/vehicle/dds/idl\");\n    let default_domain_id = 0;\n    let default_out_dir = None; // Default is to use the OUT_DIR environment variable\n\n    // Search for settings file path based on project root\n    // CARGO_MANIFEST_DIR is the path where filtergateway's Cargo.toml is located\n    // To change to a relative path based on pullpiri (project root), move to parent directory\n    let manifest_dir = std::env::var(\"CARGO_MANIFEST_DIR\")?;\n    let settings_path = PathBuf::from(\u0026manifest_dir)\n        .parent() // go up to 'player'\n        .and_then(|p| p.parent()) // go up to 'src'\n        .and_then(|p| p.parent()) // go up to 'pullpiri'\n        .map(|p| p.join(\"src/settings.yaml\"))\n        .ok_or(\"Failed to resolve project root for settings.yaml\")?;\n\n    let mut settings_content = String::new();\n\n    if !settings_path.exists() {\n        println!(\"No settings file found, using defaults\");\n        return Ok((default_idl_dir, default_domain_id, default_out_dir));\n    }\n\n    // Read settings file\n    println!(\"Reading settings from: {:?}\", settings_path);\n    settings_content = fs::read_to_string(\u0026settings_path)?;\n\n    // Parse JSON or YAML\n    let settings: serde_yaml::Value = serde_yaml::from_str(\u0026settings_content)?;\n\n    println!(\"Settings content: {}\", settings_content);\n\n    // Extract DDS settings (relative path based on project root)\n    let idl_path = settings\n        .get(\"dds\")\n        .and_then(|dds| dds.get(\"idl_path\"))\n        .and_then(|path| path.as_str())\n        .map(PathBuf::from)\n        .unwrap_or(default_idl_dir);\n\n    // Calculate absolute path based on project root\n    println!(\"IDL path from settings (relative): {:?}\", idl_path);\n\n    let domain_id = settings\n        .get(\"dds\")\n        .and_then(|dds| dds.get(\"domain_id\"))\n        .and_then(|id| id.as_i64())\n        .map(|id| id as i32)\n        .unwrap_or(default_domain_id);\n\n    println!(\"Domain ID from settings: {}\", domain_id);\n\n    // Check for custom OUT_DIR value\n    // If relative, convert to absolute path within target directory\n    let out_dir = settings\n        .get(\"dds\")\n        .and_then(|dds| dds.get(\"out_dir\"))\n        .and_then(|path| path.as_str())\n        .and_then(|dir| {\n            // If directory starts with / consider it absolute, otherwise make it relative to build directory\n            if dir.starts_with('/') {\n                Some(dir.to_string())\n            } else {\n                // Use the standard cargo OUT_DIR as the base directory\n                std::env::var(\"OUT_DIR\").ok().map(|out_dir| {\n                    println!(\n                        \"Converting relative path '{}' to absolute within build directory\",\n                        dir\n                    );\n                    format!(\"{}\", out_dir)\n                })\n            }\n        });\n\n    if let Some(dir) = \u0026out_dir {\n        println!(\"Output directory (absolute): {}\", dir);\n    }\n\n    Ok((idl_path, domain_id, out_dir))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","build_scripts","types.rs"],"content":"// Module for DDS type definitions\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n/// Definition of DDS data structure\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DdsData {\n    pub name: String,\n    pub value: String,\n    pub fields: HashMap\u003cString, String\u003e,\n}\n\n/// Convert IDL type to Rust type\npub fn idl_to_rust_type(idl_type: \u0026str) -\u003e \u0026str {\n    match idl_type {\n        \"boolean\" =\u003e \"bool\",\n        \"short\" | \"int16_t\" =\u003e \"i16\",\n        \"unsigned short\" | \"uint16_t\" =\u003e \"u16\",\n        \"long\" | \"int32_t\" =\u003e \"i32\",\n        \"unsigned long\" | \"uint32_t\" =\u003e \"u32\",\n        \"long long\" | \"int64_t\" =\u003e \"i64\",\n        \"unsigned long long\" | \"uint64_t\" =\u003e \"u64\",\n        \"float\" =\u003e \"f32\",\n        \"double\" =\u003e \"f64\",\n        \"string\" | \"std::string\" =\u003e \"String\",\n        \"octet\" | \"byte\" =\u003e \"u8\",\n        \"char\" =\u003e \"char\",\n        _ =\u003e \"String\", // Default to String for complex types\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","filter","mod.rs"],"content":"use crate::grpc::sender::FilterGatewaySender;\nuse crate::vehicle::dds::DdsData;\nuse common::spec::artifact::Scenario;\nuse common::Result;\n// use dust_dds::infrastructure::wait_set::Condition;\nuse std::sync::Arc;\nuse tokio::sync::{mpsc, Mutex};\n\n/// Filter for evaluating scenario conditions\npub struct Filter {\n    /// Name of the scenario\n    pub scenario_name: String,\n    /// Full scenario definition\n    pub scenario: Scenario,\n    /// Flag to indicate if the filter is active\n    is_active: bool,\n    /// gRPC sender for action controller\n    sender: FilterGatewaySender,\n}\n\nimpl Filter {\n    /// Create a new Filter\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    /// * `scenario` - Full scenario definition\n    /// * `rx_dds` - Receiver for DDS data\n    /// * `sender` - Sender for gRPC calls\n    ///\n    /// # Returns\n    ///\n    /// A new Filter instance\n    pub fn new(\n        scenario_name: String,\n        scenario: Scenario,\n        is_active: bool,\n        sender: FilterGatewaySender,\n    ) -\u003e Self {\n        Self {\n            scenario_name,\n            scenario,\n            is_active,\n            sender,\n        }\n    }\n\n    /// Check if scenario conditions are met\n    ///\n    /// Evaluates if the received vehicle data meets the scenario conditions.\n    /// If conditions are met, triggers an action through ActionController.\n    ///\n    /// # Arguments\n    ///\n    /// * `data` - Vehicle message data\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn meet_scenario_condition(\u0026mut self, data: \u0026DdsData) -\u003e Result\u003c()\u003e {\n        let condition = self.scenario.get_conditions().unwrap();\n        let topic = condition.get_operand_value();\n        let value_name = condition.get_operand_name();\n        let target_value = condition.get_value();\n        let express = condition.get_express();\n\n        print!(\n            \"Checking condition for scenario: {}\\nTopic: {}\\nTarget Value: {}\\nValue Name: {}\\nExpression: {}\\n\",\n            self.scenario_name, topic, target_value, value_name, express\n        );\n\n        if !data.name.eq(\u0026topic) {\n            return Err(\"data topic does not match\".into());\n        }\n\n        // fields에서 value_name과 일치하는 key를 찾고, 해당 value와 target_value를 비교\n        let field_value = match data.fields.get(\u0026value_name) {\n            Some(v) =\u003e v,\n            None =\u003e return Err(format!(\"field '{}' not found in data.fields\", value_name).into()),\n        };\n\n        let check: bool = match express.as_str() {\n            \"eq\" =\u003e target_value.to_lowercase() == field_value.to_lowercase(),\n            \"lt\" =\u003e {\n                let target_v = target_value\n                    .parse::\u003cf32\u003e()\n                    .map_err(|_| \"target_value parse error\")?;\n                let current_v = field_value\n                    .parse::\u003cf32\u003e()\n                    .map_err(|_| \"field_value parse error\")?;\n                current_v \u003c target_v\n            }\n            \"le\" =\u003e {\n                let target_v = target_value\n                    .parse::\u003cf32\u003e()\n                    .map_err(|_| \"target_value parse error\")?;\n                let current_v = field_value\n                    .parse::\u003cf32\u003e()\n                    .map_err(|_| \"field_value parse error\")?;\n                current_v \u003c= target_v\n            }\n            \"ge\" =\u003e {\n                let target_v = target_value\n                    .parse::\u003cf32\u003e()\n                    .map_err(|_| \"target_value parse error\")?;\n                let current_v = field_value\n                    .parse::\u003cf32\u003e()\n                    .map_err(|_| \"field_value parse error\")?;\n                current_v \u003e= target_v\n            }\n            \"gt\" =\u003e {\n                let target_v = target_value\n                    .parse::\u003cf32\u003e()\n                    .map_err(|_| \"target_value parse error\")?;\n                let current_v = field_value\n                    .parse::\u003cf32\u003e()\n                    .map_err(|_| \"field_value parse error\")?;\n                current_v \u003e target_v\n            }\n            _ =\u003e return Err(\"wrong expression in condition\".into()),\n        };\n\n        if check {\n            println!(\"Condition met for scenario: {}\", self.scenario_name);\n            self.sender\n                .trigger_action(self.scenario_name.clone())\n                .await?;\n            Ok(())\n        } else {\n            Err(\"cannot meet condition\".into())\n        }\n    }\n\n    /// Pause the filter processing\n    ///\n    /// Temporarily disables condition evaluation for this scenario.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn pause_scenario_filter(\u0026mut self) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        self.is_active = false;\n        Ok(())\n    }\n\n    /// Resume the filter processing\n    ///\n    /// Re-enables condition evaluation for this scenario.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn resume_scenario_filter(\u0026mut self) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        self.is_active = true;\n        Ok(())\n    }\n\n    /// Check if filter is active\n    ///\n    /// # Returns\n    ///\n    /// * `bool` - Filter active status\n    pub fn is_active(\u0026self) -\u003e bool {\n        self.is_active\n    }\n\n    /// Process DDS data and check conditions\n    ///\n    /// Processes received DDS data and checks scenario conditions.\n    /// Triggers an action if conditions are met.\n    ///\n    /// # Arguments\n    ///\n    /// * `data` - Received DDS data\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn process_data(\u0026mut self, data: \u0026DdsData) -\u003e Result\u003c()\u003e {\n        // Do not process inactive filters\n        if !self.is_active {\n            return Ok(());\n        }\n\n        print!(\n            \"process data for scenario: {}\\nTopic: {:?}\\nTarget Name: {:?}\\nTarget Value: {:?}\\n\",\n            self.scenario_name, data.name, data.value, data.fields\n        );\n\n        // Check if topic matches filter condition\n        let condition = match self.scenario.get_conditions() {\n            Some(c) =\u003e c,\n            None =\u003e return Ok(()), // No conditions case (already handled)\n        };\n\n        let topic = condition.get_operand_value();\n        if !data.name.eq(\u0026topic) {\n            return Ok(()); // Ignore unrelated topics\n        }\n\n        // Perform condition check\n        match self.meet_scenario_condition(data).await {\n            Ok(_) =\u003e {\n                println!(\"Action triggered for scenario: {}\", self.scenario_name);\n                // Disable filter after condition is met (run only once)\n                // Add self.is_active = false; code if needed\n            }\n            Err(e) =\u003e {\n                // Condition not met is a normal case, only log at debug level\n                if e.to_string() != \"cannot meet condition\" {\n                    println!(\"Error checking condition: {:?}\", e);\n                }\n            }\n        }\n\n        Ok(())\n    }\n}\n//Unit Test Cases\n#[cfg(test)]\nmod tests {\n    use async_trait::async_trait;\n    use common::Result;\n    use mockall::{mock, predicate};\n    use std::collections::HashMap;\n    use tokio;\n\n    // Dummy DDS data struct\n    #[derive(Clone)]\n    struct DdsData {\n        topic_name: String,\n        data: HashMap\u003cString, String\u003e,\n    }\n\n    impl DdsData {\n        fn new(topic_name: \u0026str, data: HashMap\u003cString, String\u003e) -\u003e Self {\n            Self {\n                topic_name: topic_name.to_string(),\n                data,\n            }\n        }\n    }\n\n    // Dummy condition struct with operand enum\n    #[derive(Clone)]\n    struct Condition {\n        key: String,\n        operand: Operand,\n        value: String,\n    }\n\n    #[derive(Clone)]\n    enum Operand {\n        Equal,\n        NotEqual,\n    }\n\n    // Scenario holding multiple conditions\n    #[derive(Clone)]\n    struct Scenario {\n        conditions: Vec\u003cCondition\u003e,\n    }\n\n    impl Scenario {\n        fn new(conditions: Vec\u003cCondition\u003e) -\u003e Self {\n            Self { conditions }\n        }\n    }\n\n    // Trait for sender, to be mocked\n    #[async_trait]\n    pub trait FilterGatewaySenderTrait: Send + Sync {\n        async fn trigger_action(\u0026self, scenario_name: String) -\u003e Result\u003c()\u003e;\n    }\n\n    // Mock sender using mockall\n    mock! {\n        pub FilterGatewaySender {}\n\n        #[async_trait]\n        impl FilterGatewaySenderTrait for FilterGatewaySender {\n            async fn trigger_action(\u0026self, scenario_name: String) -\u003e Result\u003c()\u003e;\n        }\n    }\n\n    // Filter struct under test\n    struct Filter\u003cS: FilterGatewaySenderTrait\u003e {\n        scenario_name: String,\n        scenario: Scenario,\n        enabled: bool,\n        sender: S,\n    }\n\n    impl\u003cS: FilterGatewaySenderTrait\u003e Filter\u003cS\u003e {\n        pub fn new(scenario_name: String, scenario: Scenario, enabled: bool, sender: S) -\u003e Self {\n            Self {\n                scenario_name,\n                scenario,\n                enabled,\n                sender,\n            }\n        }\n\n        pub async fn meet_scenario_condition(\u0026mut self, dds_data: \u0026DdsData) -\u003e Result\u003c()\u003e {\n            if !self.enabled {\n                return Ok(());\n            }\n\n            for cond in \u0026self.scenario.conditions {\n                let actual_value = dds_data.data.get(\u0026cond.key);\n                let cond_met = match (actual_value, \u0026cond.operand) {\n                    (Some(val), Operand::Equal) =\u003e val == \u0026cond.value,\n                    (Some(val), Operand::NotEqual) =\u003e val != \u0026cond.value,\n                    _ =\u003e false,\n                };\n\n                if !cond_met {\n                    return Ok(());\n                }\n            }\n\n            self.sender.trigger_action(self.scenario_name.clone()).await\n        }\n    }\n\n    // Helper to create scenario\n    fn make_scenario_with_conditions(conds: Vec\u003cCondition\u003e) -\u003e Scenario {\n        Scenario::new(conds)\n    }\n\n    // Helper to create dds data\n    fn make_dds_data(topic_name: \u0026str, data: HashMap\u003cString, String\u003e) -\u003e DdsData {\n        DdsData::new(topic_name, data)\n    }\n\n    // Test: Trigger action when enabled and conditions met\n    #[tokio::test]\n    async fn test_trigger_action_when_condition_met_and_enabled() {\n        let mut mock_sender = MockFilterGatewaySender::new();\n\n        // Mock: expect trigger_action called once with scenario name\n        mock_sender\n            .expect_trigger_action()\n            .with(predicate::eq(\"test_scenario\".to_string()))\n            .times(1)\n            .returning(|_| Ok(()));\n\n        let scenario = make_scenario_with_conditions(vec![Condition {\n            key: \"temperature\".into(),\n            operand: Operand::Equal,\n            value: \"25\".into(),\n        }]);\n\n        let mut filter = Filter::new(\"test_scenario\".into(), scenario, true, mock_sender);\n\n        let mut data_map = HashMap::new();\n        data_map.insert(\"temperature\".into(), \"25\".into());\n        let dds_data = make_dds_data(\"TestTopic\", data_map);\n        let result = filter.meet_scenario_condition(\u0026dds_data).await;\n\n        assert!(result.is_ok());\n    }\n\n    // Test: Do not trigger when filter disabled\n    #[tokio::test]\n    async fn test_no_trigger_when_filter_disabled() {\n        let mut mock_sender = MockFilterGatewaySender::new();\n\n        // No expectation since should not call trigger_action\n\n        let scenario = make_scenario_with_conditions(vec![Condition {\n            key: \"temperature\".into(),\n            operand: Operand::Equal,\n            value: \"25\".into(),\n        }]);\n\n        let mut filter = Filter::new(\"test_scenario\".into(), scenario, false, mock_sender);\n\n        let mut data_map = HashMap::new();\n        data_map.insert(\"temperature\".into(), \"25\".into());\n        let dds_data = make_dds_data(\"TestTopic\", data_map);\n\n        let result = filter.meet_scenario_condition(\u0026dds_data).await;\n\n        assert!(result.is_ok());\n    }\n\n    // Test: Do not trigger when condition not met\n    #[tokio::test]\n    async fn test_no_trigger_when_condition_not_met() {\n        let mut mock_sender = MockFilterGatewaySender::new();\n\n        // No expectation since condition fails\n\n        let scenario = make_scenario_with_conditions(vec![Condition {\n            key: \"temperature\".into(),\n            operand: Operand::Equal,\n            value: \"25\".into(),\n        }]);\n\n        let mut filter = Filter::new(\"test_scenario\".into(), scenario, true, mock_sender);\n\n        let mut data_map = HashMap::new();\n        data_map.insert(\"temperature\".into(), \"30\".into()); // value differs\n        let dds_data = make_dds_data(\"TestTopic\", data_map);\n\n        let result = filter.meet_scenario_condition(\u0026dds_data).await;\n\n        assert!(result.is_ok());\n    }\n\n    // Test: Propagate error from trigger_action\n    #[tokio::test]\n    async fn test_trigger_action_error_propagated() {\n        let mut mock_sender = MockFilterGatewaySender::new();\n\n        // Mock: return error on trigger_action\n        mock_sender\n            .expect_trigger_action()\n            .with(predicate::eq(\"test_scenario\".to_string()))\n            .times(1)\n            .returning(|_| Err(\"trigger error\".into()));\n\n        let scenario = make_scenario_with_conditions(vec![Condition {\n            key: \"temperature\".into(),\n            operand: Operand::Equal,\n            value: \"25\".into(),\n        }]);\n\n        let mut filter = Filter::new(\"test_scenario\".into(), scenario, true, mock_sender);\n\n        let mut data_map = HashMap::new();\n        data_map.insert(\"temperature\".into(), \"25\".into());\n        let dds_data = make_dds_data(\"TestTopic\", data_map);\n\n        let result = filter.meet_scenario_condition(\u0026dds_data).await;\n\n        assert!(result.is_err());\n        assert_eq!(format!(\"{}\", result.unwrap_err()), \"trigger error\");\n    }\n    // Test: Trigger when multiple conditions all met\n    #[tokio::test]\n    async fn test_multiple_conditions_all_met() {\n        let mut mock_sender = MockFilterGatewaySender::new();\n\n        // Expect trigger once\n        mock_sender\n            .expect_trigger_action()\n            .with(predicate::eq(\"test_scenario\".to_string()))\n            .times(1)\n            .returning(|_| Ok(()));\n\n        let scenario = make_scenario_with_conditions(vec![\n            Condition {\n                key: \"temperature\".into(),\n                operand: Operand::Equal,\n                value: \"25\".into(),\n            },\n            Condition {\n                key: \"humidity\".into(),\n                operand: Operand::NotEqual,\n                value: \"80\".into(),\n            },\n        ]);\n\n        let mut filter = Filter::new(\"test_scenario\".into(), scenario, true, mock_sender);\n\n        let mut data_map = HashMap::new();\n        data_map.insert(\"temperature\".into(), \"25\".into());\n        data_map.insert(\"humidity\".into(), \"50\".into());\n        let dds_data = make_dds_data(\"TestTopic\", data_map);\n\n        let result = filter.meet_scenario_condition(\u0026dds_data).await;\n\n        assert!(result.is_ok());\n    }\n\n    // Test: Do not trigger if one condition in multiple not met\n    #[tokio::test]\n    async fn test_multiple_conditions_one_not_met() {\n        let mut mock_sender = MockFilterGatewaySender::new();\n\n        // No expectation since condition fails\n\n        let scenario = make_scenario_with_conditions(vec![\n            Condition {\n                key: \"temperature\".into(),\n                operand: Operand::Equal,\n                value: \"25\".into(),\n            },\n            Condition {\n                key: \"humidity\".into(),\n                operand: Operand::NotEqual,\n                value: \"80\".into(),\n            },\n        ]);\n\n        let mut filter = Filter::new(\"test_scenario\".into(), scenario, true, mock_sender);\n\n        let mut data_map = HashMap::new();\n        data_map.insert(\"temperature\".into(), \"25\".into());\n        data_map.insert(\"humidity\".into(), \"80\".into()); // fails NotEqual\n        let dds_data = make_dds_data(\"TestTopic\", data_map);\n\n        let result = filter.meet_scenario_condition(\u0026dds_data).await;\n\n        assert!(result.is_ok());\n    }\n    // Test: Trigger action when all conditions are met but with additional irrelevant data\n    #[tokio::test]\n    async fn test_trigger_action_with_irrelevant_data() {\n        let mut mock_sender = MockFilterGatewaySender::new();\n\n        // Expect trigger once\n        mock_sender\n            .expect_trigger_action()\n            .with(predicate::eq(\"test_scenario\".to_string()))\n            .times(1)\n            .returning(|_| Ok(()));\n\n        let scenario = make_scenario_with_conditions(vec![Condition {\n            key: \"temperature\".into(),\n            operand: Operand::Equal,\n            value: \"25\".into(),\n        }]);\n\n        let mut filter = Filter::new(\"test_scenario\".into(), scenario, true, mock_sender);\n\n        let mut data_map = HashMap::new();\n        data_map.insert(\"temperature\".into(), \"25\".into());\n        data_map.insert(\"pressure\".into(), \"1013\".into()); // Irrelevant data\n        let dds_data = make_dds_data(\"TestTopic\", data_map);\n\n        let result = filter.meet_scenario_condition(\u0026dds_data).await;\n\n        assert!(result.is_ok());\n    }\n\n    // Test: Do not trigger action when data map is empty\n    #[tokio::test]\n    async fn test_no_trigger_with_empty_data_map() {\n        let mut mock_sender = MockFilterGatewaySender::new();\n        // No expectation since condition fails\n        let scenario = make_scenario_with_conditions(vec![Condition {\n            key: \"temperature\".into(),\n            operand: Operand::Equal,\n            value: \"25\".into(),\n        }]);\n\n        let mut filter = Filter::new(\"test_scenario\".into(), scenario, true, mock_sender);\n\n        let dds_data = make_dds_data(\"TestTopic\", HashMap::new());\n\n        let result = filter.meet_scenario_condition(\u0026dds_data).await;\n\n        assert!(result.is_ok());\n    }\n\n    // Test: Trigger action when condition is met with case-insensitive comparison\n    #[tokio::test]\n    async fn test_trigger_action_with_case_insensitive_match() {\n        let mut mock_sender = MockFilterGatewaySender::new();\n\n        // Expect trigger once\n        mock_sender\n            .expect_trigger_action()\n            .with(predicate::eq(\"test_scenario\".to_string()))\n            .times(1)\n            .returning(|_| Ok(()));\n\n        let scenario = make_scenario_with_conditions(vec![Condition {\n            key: \"temperature\".into(),\n            operand: Operand::Equal,\n            value: \"25\".into(),\n        }]);\n\n        let mut filter = Filter::new(\"test_scenario\".into(), scenario, true, mock_sender);\n\n        let mut data_map = HashMap::new();\n        data_map.insert(\"temperature\".into(), \"25\".into()); // Matching value\n        let dds_data = make_dds_data(\"TestTopic\", data_map);\n\n        let result = filter.meet_scenario_condition(\u0026dds_data).await;\n\n        assert!(result.is_ok());\n    }\n\n    // Test: Trigger action when multiple conditions are met with mixed operands\n    #[tokio::test]\n    async fn test_trigger_action_with_mixed_operands() {\n        let mut mock_sender = MockFilterGatewaySender::new();\n\n        // Expect trigger once\n        mock_sender\n            .expect_trigger_action()\n            .with(predicate::eq(\"test_scenario\".to_string()))\n            .times(1)\n            .returning(|_| Ok(()));\n\n        let scenario = make_scenario_with_conditions(vec![\n            Condition {\n                key: \"temperature\".into(),\n                operand: Operand::Equal,\n                value: \"25\".into(),\n            },\n            Condition {\n                key: \"humidity\".into(),\n                operand: Operand::NotEqual,\n                value: \"80\".into(),\n            },\n        ]);\n\n        let mut filter = Filter::new(\"test_scenario\".into(), scenario, true, mock_sender);\n\n        let mut data_map = HashMap::new();\n        data_map.insert(\"temperature\".into(), \"25\".into());\n        data_map.insert(\"humidity\".into(), \"50\".into()); // Meets NotEqual condition\n        let dds_data = make_dds_data(\"TestTopic\", data_map);\n\n        let result = filter.meet_scenario_condition(\u0026dds_data).await;\n\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":34,"address":[3359856],"length":1,"stats":{"Line":3}},{"line":60,"address":[3359968,3359981],"length":1,"stats":{"Line":8}},{"line":61,"address":[3984774,3984890],"length":1,"stats":{"Line":6}},{"line":62,"address":[5853920],"length":1,"stats":{"Line":4}},{"line":63,"address":[4792093],"length":1,"stats":{"Line":3}},{"line":64,"address":[3196962],"length":1,"stats":{"Line":4}},{"line":65,"address":[3985171],"length":1,"stats":{"Line":4}},{"line":67,"address":[4792344,4792411],"length":1,"stats":{"Line":9}},{"line":72,"address":[3985604],"length":1,"stats":{"Line":4}},{"line":73,"address":[3205402,3205294],"length":1,"stats":{"Line":2}},{"line":77,"address":[5854799,5854692],"length":1,"stats":{"Line":8}},{"line":78,"address":[3985846],"length":1,"stats":{"Line":5}},{"line":79,"address":[3197783],"length":1,"stats":{"Line":2}},{"line":82,"address":[3205518,3205788],"length":1,"stats":{"Line":7}},{"line":83,"address":[2898579,2901660,2898498],"length":1,"stats":{"Line":7}},{"line":84,"address":[3986217,3986291],"length":1,"stats":{"Line":5}},{"line":85,"address":[3986339,3989287,3988686,3988870],"length":1,"stats":{"Line":4}},{"line":87,"address":[2941824,2941833,2940022],"length":1,"stats":{"Line":3}},{"line":88,"address":[3102738,3102430,3102653],"length":1,"stats":{"Line":3}},{"line":90,"address":[3202544,3202553,3201005],"length":1,"stats":{"Line":3}},{"line":91,"address":[2901556],"length":1,"stats":{"Line":1}},{"line":93,"address":[3986387,3986313],"length":1,"stats":{"Line":4}},{"line":94,"address":[2939220,2939404,2939833,2937619],"length":1,"stats":{"Line":4}},{"line":96,"address":[3210361,3210352,3207836],"length":1,"stats":{"Line":3}},{"line":97,"address":[3102100,3102003,3101780],"length":1,"stats":{"Line":3}},{"line":99,"address":[5857475,5859728,5859737],"length":1,"stats":{"Line":3}},{"line":100,"address":[3751832],"length":1,"stats":{"Line":1}},{"line":102,"address":[3749763,3749689],"length":1,"stats":{"Line":3}},{"line":103,"address":[2939183,2938570,2937715,2938754],"length":1,"stats":{"Line":4}},{"line":105,"address":[2903113,2903104,2899874],"length":1,"stats":{"Line":3}},{"line":106,"address":[2899978,2900298,2900201],"length":1,"stats":{"Line":3}},{"line":108,"address":[3104288,3104297,3101321],"length":1,"stats":{"Line":3}},{"line":109,"address":[4794942],"length":1,"stats":{"Line":1}},{"line":111,"address":[2898841,2898915],"length":1,"stats":{"Line":2}},{"line":112,"address":[3750002,3750621,3749911,3750182],"length":1,"stats":{"Line":4}},{"line":114,"address":[3198746,3202713,3202704],"length":1,"stats":{"Line":3}},{"line":115,"address":[3986978,3987201,3987312],"length":1,"stats":{"Line":3}},{"line":117,"address":[5859856,5856161,5859865],"length":1,"stats":{"Line":3}},{"line":118,"address":[4794302],"length":1,"stats":{"Line":1}},{"line":120,"address":[3100073,3100173],"length":1,"stats":{"Line":2}},{"line":123,"address":[3750549,3753548],"length":1,"stats":{"Line":7}},{"line":124,"address":[3989685,3989611],"length":1,"stats":{"Line":4}},{"line":125,"address":[3103250,3103659,3103342,3103288,3103769,3103581,3103998],"length":1,"stats":{"Line":14}},{"line":126,"address":[3209424],"length":1,"stats":{"Line":2}},{"line":127,"address":[3753473,3753087,3753127,3753186,3753363,3748107],"length":1,"stats":{"Line":18}},{"line":128,"address":[5859304],"length":1,"stats":{"Line":5}},{"line":130,"address":[3103128,3103051],"length":1,"stats":{"Line":2}},{"line":145,"address":[3182520,3182512],"length":1,"stats":{"Line":4}},{"line":147,"address":[2942149],"length":1,"stats":{"Line":1}},{"line":148,"address":[2942156],"length":1,"stats":{"Line":1}},{"line":162,"address":[6266064,6266072],"length":1,"stats":{"Line":4}},{"line":164,"address":[2942293],"length":1,"stats":{"Line":1}},{"line":165,"address":[2903452],"length":1,"stats":{"Line":1}},{"line":173,"address":[3233984],"length":1,"stats":{"Line":2}},{"line":174,"address":[3585333],"length":1,"stats":{"Line":3}},{"line":189,"address":[2903570,2905468,2903520,2903682,2903825,2904724],"length":1,"stats":{"Line":19}},{"line":191,"address":[3754558],"length":1,"stats":{"Line":3}},{"line":192,"address":[5860378],"length":1,"stats":{"Line":1}},{"line":195,"address":[2942725,2942584],"length":1,"stats":{"Line":10}},{"line":201,"address":[3203599],"length":1,"stats":{"Line":6}},{"line":202,"address":[4798724],"length":1,"stats":{"Line":5}},{"line":203,"address":[3211715],"length":1,"stats":{"Line":1}},{"line":206,"address":[3211685],"length":1,"stats":{"Line":6}},{"line":207,"address":[3755366,3755438],"length":1,"stats":{"Line":12}},{"line":208,"address":[2904548],"length":1,"stats":{"Line":2}},{"line":212,"address":[3755547,3755484,3755634,3754605],"length":1,"stats":{"Line":11}},{"line":214,"address":[3204565],"length":1,"stats":{"Line":5}},{"line":218,"address":[3204503],"length":1,"stats":{"Line":2}},{"line":220,"address":[3992663,3992874],"length":1,"stats":{"Line":4}},{"line":221,"address":[3204883],"length":1,"stats":{"Line":2}},{"line":226,"address":[4799688],"length":1,"stats":{"Line":2}}],"covered":71,"coverable":71},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","grpc","mod.rs"],"content":"pub mod receiver;\npub mod sender;\n\n/// Initializes the gRPC module for FilterGateway\n///\n/// Sets up the gRPC server to receive requests from API-Server,\n/// and establishes client connections to communicate with ActionController.\n///\n/// # Returns\n///\n/// * `common::Result\u003c()\u003e` - Result of initialization\npub async fn init() -\u003e common::Result\u003c()\u003e {\n    // TODO: Implementation\n    Ok(())\n}\n//Unit Test Case\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_init_success() {\n        // Call the `init` function and wait for it to complete\n        let result = init().await;\n\n        // Assert that the result is successful (Ok)\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_init_edge_case() {\n        // Call the `init` function and wait for it to complete\n        let result = init().await;\n\n        // Use a match statement to handle both success and error cases\n        match result {\n            Ok(_) =\u003e assert!(true), // If the result is Ok, the test passes\n            Err(_) =\u003e assert!(false, \"Expected Ok(()), but got an Err\"), // If the result is Err, the test fails with a message\n        }\n    }\n}\n","traces":[{"line":12,"address":[3744968,3745048,3744944],"length":1,"stats":{"Line":6}},{"line":14,"address":[3745001],"length":1,"stats":{"Line":2}}],"covered":2,"coverable":2},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","grpc","receiver.rs"],"content":"use core::sync;\nuse std::io::Error;\n\nuse crate::manager::ScenarioParameter;\nuse crate::vehicle::dds::DdsData;\n\nuse common::spec::artifact::{Artifact, Scenario};\nuse common::Result;\nuse tokio::sync::mpsc::{self, error::SendError};\nuse tonic::{Request, Response, Status};\n\n// Import the generated protobuf code from filtergateway.proto\nuse common::filtergateway::{\n    filter_gateway_connection_server::{FilterGatewayConnection, FilterGatewayConnectionServer},\n    HandleScenarioRequest, HandleScenarioResponse,\n};\n\n/// FilterGateway gRPC service handler\npub struct FilterGatewayReceiver {\n    tx: mpsc::Sender\u003cScenarioParameter\u003e,\n}\n\nimpl FilterGatewayReceiver {\n    /// Create a new FilterGatewayReceiver\n    ///\n    /// # Arguments\n    ///\n    /// * `tx` - Channel sender for ScenarioParameter information\n    ///\n    /// # Returns\n    ///\n    /// A new FilterGatewayReceiver instance\n    pub fn new(tx: mpsc::Sender\u003cScenarioParameter\u003e) -\u003e Self {\n        Self { tx }\n    }\n\n    /// Get the gRPC server for this receiver\n    ///\n    /// # Returns\n    ///\n    /// A gRPC server for handling requests\n    pub fn into_service(self) -\u003e FilterGatewayConnectionServer\u003cSelf\u003e {\n        FilterGatewayConnectionServer::new(self)\n    }\n\n    /// Handle a scenario from API-Server\n    ///\n    /// Receives a scenario YAML string from API-Server, parses it into a Scenario struct,\n    /// and forwards it to the FilterGateway manager for processing.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_yaml_str` - YAML string of the scenario\n    /// * `action` - Action code (0 for APPLY, 1 for WITHDRAW)\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn handle_scenario(\u0026self, scenario_yaml_str: String, action: i32) -\u003e Result\u003c()\u003e {\n        // Parse the scenario YAML string into a Scenario struct\n        let scenario = serde_yaml::from_str::\u003cScenario\u003e(\u0026scenario_yaml_str)?;\n\n        let param = ScenarioParameter {\n            action: action,\n            scenario: scenario,\n        };\n\n        self.tx.send(param).await.map_err(|e| {\n            eprintln!(\"Failed to send scenario: {}\", e);\n            Error::new(std::io::ErrorKind::Other, \"Failed to send scenario\")\n        })?;\n\n        Ok(())\n    }\n}\n\n#[tonic::async_trait]\nimpl FilterGatewayConnection for FilterGatewayReceiver {\n    async fn handle_scenario(\n        \u0026self,\n        request: Request\u003cHandleScenarioRequest\u003e,\n    ) -\u003e std::result::Result\u003cResponse\u003cHandleScenarioResponse\u003e, Status\u003e {\n        let req = request.into_inner();\n        println!(\"Received scenario handling request\");\n\n        // Extract the scenario YAML string and action from the request\n        match self.handle_scenario(req.scenario, req.action).await {\n            Ok(_) =\u003e {\n                println!(\"Successfully handled scenario\");\n            }\n            Err(e) =\u003e {\n                eprintln!(\"Error handling scenario: {}\", e);\n                return Err(Status::internal(format!(\n                    \"Failed to handle scenario: {}\",\n                    e\n                )));\n            }\n        }\n        Ok(Response::new(HandleScenarioResponse {\n            status: true,\n            desc: \"Successfully handled scenario\".to_string(),\n        }))\n    }\n}\n//Unit Test Cases\n#[cfg(test)]\nmod tests {\n    use crate::grpc::receiver::FilterGatewayReceiver;\n    use serde_yaml;\n    use tokio::sync::mpsc;\n\n    // Test case for handling valid YAML input\n    #[tokio::test]\n    async fn test_handle_scenario_with_valid_yaml() {\n        let (tx, mut rx) = mpsc::channel(1);\n        let receiver = FilterGatewayReceiver::new(tx);\n\n        let scenario_yaml = r#\"\n        apiVersion: v1\n        kind: Scenario\n        metadata:\n          name: helloworld\n        spec:\n          condition:\n          action: update\n          target: helloworld\n        \"#;\n\n        let action = 0;\n\n        let result = receiver\n            .handle_scenario(scenario_yaml.to_string(), action)\n            .await;\n        assert!(result.is_ok());\n\n        let received_param = rx.recv().await.unwrap();\n        assert_eq!(received_param.action, action);\n\n        let scenario: serde_yaml::Value = serde_yaml::from_str(\u0026scenario_yaml).unwrap();\n        assert_eq!(scenario[\"metadata\"][\"name\"], \"helloworld\");\n        assert_eq!(scenario[\"spec\"][\"action\"], \"update\");\n        assert_eq!(scenario[\"spec\"][\"target\"], \"helloworld\");\n    }\n\n    // Test case for handling invalid YAML input\n    #[tokio::test]\n    async fn test_handle_scenario_with_invalid_yaml() {\n        let (tx, _rx) = mpsc::channel(1);\n        let receiver = FilterGatewayReceiver::new(tx);\n\n        let invalid_yaml = r#\"\n        apiVersion: v1\n        kind: Scenario\n        metadata:\n          name: helloworld\n        spec:\n          condition:\n          action: update\n          target: helloworld\n        ---\n        apiVersion: v1\n        kind: Package\n        metadata:\n          label: null\n          name: helloworld\n        spec:\n          pattern:\n            - type: plain\n          models:\n            - name: helloworld-core\n              node: HPC\n              resources:\n                volume:\n                network:\n        \"#; // Invalid YAML due to missing resource definitions\n\n        let action = 0;\n\n        let result = receiver\n            .handle_scenario(invalid_yaml.to_string(), action)\n            .await;\n        assert!(result.is_err());\n    }\n\n    // Test case for handling empty YAML input\n    #[tokio::test]\n    async fn test_handle_scenario_with_empty_yaml() {\n        let (tx, _rx) = mpsc::channel(1);\n        let receiver = FilterGatewayReceiver::new(tx);\n\n        let empty_yaml = \"\";\n\n        let action = 0;\n\n        let result = receiver\n            .handle_scenario(empty_yaml.to_string(), action)\n            .await;\n        assert!(result.is_err());\n    }\n\n    // Test case for handling YAML with missing required fields\n    #[tokio::test]\n    async fn test_handle_scenario_with_missing_fields() {\n        let (tx, _rx) = mpsc::channel(1);\n        let receiver = FilterGatewayReceiver::new(tx);\n\n        let incomplete_yaml = r#\"\n        apiVersion: v1\n        kind: Scenario\n        metadata:\n          name: helloworld\n        spec:\n          action: update\n        \"#; // Missing \"target\" field\n\n        let action = 0;\n\n        let result = receiver\n            .handle_scenario(incomplete_yaml.to_string(), action)\n            .await;\n        assert!(result.is_err());\n    }\n\n    // Negative test case for handling a scenario when the channel is closed\n    #[tokio::test]\n    async fn test_handle_scenario_with_closed_channel() {\n        let (tx, _rx) = mpsc::channel(1); // Use a buffer size greater than 0\n        drop(tx.clone()); // Explicitly close the channel\n        let receiver = FilterGatewayReceiver::new(tx);\n\n        let scenario_yaml = r#\"\n        apiVersion: v1\n        kind: Scenario\n        metadata:\n          name: helloworld\n        spec:\n          condition:\n          action: update\n          target: helloworld\n        \"#;\n\n        let action = 0;\n\n        let result = receiver\n            .handle_scenario(scenario_yaml.to_string(), action)\n            .await;\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":33,"address":[2748208],"length":1,"stats":{"Line":9}},{"line":42,"address":[3813792],"length":1,"stats":{"Line":5}},{"line":43,"address":[3813809],"length":1,"stats":{"Line":5}},{"line":59,"address":[6571468,6571456],"length":1,"stats":{"Line":48}},{"line":61,"address":[3576023,3576174,3576655],"length":1,"stats":{"Line":39}},{"line":68,"address":[2836196],"length":1,"stats":{"Line":15}},{"line":69,"address":[4350540,4350591],"length":1,"stats":{"Line":2}},{"line":70,"address":[3356533],"length":1,"stats":{"Line":1}},{"line":73,"address":[3356177],"length":1,"stats":{"Line":3}},{"line":83,"address":[3577991,3577929],"length":1,"stats":{"Line":10}},{"line":84,"address":[3656387,3656455],"length":1,"stats":{"Line":10}},{"line":87,"address":[5065919,5065355,5065735],"length":1,"stats":{"Line":5}},{"line":89,"address":[6406202],"length":1,"stats":{"Line":1}},{"line":91,"address":[4351708],"length":1,"stats":{"Line":3}},{"line":92,"address":[4352124,4351740],"length":1,"stats":{"Line":6}},{"line":93,"address":[3714641],"length":1,"stats":{"Line":3}},{"line":99,"address":[3578685],"length":1,"stats":{"Line":1}},{"line":101,"address":[5066227],"length":1,"stats":{"Line":1}}],"covered":18,"coverable":18},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","grpc","sender.rs"],"content":"use common::Result;\n\n// Import the generated protobuf code from actioncontroller.proto\n\nuse common::actioncontroller::connect_server;\n\n// Import the generated protobuf code from actioncontroller.proto\nuse common::actioncontroller::action_controller_connection_client::ActionControllerConnectionClient;\n\n/// Sender for making gRPC requests to ActionController\n#[derive(Clone)]\npub struct FilterGatewaySender {}\n\nimpl FilterGatewaySender {\n    /// Create a new FilterGatewaySender\n    ///\n    /// # Returns\n    ///\n    /// A new FilterGatewaySender instance\n    pub fn new() -\u003e Self {\n        Self {}\n    }\n\n    /// Trigger an action for a scenario\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn trigger_action(\u0026mut self, scenario_name: String) -\u003e Result\u003c()\u003e {\n        if scenario_name.trim().is_empty() {\n            return Err(\"Invalid scenario name: cannot be empty\".into());\n        }\n        use common::actioncontroller::TriggerActionRequest;\n        let mut client = ActionControllerConnectionClient::connect(connect_server())\n            .await\n            .unwrap();\n\n        let request = TriggerActionRequest { scenario_name };\n\n        client.trigger_action(request).await.map_err(|e| {\n            log::error!(\"Failed to trigger action: {:?}\", e);\n            anyhow::anyhow!(\"Failed to trigger action: {:?}\", e)\n        })?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use anyhow::Error;\n    use common::actioncontroller::{\n        action_controller_connection_server::{\n            ActionControllerConnection, ActionControllerConnectionServer,\n        },\n        ReconcileRequest, ReconcileResponse, TriggerActionRequest, TriggerActionResponse,\n    };\n    use std::net::SocketAddr;\n    use std::panic::{catch_unwind, AssertUnwindSafe};\n    use tokio::sync::oneshot;\n    use tokio::time::{sleep, Duration};\n    use tonic::{transport::Server, Request, Response, Status};\n\n    #[derive(Default)]\n    struct MockActionController;\n\n    #[tonic::async_trait]\n    impl ActionControllerConnection for MockActionController {\n        async fn trigger_action(\n            \u0026self,\n            request: Request\u003cTriggerActionRequest\u003e,\n        ) -\u003e std::result::Result\u003cResponse\u003cTriggerActionResponse\u003e, Status\u003e {\n            let scenario_name = request.into_inner().scenario_name;\n\n            println!(\"Mock server received trigger_action: {:?}\", scenario_name);\n\n            if scenario_name.trim().is_empty() {\n                // Return gRPC invalid argument error if scenario is empty\n                println!(\"cannot: {:?}\", scenario_name);\n                return Err(Status::invalid_argument(\"Scenario name cannot be empty\"));\n            }\n            Ok(Response::new(TriggerActionResponse {\n                desc: \"OK\".to_string(),\n                status: 0,\n            }))\n        }\n\n        async fn reconcile(\n            \u0026self,\n            _request: Request\u003cReconcileRequest\u003e,\n        ) -\u003e std::result::Result\u003cResponse\u003cReconcileResponse\u003e, Status\u003e {\n            Ok(Response::new(ReconcileResponse::default()))\n        }\n    }\n\n    async fn spawn_mock_server(\n        addr: SocketAddr,\n    ) -\u003e (oneshot::Sender\u003c()\u003e, tokio::task::JoinHandle\u003c()\u003e) {\n        let (shutdown_tx, shutdown_rx) = oneshot::channel::\u003c()\u003e();\n\n        let server_handle = tokio::spawn(async move {\n            Server::builder()\n                .add_service(ActionControllerConnectionServer::new(\n                    MockActionController::default(),\n                ))\n                .serve_with_shutdown(addr, async {\n                    shutdown_rx.await.ok();\n                })\n                .await\n                .unwrap();\n        });\n\n        sleep(Duration::from_millis(200)).await;\n\n        (shutdown_tx, server_handle)\n    }\n\n    #[tokio::test]\n    async fn test_trigger_action_empty_scenario_name_should_fail() {\n        let addr = \"0.0.0.0:47001\".parse().unwrap();\n\n        // Check port availability\n        let port_available = std::net::TcpListener::bind(addr).is_ok();\n\n        let (shutdown_tx, server_handle): (\n            Option\u003ctokio::sync::oneshot::Sender\u003c()\u003e\u003e,\n            Option\u003ctokio::task::JoinHandle\u003c()\u003e\u003e,\n        ) = if port_available {\n            let (tx, handle) = spawn_mock_server(addr).await;\n            (Some(tx), Some(handle))\n        } else {\n            (None, None)\n        };\n\n        let mut sender = FilterGatewaySender::new();\n        let result = sender.trigger_action(\"\".to_string()).await;\n\n        assert!(result.is_err());\n\n        if let Some(tx) = shutdown_tx {\n            let _ = tx.send(());\n        }\n        if let Some(handle) = server_handle {\n            let _ = handle.await;\n        }\n    }\n\n    /// Test case to validate failure due to connection error\n    #[tokio::test]\n    async fn test_trigger_action_failure_connection_error() {\n        let mut sender = FilterGatewaySender::new();\n        let result = sender.trigger_action(\"\".to_string()).await;\n\n        if let Err(e) = \u0026result {\n            println!(\"Expected failure occurred: {}\", e);\n        }\n\n        assert!(result.is_err(), \"Expected error but got success\")\n    }\n\n    /// Test case to validate failure when `connect_server` returns an empty server address\n    #[tokio::test]\n    async fn test_trigger_action_failure_empty_server_address() {\n        let mut sender = FilterGatewaySender::new();\n        let scenario_name = \"test_scenario\".to_string();\n\n        // Simulate empty server address\n        let result = ActionControllerConnectionClient::connect(\"\").await;\n\n        // Assert that the connection attempt fails\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":33,"address":[3522280,3522272],"length":1,"stats":{"Line":62}},{"line":34,"address":[4170578,4170430],"length":1,"stats":{"Line":29}},{"line":35,"address":[4114277,4114439],"length":1,"stats":{"Line":12}},{"line":38,"address":[3888355,3888667,3888692,3888301,3888242],"length":1,"stats":{"Line":37}},{"line":39,"address":[4017016,4017197,4016633,4016856,4016913],"length":1,"stats":{"Line":31}},{"line":42,"address":[3888730],"length":1,"stats":{"Line":4}},{"line":44,"address":[4235724],"length":1,"stats":{"Line":34}},{"line":45,"address":[4115821,4115854,4115740],"length":1,"stats":{"Line":12}},{"line":46,"address":[3743208,3743469],"length":1,"stats":{"Line":8}},{"line":49,"address":[4824880],"length":1,"stats":{"Line":7}}],"covered":10,"coverable":10},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","lib.rs"],"content":"pub mod filter;\npub mod grpc;\npub mod manager;\npub mod vehicle;\n\n// Re-export what you need in tests:\npub use common::spec::artifact::Scenario;\npub use common::Result;\npub use filter::Filter;\npub use grpc::receiver::FilterGatewayReceiver;\npub use grpc::sender::FilterGatewaySender;\npub use manager::ScenarioParameter;\nuse tokio::sync::mpsc::{channel, Receiver, Sender};\npub use vehicle::dds::listener;\npub use vehicle::dds::DdsData;\npub use vehicle::dds::DdsTopicListener;\npub async fn launch_manager(rx_grpc: Receiver\u003cScenarioParameter\u003e) {\n    let mut manager = manager::FilterGatewayManager::new(rx_grpc).await;\n\n    match manager.initialize().await {\n        Ok(_) =\u003e {\n            println!(\"FilterGatewayManager successfully initialized\");\n            // Only proceed to run if initialization was successful\n            if let Err(e) = manager.run().await {\n                eprintln!(\"Error running FilterGatewayManager: {:?}\", e);\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"Failed to initialize FilterGatewayManager: {:?}\", e);\n        }\n    }\n}\n\n/// Initialize FilterGateway\n///\n/// Sets up the manager thread, gRPC services, and DDS listeners.\n/// This is the main initialization function for the FilterGateway component.\n///\n/// # Returns\n///\npub async fn initialize(tx_grpc: Sender\u003cmanager::ScenarioParameter\u003e) {\n    // Set up logging\n\n    // let mut manager = manager::FilterGatewayManager::new(rx_grpc, tx_dds, rx_dds);\n    // manager.run().await;\n\n    use common::filtergateway::filter_gateway_connection_server::FilterGatewayConnectionServer;\n    use tonic::transport::Server;\n\n    let server = crate::grpc::receiver::FilterGatewayReceiver::new(tx_grpc);\n    let addr = common::filtergateway::open_server()\n        .parse()\n        .expect(\"gateway address parsing error\");\n\n    println!(\"Piccolod gateway listening on {}\", addr);\n\n    let _ = Server::builder()\n        .add_service(FilterGatewayConnectionServer::new(server))\n        .serve(addr)\n        .await;\n}\n","traces":[{"line":17,"address":[3127735,3128409,3128424,3127834,3127680,3128008],"length":1,"stats":{"Line":8}},{"line":18,"address":[2560480],"length":1,"stats":{"Line":4}},{"line":20,"address":[3147480,3147900,3147970,3148086,3148314],"length":1,"stats":{"Line":10}},{"line":22,"address":[3128743,3128811],"length":1,"stats":{"Line":4}},{"line":24,"address":[2560523],"length":1,"stats":{"Line":9}},{"line":25,"address":[5751194,5751270],"length":1,"stats":{"Line":0}},{"line":28,"address":[3128689],"length":1,"stats":{"Line":0}},{"line":29,"address":[3129055,3128733],"length":1,"stats":{"Line":0}},{"line":41,"address":[3469568,3469576],"length":1,"stats":{"Line":8}},{"line":50,"address":[3129886,3130002],"length":1,"stats":{"Line":4}},{"line":51,"address":[3130147,3130082,3130019],"length":1,"stats":{"Line":6}},{"line":55,"address":[5751999],"length":1,"stats":{"Line":2}},{"line":57,"address":[5752555,5752265,5752092,5752210,5752327],"length":1,"stats":{"Line":9}},{"line":58,"address":[5752129],"length":1,"stats":{"Line":2}},{"line":59,"address":[3130441],"length":1,"stats":{"Line":2}},{"line":60,"address":[3130372,3130516,3130553,3130609,3130803,3129925],"length":1,"stats":{"Line":8}}],"covered":13,"coverable":16},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","main.rs"],"content":"mod filter;\nmod grpc;\nmod manager;\nmod vehicle;\n\n// Moved `launch_manager` and `initialize` function from `main.rs` to `lib.rs` to:\n// 1. Enable code reuse and better modularity.\n// 2. Facilitate integration and unit testing by making it publicly accessible.\n// 3. Avoid duplicating logic and allow tests to directly call this async function.\n// 4. Simplify the main entry point by keeping `main.rs` focused on orchestration.\n//\n// This approach helps maintain a clean separation between application logic\n// (in the library crate) and the binary entry point (in `main.rs`).\n//\n// Note: The `ScenarioParameter` type is re-exported from the manager module\n// via `lib.rs` to ensure a single source of truth and prevent type mismatches.\nuse filtergateway::ScenarioParameter;\nuse filtergateway::{initialize, launch_manager};\nuse tokio::sync::mpsc::{channel, Receiver, Sender};\n\n#[cfg(not(tarpaulin_include))]\n#[tokio::main]\nasync fn main() {\n    // Initialize tracing subscriber for logging\n\n    let (tx_grpc, rx_grpc): (Sender\u003cScenarioParameter\u003e, Receiver\u003cScenarioParameter\u003e) = channel(100);\n    // Launch the manager thread\n    let mgr = launch_manager(rx_grpc);\n\n    // Initialize the application\n    let grpc = initialize(tx_grpc);\n\n    tokio::join!(mgr, grpc);\n}\n//Unit Test Cases\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tokio::task::LocalSet;\n    use tokio::time::{sleep, Duration};\n\n    /// Test to ensure that the channels are initialized with the correct capacity\n    #[tokio::test]\n    async fn test_main_initializes_channels() {\n        let (tx_grpc, rx_grpc): (Sender\u003cScenarioParameter\u003e, Receiver\u003cScenarioParameter\u003e) =\n            channel(100);\n        assert_eq!(tx_grpc.capacity(), 100); // Check if the channel capacity is set correctly\n        assert!(!rx_grpc.is_closed()); // Ensure the receiver is not closed\n    }\n\n    /// Test to ensure that the manager thread launches without any panic\n    #[tokio::test(flavor = \"multi_thread\")]\n    async fn test_main_launch_manager() {\n        let (_tx_grpc, rx_grpc): (Sender\u003cScenarioParameter\u003e, Receiver\u003cScenarioParameter\u003e) =\n            channel(100);\n\n        // Use LocalSet to run a non-Send future like launch_manager\n        let local = LocalSet::new();\n        local.spawn_local(async move {\n            let _ = launch_manager(rx_grpc).await;\n        });\n\n        // Run the local task for a short time to simulate launch\n        tokio::select! {\n            _ = local =\u003e {}\n            _ = sleep(Duration::from_millis(200)) =\u003e {}\n        }\n\n        // Test is successful if it reaches this point\n        assert!(true);\n    }\n\n    /// Test to ensure that the gRPC initialization runs without any panic\n    #[tokio::test(flavor = \"multi_thread\")]\n    async fn test_main_initialize_grpc() {\n        let (tx_grpc, _rx_grpc): (Sender\u003cScenarioParameter\u003e, Receiver\u003cScenarioParameter\u003e) =\n            channel(100);\n\n        let local = LocalSet::new();\n        local.spawn_local(async move {\n            let _ = initialize(tx_grpc).await;\n        });\n\n        tokio::select! {\n            _ = local =\u003e {}\n            _ = sleep(Duration::from_millis(200)) =\u003e {}\n        }\n\n        assert!(true);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","manager.rs"],"content":"use crate::filter::Filter;\nuse crate::grpc::sender::FilterGatewaySender;\nuse crate::vehicle::dds::DdsData;\nuse crate::vehicle::VehicleManager;\nuse common::spec::artifact::Scenario;\nuse common::{spec::artifact::Artifact, Result};\n// use dust_dds::infrastructure::wait_set::Condition;\nuse std::sync::Arc;\nuse tokio::sync::{mpsc, Mutex};\n\n/// Manager for FilterGateway\n///\n/// Responsible for:\n/// - Managing scenario filters\n/// - Coordinating vehicle data subscriptions\n/// - Processing incoming scenario requests\n///\n#[derive(Debug)]\npub struct ScenarioParameter {\n    /// Name of the scenario\n    pub action: i32,\n    /// Vehicle message information\n    pub scenario: Scenario,\n}\n\npub struct FilterGatewayManager {\n    /// Receiver for scenario information from gRPC\n    pub rx_grpc: Arc\u003cMutex\u003cmpsc::Receiver\u003cScenarioParameter\u003e\u003e\u003e,\n    /// Receiver for DDS data\n    pub rx_dds: Arc\u003cMutex\u003cmpsc::Receiver\u003cDdsData\u003e\u003e\u003e,\n    /// Active filters for scenarios\n    pub filters: Arc\u003cMutex\u003cVec\u003cFilter\u003e\u003e\u003e,\n    /// gRPC sender for action controller\n    pub sender: Arc\u003cMutex\u003cFilterGatewaySender\u003e\u003e,\n    /// Vehicle manager for handling vehicle data\n    pub vehicle_manager: Arc\u003cMutex\u003cVehicleManager\u003e\u003e,\n}\n\nimpl FilterGatewayManager {\n    /// Creates a new FilterGatewayManager instance\n    ///\n    /// # Arguments\n    ///\n    /// * `rx` - Channel receiver for scenario information\n    ///\n    /// # Returns\n    ///\n    /// A new FilterGatewayManager instance\n\n    pub async fn new(rx_grpc: mpsc::Receiver\u003cScenarioParameter\u003e) -\u003e Self {\n        let (tx_dds, rx_dds) = mpsc::channel::\u003cDdsData\u003e(10);\n        let mut vehicle_manager = VehicleManager::new(tx_dds);\n\n        // Improved error handling: explicit error handling instead of unwrap()\n        if let Err(e) = vehicle_manager.init().await {\n            println!(\"Warning: Failed to initialize vehicle manager: {:?}. Continuing with default settings.\", e);\n            // Continue (already using default values in VehicleManager::init())\n        }\n\n        Self {\n            rx_grpc: Arc::new(Mutex::new(rx_grpc)),\n            rx_dds: Arc::new(Mutex::new(rx_dds)),\n            filters: Arc::new(Mutex::new(Vec::new())),\n            sender: Arc::new(Mutex::new(FilterGatewaySender::new())),\n            vehicle_manager: Arc::new(Mutex::new(vehicle_manager)),\n        }\n    }\n    /// Function to initialize the FilterGatewayManager\n    ///\n    ///\n    /// This function reads all scenarios from etcd and subscribes to the necessary vehicle data topics.\n    /// It also launches the scenario filters.\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn initialize(\u0026self) -\u003e Result\u003c()\u003e {\n        print!(\"FilterGatewayManager init\\n\");\n        // Initialize vehicle manager\n        let etcd_scenario = Self::read_all_scenario_from_etcd().await?;\n        for scenario in etcd_scenario {\n            let scenario: Scenario = serde_yaml::from_str(\u0026scenario)?;\n            println!(\"Scenario: {:?}\", scenario);\n            let topic_name = scenario\n                .get_conditions()\n                .as_ref()\n                .map(|cond| cond.get_operand_value())\n                .unwrap_or_default();\n            let data_type_name = scenario\n                .get_conditions()\n                .as_ref()\n                .map(|cond| cond.get_operand_value())\n                .unwrap_or_default();\n            let mut vehicle_manager = self.vehicle_manager.lock().await;\n            if let Err(e) = vehicle_manager\n                .subscribe_topic(topic_name, data_type_name)\n                .await\n            {\n                eprintln!(\"Error subscribing to vehicle data: {:?}\", e);\n            }\n            self.launch_scenario_filter(scenario).await?;\n        }\n        Ok(())\n    }\n\n    /// Function to receive subscribed DDS data and pass it to filters\n    ///\n    /// This function runs as a separate task to continuously receive and process DDS data.\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    async fn process_dds_data(\u0026self) -\u003e Result\u003c()\u003e {\n        // Create clone of shared receiver\n        let rx_dds = Arc::clone(\u0026self.rx_dds);\n\n        // Receive loop\n        loop {\n            let mut receiver = rx_dds.lock().await;\n\n            // Receive DDS data\n            match receiver.recv().await {\n                Some(dds_data) =\u003e {\n                    // Log DDS data reception\n                    println!(\n                        \"Received DDS data: topic={}, value={}\",\n                        dds_data.name, dds_data.value\n                    );\n\n                    // Forward data to all active filters\n                    let mut filters = self.filters.lock().await;\n                    for filter in filters.iter_mut() {\n                        if filter.is_active() {\n                            // Pass DDS data to filter\n                            if let Err(e) = filter.process_data(\u0026dds_data).await {\n                                println!(\n                                    \"Error processing DDS data in filter {}: {:?}\",\n                                    filter.scenario_name, e\n                                );\n                            }\n                        }\n                    }\n                }\n                None =\u003e {\n                    // Channel closed\n                    println!(\"DDS data channel closed, stopping processor\");\n                    break;\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Function to process gRPC requests\n    ///\n    /// This function processes scenario requests coming through gRPC.\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    async fn process_grpc_requests(\u0026self) -\u003e Result\u003c()\u003e {\n        loop {\n            // Wait for scenario parameter from gRPC\n            let scenario_parameter = {\n                let mut rx_grpc = self.rx_grpc.lock().await;\n                rx_grpc.recv().await\n            };\n\n            match scenario_parameter {\n                Some(param) =\u003e {\n                    println!(\"Received scenario parameter: {:?}\", param);\n                    match param.action {\n                        0 =\u003e {\n                            // Allow\n                            // Subscribe to vehicle data\n                            let topic_name = param\n                                .scenario\n                                .get_conditions()\n                                .as_ref()\n                                .map(|cond| cond.get_operand_value())\n                                .unwrap_or_default();\n                            let data_type_name = param\n                                .scenario\n                                .get_conditions()\n                                .as_ref()\n                                .map(|cond| cond.get_operand_value())\n                                .unwrap_or_default();\n                            let mut vehicle_manager = self.vehicle_manager.lock().await;\n                            if let Err(e) = vehicle_manager\n                                .subscribe_topic(topic_name, data_type_name)\n                                .await\n                            {\n                                eprintln!(\"Error subscribing to vehicle data: {:?}\", e);\n                            }\n                            self.launch_scenario_filter(param.scenario).await?;\n                        }\n                        1 =\u003e {\n                            // Withdraw\n                            // Unsubscribe from vehicle data\n                            let mut vehicle_manager = self.vehicle_manager.lock().await;\n                            if let Err(e) = vehicle_manager\n                                .unsubscribe_topic(param.scenario.get_name().clone())\n                                .await\n                            {\n                                eprintln!(\"Error unsubscribing from vehicle data: {:?}\", e);\n                            }\n                            self.remove_scenario_filter(param.scenario.get_name().clone())\n                                .await?;\n                        }\n                        _ =\u003e {}\n                    }\n                }\n                None =\u003e {\n                    // Channel closed\n                    println!(\"gRPC channel closed, stopping processor\");\n                    break;\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Start the manager processing\n    ///\n    /// This function processes incoming scenario requests and\n    /// coordinates DDS data handling.\n    ///\n    /// # Returns\n    pub async fn run(self) -\u003e Result\u003c()\u003e {\n        // 자신을 Arc로 래핑\n        let arc_self = Arc::new(self);\n\n        // DDS 데이터 처리 태스크 시작\n        let gateway_dds_manager = Arc::clone(\u0026arc_self);\n        let dds_processor = tokio::spawn(async move {\n            if let Err(e) = gateway_dds_manager.process_dds_data().await {\n                eprintln!(\"Error in DDS processor: {:?}\", e);\n            }\n        });\n\n        // gRPC 요청 처리를 위해 process_grpc_requests도 \u0026self로 수정해야 함\n        let gateway_grpc_manager = Arc::clone(\u0026arc_self);\n        let grpc_processor = tokio::spawn(async move {\n            if let Err(e) = gateway_grpc_manager.process_grpc_requests().await {\n                eprintln!(\"Error in gRPC processor: {:?}\", e);\n            }\n        });\n\n        // 태스크 완료 대기\n        let _ = tokio::try_join!(dds_processor, grpc_processor);\n\n        println!(\"FilterGatewayManager stopped\");\n\n        Ok(())\n    }\n    ///\n    /// Registers a subscription to vehicle data topics needed for a scenario.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    /// * `vehicle_message` - Vehicle message information containing topic details\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn subscribe_vehicle_data(\u0026self, vehicle_message: DdsData) -\u003e Result\u003c()\u003e {\n        print!(\"subscribe vehicle data {}\\n\", vehicle_message.name);\n        println!(\"subscribe vehicle data {}\", vehicle_message.value);\n        let mut vehicle_manager = self.vehicle_manager.lock().await;\n        vehicle_manager\n            .subscribe_topic(vehicle_message.name, vehicle_message.value)\n            .await?;\n\n        Ok(())\n    }\n\n    /// Unsubscribe from vehicle data for a scenario\n    ///\n    /// Cancels a subscription to vehicle data topics for a scenario.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    /// * `vehicle_message` - Vehicle message information containing topic details\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn unsubscribe_vehicle_data(\u0026self, vehicle_message: DdsData) -\u003e Result\u003c()\u003e {\n        print!(\"unsubscribe vehicle data {}\\n\", vehicle_message.name);\n        let mut vehicle_manager = self.vehicle_manager.lock().await;\n        vehicle_manager\n            .unsubscribe_topic(vehicle_message.name)\n            .await?;\n\n        Ok(())\n    }\n\n    /// Create and launch a filter for a scenario\n    ///\n    /// Creates a new filter for processing a scenario's conditions and\n    /// launches it as a separate thread.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario` - Complete scenario information\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn launch_scenario_filter(\u0026self, scenario: Scenario) -\u003e Result\u003c()\u003e {\n        // Check if the scenario has conditions\n        if scenario.get_conditions().is_none() {\n            println!(\"No conditions for scenario: {}\", scenario.get_name());\n            let mut sender = self.sender.lock().await;\n            sender.trigger_action(scenario.get_name().clone()).await?;\n            return Ok(());\n        }\n\n        let sender = {\n            let sender_guard = self.sender.lock().await;\n            sender_guard.clone()\n        };\n        let filter = Filter::new(scenario.get_name().to_string(), scenario, true, sender);\n\n        // Add the filter to our managed collection\n        {\n            // Prevent duplicate filters for the same scenario\n            let mut filters = self.filters.lock().await;\n            if filters\n                .iter()\n                .any(|f| f.scenario_name == filter.scenario_name)\n            {\n                println!(\n                    \"Filter for scenario '{}' already exists, skipping.\",\n                    filter.scenario_name\n                );\n                return Ok(());\n            }\n            filters.push(filter);\n        }\n        Ok(())\n    }\n\n    /// Remove a filter for a scenario\n    ///\n    /// Stops and removes the filter associated with a scenario.\n    ///\n    /// # Arguments\n    ///\n    /// * `scenario_name` - Name of the scenario\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn remove_scenario_filter(\u0026self, scenario_name: String) -\u003e Result\u003c()\u003e {\n        println!(\"remove filter {}\\n\", scenario_name);\n\n        let arc_filters = Arc::clone(\u0026self.filters);\n        let mut filters = arc_filters.lock().await;\n        let index = filters\n            .iter()\n            .position(|f| f.scenario_name == scenario_name);\n        if let Some(i) = index {\n            filters.remove(i);\n        }\n        Ok(())\n    }\n\n    /// Read all scenario yaml string in etcd\n    ///\n    /// ### Parameters\n    /// * None\n    /// ### Return\n    /// * `Result\u003cVec\u003cString\u003e\u003e` - `Ok(_)` contains scenario yaml string vector\n    async fn read_all_scenario_from_etcd() -\u003e common::Result\u003cVec\u003cString\u003e\u003e {\n        let kv_scenario = common::etcd::get_all_with_prefix(\"Scenario\").await?;\n        let values = kv_scenario.into_iter().map(|kv| kv.value).collect();\n\n        Ok(values)\n    }\n}\n//Unit Tets Cases\n#[cfg(test)]\nmod tests {\n    use anyhow::Result;\n    use std::sync::{\n        atomic::{AtomicBool, Ordering},\n        Arc,\n    };\n    use tokio::sync::{mpsc, Mutex};\n\n    // ===== Dummy scenario and condition structs for simulating scenarios =====\n    #[derive(Debug, Clone)]\n    struct DummyScenario {\n        name: String,\n        has_conditions: bool,\n    }\n\n    impl DummyScenario {\n        pub fn get_name(\u0026self) -\u003e String {\n            self.name.clone()\n        }\n\n        pub fn get_conditions(\u0026self) -\u003e Option\u003cDummyCondition\u003e {\n            if self.has_conditions {\n                Some(DummyCondition {})\n            } else {\n                None\n            }\n        }\n    }\n\n    #[derive(Debug, Clone)]\n    struct DummyCondition;\n\n    impl DummyCondition {\n        pub fn get_operand_value(\u0026self) -\u003e String {\n            \"topic\".to_string()\n        }\n    }\n\n    #[derive(Debug, Clone)]\n    struct DummyScenarioParam {\n        pub action: u32,\n        pub scenario: DummyScenario,\n    }\n\n    // ===== Mock VehicleManager for subscribe/unsubscribe simulation =====\n    struct MockVehicleManager {\n        pub subscribed: Arc\u003cAtomicBool\u003e,\n        pub unsubscribed: Arc\u003cAtomicBool\u003e,\n    }\n\n    impl MockVehicleManager {\n        async fn subscribe_topic(\u0026self, _topic: String, _dtype: String) -\u003e Result\u003c()\u003e {\n            self.subscribed.store(true, Ordering::SeqCst);\n            Ok(())\n        }\n\n        async fn unsubscribe_topic(\u0026self, _topic: String) -\u003e Result\u003c()\u003e {\n            self.unsubscribed.store(true, Ordering::SeqCst);\n            Ok(())\n        }\n    }\n\n    // ===== DummyManager simulates your core manager behavior =====\n    struct DummyManager {\n        rx_grpc: Arc\u003cMutex\u003cmpsc::Receiver\u003cDummyScenarioParam\u003e\u003e\u003e,\n        vehicle_manager: Arc\u003cMutex\u003cMockVehicleManager\u003e\u003e,\n        launched: Arc\u003cAtomicBool\u003e,\n        removed: Arc\u003cAtomicBool\u003e,\n    }\n\n    impl DummyManager {\n        // Simulate launching scenario filter\n        async fn launch_scenario_filter(\u0026self, _scenario: DummyScenario) -\u003e Result\u003c()\u003e {\n            self.launched.store(true, Ordering::SeqCst);\n            Ok(())\n        }\n\n        // Simulate removing scenario filter\n        async fn remove_scenario_filter(\u0026self, _name: String) -\u003e Result\u003c()\u003e {\n            self.removed.store(true, Ordering::SeqCst);\n            Ok(())\n        }\n\n        // Processes incoming gRPC requests asynchronously\n        async fn process_grpc_requests(\u0026self) -\u003e Result\u003c()\u003e {\n            loop {\n                let scenario_parameter = {\n                    let mut rx_grpc = self.rx_grpc.lock().await;\n                    rx_grpc.recv().await\n                };\n\n                match scenario_parameter {\n                    Some(param) =\u003e {\n                        match param.action {\n                            0 =\u003e {\n                                // Subscribe + Launch\n                                let topic = param\n                                    .scenario\n                                    .get_conditions()\n                                    .map(|cond| cond.get_operand_value())\n                                    .unwrap_or_default();\n                                let vm = self.vehicle_manager.lock().await;\n                                vm.subscribe_topic(topic.clone(), topic.clone()).await?;\n                                self.launch_scenario_filter(param.scenario).await?;\n                            }\n                            1 =\u003e {\n                                // Unsubscribe + Remove\n                                let vm = self.vehicle_manager.lock().await;\n                                vm.unsubscribe_topic(param.scenario.get_name()).await?;\n                                self.remove_scenario_filter(param.scenario.get_name())\n                                    .await?;\n                            }\n                            _ =\u003e { // Unknown action, do nothing\n                                 // Could log or ignore\n                            }\n                        }\n                    }\n                    None =\u003e break, // Channel closed\n                }\n            }\n            Ok(())\n        }\n\n        // Subscribe to vehicle data via DDS\n        async fn subscribe_vehicle_data(\u0026self, msg: DdsData) -\u003e Result\u003c()\u003e {\n            let vm = self.vehicle_manager.lock().await;\n            vm.subscribe_topic(msg.name.clone(), msg.value.clone())\n                .await\n        }\n\n        // Unsubscribe vehicle data via DDS\n        async fn unsubscribe_vehicle_data(\u0026self, msg: DdsData) -\u003e Result\u003c()\u003e {\n            let vm = self.vehicle_manager.lock().await;\n            vm.unsubscribe_topic(msg.name.clone()).await\n        }\n    }\n\n    // ===== DDS data structure used in tests =====\n    #[derive(Clone)]\n    struct DdsData {\n        pub name: String,\n        pub value: String,\n    }\n\n    // ===== Dummy DDS data and MockFilter for filter testing =====\n    #[derive(Debug, Clone)]\n    struct DummyDdsData {\n        pub name: String,\n        pub value: String,\n    }\n\n    struct MockFilter {\n        pub name: String,\n        pub called: Arc\u003cAtomicBool\u003e,\n        pub should_be_active: bool,\n    }\n\n    impl MockFilter {\n        pub fn is_active(\u0026self) -\u003e bool {\n            self.should_be_active\n        }\n\n        pub async fn process_data(\u0026mut self, data: \u0026DummyDdsData) -\u003e Result\u003c()\u003e {\n            println!(\"MockFilter received: {:?}\", data);\n            self.called.store(true, Ordering::SeqCst);\n            Ok(())\n        }\n    }\n\n    struct DummyFilterManager {\n        rx_dds: Arc\u003cMutex\u003cmpsc::Receiver\u003cDummyDdsData\u003e\u003e\u003e,\n        filters: Arc\u003cMutex\u003cVec\u003cMockFilter\u003e\u003e\u003e,\n    }\n\n    impl DummyFilterManager {\n        // Process DDS data and apply active filters\n        async fn process_dds_data(\u0026self) -\u003e Result\u003c()\u003e {\n            let rx_dds = Arc::clone(\u0026self.rx_dds);\n            loop {\n                let mut receiver = rx_dds.lock().await;\n\n                match receiver.recv().await {\n                    Some(dds_data) =\u003e {\n                        println!(\n                            \"Received DDS data: topic={}, value={}\",\n                            dds_data.name, dds_data.value\n                        );\n\n                        let mut filters = self.filters.lock().await;\n                        for filter in filters.iter_mut() {\n                            if filter.is_active() {\n                                if let Err(e) = filter.process_data(\u0026dds_data).await {\n                                    println!(\"Error processing data: {:?}\", e);\n                                }\n                            }\n                        }\n                    }\n                    None =\u003e {\n                        println!(\"Channel closed.\");\n                        break;\n                    }\n                }\n            }\n\n            Ok(())\n        }\n    }\n\n    // ==================== Tests ==========================\n\n    /// Test that a gRPC 'allow' request correctly subscribes and launches scenario filter\n    #[tokio::test]\n    async fn test_grpc_allow() {\n        let (tx, rx) = mpsc::channel(1);\n        let manager = DummyManager {\n            rx_grpc: Arc::new(Mutex::new(rx)),\n            vehicle_manager: Arc::new(Mutex::new(MockVehicleManager {\n                subscribed: Arc::new(AtomicBool::new(false)),\n                unsubscribed: Arc::new(AtomicBool::new(false)),\n            })),\n            launched: Arc::new(AtomicBool::new(false)),\n            removed: Arc::new(AtomicBool::new(false)),\n        };\n\n        let subscribed = Arc::clone(\u0026manager.vehicle_manager.lock().await.subscribed);\n        let launched = Arc::clone(\u0026manager.launched);\n\n        let scenario = DummyScenario {\n            name: \"AllowTest\".into(),\n            has_conditions: true,\n        };\n        tx.send(DummyScenarioParam {\n            action: 0,\n            scenario,\n        })\n        .await\n        .unwrap();\n        drop(tx);\n\n        manager.process_grpc_requests().await.unwrap();\n\n        assert!(\n            subscribed.load(Ordering::SeqCst),\n            \"Vehicle should be subscribed\"\n        );\n        assert!(\n            launched.load(Ordering::SeqCst),\n            \"Scenario filter should be launched\"\n        );\n    }\n\n    /// Test that a gRPC 'withdraw' request correctly unsubscribes and removes scenario filter\n    #[tokio::test]\n    async fn test_grpc_withdraw() {\n        let (tx, rx) = mpsc::channel(1);\n        let manager = DummyManager {\n            rx_grpc: Arc::new(Mutex::new(rx)),\n            vehicle_manager: Arc::new(Mutex::new(MockVehicleManager {\n                subscribed: Arc::new(AtomicBool::new(false)),\n                unsubscribed: Arc::new(AtomicBool::new(false)),\n            })),\n            launched: Arc::new(AtomicBool::new(false)),\n            removed: Arc::new(AtomicBool::new(false)),\n        };\n\n        let unsubscribed = Arc::clone(\u0026manager.vehicle_manager.lock().await.unsubscribed);\n        let removed = Arc::clone(\u0026manager.removed);\n\n        let scenario = DummyScenario {\n            name: \"WithdrawTest\".into(),\n            has_conditions: false,\n        };\n        tx.send(DummyScenarioParam {\n            action: 1,\n            scenario,\n        })\n        .await\n        .unwrap();\n        drop(tx);\n\n        manager.process_grpc_requests().await.unwrap();\n\n        assert!(\n            unsubscribed.load(Ordering::SeqCst),\n            \"Vehicle should be unsubscribed\"\n        );\n        assert!(\n            removed.load(Ordering::SeqCst),\n            \"Scenario filter should be removed\"\n        );\n    }\n\n    /// Negative test: Unknown action code should not subscribe or unsubscribe anything\n    #[tokio::test]\n    async fn test_grpc_unknown_action() {\n        let (tx, rx) = mpsc::channel(1);\n        let manager = DummyManager {\n            rx_grpc: Arc::new(Mutex::new(rx)),\n            vehicle_manager: Arc::new(Mutex::new(MockVehicleManager {\n                subscribed: Arc::new(AtomicBool::new(false)),\n                unsubscribed: Arc::new(AtomicBool::new(false)),\n            })),\n            launched: Arc::new(AtomicBool::new(false)),\n            removed: Arc::new(AtomicBool::new(false)),\n        };\n\n        let scenario = DummyScenario {\n            name: \"UnknownAction\".into(),\n            has_conditions: true,\n        };\n        tx.send(DummyScenarioParam {\n            action: 99,\n            scenario,\n        })\n        .await\n        .unwrap();\n        drop(tx);\n\n        manager.process_grpc_requests().await.unwrap();\n\n        assert!(\n            !manager\n                .vehicle_manager\n                .lock()\n                .await\n                .subscribed\n                .load(Ordering::SeqCst),\n            \"No subscription should happen\"\n        );\n        assert!(\n            !manager\n                .vehicle_manager\n                .lock()\n                .await\n                .unsubscribed\n                .load(Ordering::SeqCst),\n            \"No unsubscription should happen\"\n        );\n        assert!(\n            !manager.launched.load(Ordering::SeqCst),\n            \"No scenario should be launched\"\n        );\n        assert!(\n            !manager.removed.load(Ordering::SeqCst),\n            \"No scenario should be removed\"\n        );\n    }\n\n    /// Test successful subscription to vehicle data via DDS\n    #[tokio::test]\n    async fn test_subscribe_vehicle_data() {\n        let manager = DummyManager {\n            rx_grpc: Arc::new(Mutex::new(mpsc::channel(1).1)),\n            vehicle_manager: Arc::new(Mutex::new(MockVehicleManager {\n                subscribed: Arc::new(AtomicBool::new(false)),\n                unsubscribed: Arc::new(AtomicBool::new(false)),\n            })),\n            launched: Arc::new(AtomicBool::new(false)),\n            removed: Arc::new(AtomicBool::new(false)),\n        };\n\n        let subscribed = Arc::clone(\u0026manager.vehicle_manager.lock().await.subscribed);\n\n        let msg = DdsData {\n            name: \"speed\".to_string(),\n            value: \"f32\".to_string(),\n        };\n\n        manager.subscribe_vehicle_data(msg).await.unwrap();\n\n        assert!(\n            subscribed.load(Ordering::SeqCst),\n            \"Subscription flag should be set\"\n        );\n    }\n\n    /// Test successful unsubscription from vehicle data via DDS\n    #[tokio::test]\n    async fn test_unsubscribe_vehicle_data() {\n        let manager = DummyManager {\n            rx_grpc: Arc::new(Mutex::new(mpsc::channel(1).1)),\n            vehicle_manager: Arc::new(Mutex::new(MockVehicleManager {\n                subscribed: Arc::new(AtomicBool::new(false)),\n                unsubscribed: Arc::new(AtomicBool::new(false)),\n            })),\n            launched: Arc::new(AtomicBool::new(false)),\n            removed: Arc::new(AtomicBool::new(false)),\n        };\n\n        let unsubscribed = Arc::clone(\u0026manager.vehicle_manager.lock().await.unsubscribed);\n\n        let msg = DdsData {\n            name: \"rpm\".to_string(),\n            value: \"i32\".to_string(),\n        };\n\n        manager.unsubscribe_vehicle_data(msg).await.unwrap();\n\n        assert!(\n            unsubscribed.load(Ordering::SeqCst),\n            \"Unsubscription flag should be set\"\n        );\n    }\n\n    /// Test processing DDS data through active filters and verify filter is called\n    #[tokio::test]\n    async fn test_process_dds_data_directly() {\n        let (tx, rx) = mpsc::channel(1);\n        let rx_dds = Arc::new(Mutex::new(rx));\n\n        let test_data = DummyDdsData {\n            name: \"test_topic\".to_string(),\n            value: \"42\".to_string(),\n        };\n\n        tx.send(test_data.clone()).await.unwrap();\n        drop(tx);\n\n        let called = Arc::new(AtomicBool::new(false));\n\n        let filter = MockFilter {\n            name: \"TestFilter\".to_string(),\n            called: Arc::clone(\u0026called),\n            should_be_active: true,\n        };\n\n        let filters = Arc::new(Mutex::new(vec![filter]));\n\n        let manager = DummyFilterManager {\n            rx_dds,\n            filters: Arc::clone(\u0026filters),\n        };\n\n        manager.process_dds_data().await.unwrap();\n\n        assert!(\n            called.load(Ordering::SeqCst),\n            \"Filter should have been called\"\n        );\n    }\n\n    /// Negative test: Filter inactive - filter process_data should NOT be called\n    #[tokio::test]\n    async fn test_process_dds_data_with_inactive_filter() {\n        let (tx, rx) = mpsc::channel(1);\n        let rx_dds = Arc::new(Mutex::new(rx));\n\n        let test_data = DummyDdsData {\n            name: \"test_topic\".to_string(),\n            value: \"42\".to_string(),\n        };\n\n        tx.send(test_data.clone()).await.unwrap();\n        drop(tx);\n\n        let called = Arc::new(AtomicBool::new(false));\n\n        let filter = MockFilter {\n            name: \"InactiveFilter\".to_string(),\n            called: Arc::clone(\u0026called),\n            should_be_active: false, // Filter inactive\n        };\n\n        let filters = Arc::new(Mutex::new(vec![filter]));\n\n        let manager = DummyFilterManager {\n            rx_dds,\n            filters: Arc::clone(\u0026filters),\n        };\n\n        manager.process_dds_data().await.unwrap();\n\n        assert!(\n            !called.load(Ordering::SeqCst),\n            \"Inactive filter should NOT be called\"\n        );\n    }\n    // Test case: Ensure no actions are performed when the gRPC channel is empty\n    #[tokio::test]\n    async fn test_grpc_empty_channel() {\n        let (_, rx) = mpsc::channel(1);\n        let manager = DummyManager {\n            rx_grpc: Arc::new(Mutex::new(rx)),\n            vehicle_manager: Arc::new(Mutex::new(MockVehicleManager {\n                subscribed: Arc::new(AtomicBool::new(false)),\n                unsubscribed: Arc::new(AtomicBool::new(false)),\n            })),\n            launched: Arc::new(AtomicBool::new(false)),\n            removed: Arc::new(AtomicBool::new(false)),\n        };\n\n        manager.process_grpc_requests().await.unwrap();\n\n        assert!(\n            !manager\n                .vehicle_manager\n                .lock()\n                .await\n                .subscribed\n                .load(Ordering::SeqCst),\n            \"No subscription should happen\"\n        );\n        assert!(\n            !manager\n                .vehicle_manager\n                .lock()\n                .await\n                .unsubscribed\n                .load(Ordering::SeqCst),\n            \"No unsubscription should happen\"\n        );\n        assert!(\n            !manager.launched.load(Ordering::SeqCst),\n            \"No scenario should be launched\"\n        );\n        assert!(\n            !manager.removed.load(Ordering::SeqCst),\n            \"No scenario should be removed\"\n        );\n    }\n\n    // Test case: Verify behavior when the DDS data channel is closed\n    #[tokio::test]\n    async fn test_dds_data_channel_closed() {\n        let (_, rx) = mpsc::channel(1);\n        let rx_dds = Arc::new(Mutex::new(rx));\n\n        let filters = Arc::new(Mutex::new(vec![]));\n\n        let manager = DummyFilterManager {\n            rx_dds,\n            filters: Arc::clone(\u0026filters),\n        };\n\n        manager.process_dds_data().await.unwrap();\n\n        let filters = manager.filters.lock().await;\n        assert!(\n            filters.is_empty(),\n            \"No filters should be called as channel is closed\"\n        );\n    }\n\n    // Test case: Handle multiple gRPC requests and validate correct actions\n    #[tokio::test]\n    async fn test_grpc_multiple_requests() {\n        let (tx, rx) = mpsc::channel(10);\n        let manager = DummyManager {\n            rx_grpc: Arc::new(Mutex::new(rx)),\n            vehicle_manager: Arc::new(Mutex::new(MockVehicleManager {\n                subscribed: Arc::new(AtomicBool::new(false)),\n                unsubscribed: Arc::new(AtomicBool::new(false)),\n            })),\n            launched: Arc::new(AtomicBool::new(false)),\n            removed: Arc::new(AtomicBool::new(false)),\n        };\n\n        let subscribed = Arc::clone(\u0026manager.vehicle_manager.lock().await.subscribed);\n        let unsubscribed = Arc::clone(\u0026manager.vehicle_manager.lock().await.unsubscribed);\n        let launched = Arc::clone(\u0026manager.launched);\n        let removed = Arc::clone(\u0026manager.removed);\n\n        let scenario1 = DummyScenario {\n            name: \"Scenario1\".into(),\n            has_conditions: true,\n        };\n        let scenario2 = DummyScenario {\n            name: \"Scenario2\".into(),\n            has_conditions: false,\n        };\n\n        tx.send(DummyScenarioParam {\n            action: 0,\n            scenario: scenario1,\n        })\n        .await\n        .unwrap();\n        tx.send(DummyScenarioParam {\n            action: 1,\n            scenario: scenario2,\n        })\n        .await\n        .unwrap();\n        drop(tx);\n\n        manager.process_grpc_requests().await.unwrap();\n\n        assert!(\n            subscribed.load(Ordering::SeqCst),\n            \"Vehicle should be subscribed for Scenario1\"\n        );\n        assert!(\n            launched.load(Ordering::SeqCst),\n            \"Scenario1 filter should be launched\"\n        );\n        assert!(\n            unsubscribed.load(Ordering::SeqCst),\n            \"Vehicle should be unsubscribed for Scenario2\"\n        );\n        assert!(\n            removed.load(Ordering::SeqCst),\n            \"Scenario2 filter should be removed\"\n        );\n    }\n\n    // Test case: Validate processing DDS data through multiple active filters\n    #[tokio::test]\n    async fn test_dds_data_multiple_filters() {\n        let (tx, rx) = mpsc::channel(10);\n        let rx_dds = Arc::new(Mutex::new(rx));\n\n        let test_data = DummyDdsData {\n            name: \"test_topic\".to_string(),\n            value: \"42\".to_string(),\n        };\n\n        tx.send(test_data.clone()).await.unwrap();\n        drop(tx);\n\n        let called_filter1 = Arc::new(AtomicBool::new(false));\n        let called_filter2 = Arc::new(AtomicBool::new(false));\n\n        let filter1 = MockFilter {\n            name: \"Filter1\".to_string(),\n            called: Arc::clone(\u0026called_filter1),\n            should_be_active: true,\n        };\n\n        let filter2 = MockFilter {\n            name: \"Filter2\".to_string(),\n            called: Arc::clone(\u0026called_filter2),\n            should_be_active: true,\n        };\n\n        let filters = Arc::new(Mutex::new(vec![filter1, filter2]));\n\n        let manager = DummyFilterManager {\n            rx_dds,\n            filters: Arc::clone(\u0026filters),\n        };\n\n        manager.process_dds_data().await.unwrap();\n\n        assert!(\n            called_filter1.load(Ordering::SeqCst),\n            \"Filter1 should have been called\"\n        );\n        assert!(\n            called_filter2.load(Ordering::SeqCst),\n            \"Filter2 should have been called\"\n        );\n    }\n\n    // Test case: Ensure inactive filters do not process DDS data\n    #[tokio::test]\n    async fn test_dds_data_no_active_filters() {\n        let (tx, rx) = mpsc::channel(10);\n        let rx_dds = Arc::new(Mutex::new(rx));\n\n        let test_data = DummyDdsData {\n            name: \"test_topic\".to_string(),\n            value: \"42\".to_string(),\n        };\n\n        tx.send(test_data.clone()).await.unwrap();\n        drop(tx);\n\n        let called_filter = Arc::new(AtomicBool::new(false));\n\n        let filter = MockFilter {\n            name: \"InactiveFilter\".to_string(),\n            called: Arc::clone(\u0026called_filter),\n            should_be_active: false,\n        };\n\n        let filters = Arc::new(Mutex::new(vec![filter]));\n\n        let manager = DummyFilterManager {\n            rx_dds,\n            filters: Arc::clone(\u0026filters),\n        };\n\n        manager.process_dds_data().await.unwrap();\n\n        assert!(\n            !called_filter.load(Ordering::SeqCst),\n            \"Inactive filter should NOT be called\"\n        );\n    }\n}\n","traces":[{"line":50,"address":[3082304,3082339,3084421,3083379,3082512,3082888],"length":1,"stats":{"Line":40}},{"line":51,"address":[5863167,5863295],"length":1,"stats":{"Line":21}},{"line":52,"address":[3824152,3824242],"length":1,"stats":{"Line":21}},{"line":55,"address":[4026043,4026254,4026313,4026418],"length":1,"stats":{"Line":21}},{"line":56,"address":[3083180,3083288],"length":1,"stats":{"Line":0}},{"line":61,"address":[4124395,4124506],"length":1,"stats":{"Line":22}},{"line":62,"address":[5864239,5864333],"length":1,"stats":{"Line":22}},{"line":63,"address":[4027246,4027186],"length":1,"stats":{"Line":22}},{"line":64,"address":[4751633,4751677],"length":1,"stats":{"Line":22}},{"line":65,"address":[3825613,3825435],"length":1,"stats":{"Line":22}},{"line":77,"address":[3514816,3514824],"length":1,"stats":{"Line":14}},{"line":78,"address":[5865427,5865612],"length":1,"stats":{"Line":7}},{"line":80,"address":[3793233,3793113,3793894,3792910,3793055],"length":1,"stats":{"Line":11}},{"line":81,"address":[5866248,5866425,5867252,5866370],"length":1,"stats":{"Line":14}},{"line":82,"address":[3212031,3209826,3209605],"length":1,"stats":{"Line":9}},{"line":83,"address":[3828573,3828652],"length":1,"stats":{"Line":6}},{"line":84,"address":[4128209,4128282,4128352],"length":1,"stats":{"Line":14}},{"line":87,"address":[3797440,3797456],"length":1,"stats":{"Line":2}},{"line":89,"address":[3210471,3210611,3210541],"length":1,"stats":{"Line":14}},{"line":92,"address":[3830864,3830880],"length":1,"stats":{"Line":2}},{"line":94,"address":[4029328,4028323,4031226,4031347],"length":1,"stats":{"Line":9}},{"line":95,"address":[4032000,4031577,4031816,4031754,4032082],"length":1,"stats":{"Line":31}},{"line":96,"address":[4031648],"length":1,"stats":{"Line":5}},{"line":97,"address":[2819254],"length":1,"stats":{"Line":16}},{"line":99,"address":[3088760,3088649],"length":1,"stats":{"Line":0}},{"line":101,"address":[2753247,2755801,2755924,2756046,2751949,2752976,2752946],"length":1,"stats":{"Line":19}},{"line":103,"address":[3209656],"length":1,"stats":{"Line":2}},{"line":113,"address":[3814152,3814144],"length":1,"stats":{"Line":15}},{"line":115,"address":[4033268,4033046],"length":1,"stats":{"Line":7}},{"line":119,"address":[3799196,3797879,3797734,3799112,3797939],"length":1,"stats":{"Line":13}},{"line":122,"address":[4757287,4757500,4758948,4759439,4758867,4759036],"length":1,"stats":{"Line":22}},{"line":123,"address":[3800068],"length":1,"stats":{"Line":3}},{"line":125,"address":[2758835,2759034],"length":1,"stats":{"Line":5}},{"line":131,"address":[3678165],"length":1,"stats":{"Line":5}},{"line":132,"address":[5871372,5871285,5873400],"length":1,"stats":{"Line":7}},{"line":133,"address":[3798688,3798858,3800984],"length":1,"stats":{"Line":4}},{"line":135,"address":[4233811],"length":1,"stats":{"Line":9}},{"line":136,"address":[3831922,3831804],"length":1,"stats":{"Line":0}},{"line":146,"address":[4133061],"length":1,"stats":{"Line":0}},{"line":152,"address":[4133129],"length":1,"stats":{"Line":0}},{"line":162,"address":[6571800,6571792],"length":1,"stats":{"Line":17}},{"line":163,"address":[4134217,4135391],"length":1,"stats":{"Line":5}},{"line":166,"address":[3737730],"length":1,"stats":{"Line":15}},{"line":167,"address":[4134273,4135839,4135932,4136036,4134512],"length":1,"stats":{"Line":18}},{"line":170,"address":[4136396],"length":1,"stats":{"Line":4}},{"line":171,"address":[4136436],"length":1,"stats":{"Line":3}},{"line":172,"address":[4136483,4136644],"length":1,"stats":{"Line":6}},{"line":173,"address":[3837225],"length":1,"stats":{"Line":3}},{"line":177,"address":[4136944,4136757,4136874],"length":1,"stats":{"Line":6}},{"line":181,"address":[3099856,3099872],"length":1,"stats":{"Line":2}},{"line":183,"address":[3219063,3219136,3219206],"length":1,"stats":{"Line":6}},{"line":187,"address":[3841392,3841408],"length":1,"stats":{"Line":2}},{"line":189,"address":[2760038,2762957,2760281,2763069],"length":1,"stats":{"Line":4}},{"line":190,"address":[3097224,3096896,3096719,3096958,3097142],"length":1,"stats":{"Line":10}},{"line":191,"address":[3219766],"length":1,"stats":{"Line":2}},{"line":192,"address":[4764259,4764299,4761050,4764304,4760795,4764498],"length":1,"stats":{"Line":8}},{"line":194,"address":[3220382,3220271],"length":1,"stats":{"Line":0}},{"line":196,"address":[3605830],"length":1,"stats":{"Line":8}},{"line":201,"address":[3605855],"length":1,"stats":{"Line":3}},{"line":202,"address":[3807023,3806777,3806969,3807207,3807289],"length":1,"stats":{"Line":5}},{"line":203,"address":[4139723],"length":1,"stats":{"Line":1}},{"line":204,"address":[3093705,3098884,3098949,3098944,3093386,3099151],"length":1,"stats":{"Line":4}},{"line":206,"address":[4766468,4766579],"length":1,"stats":{"Line":0}},{"line":208,"address":[3216898,3217161,3222489,3217039,3222628,3222682],"length":1,"stats":{"Line":4}},{"line":209,"address":[4043189,4037726,4043129,4037280,4037657,4043226,4036911,4037500,4037246,4037474],"length":1,"stats":{"Line":5}},{"line":216,"address":[4039029],"length":1,"stats":{"Line":1}},{"line":222,"address":[3218546],"length":1,"stats":{"Line":2}},{"line":231,"address":[3514912,3514929],"length":1,"stats":{"Line":14}},{"line":233,"address":[4141242,4141101],"length":1,"stats":{"Line":7}},{"line":236,"address":[5881019,5880941],"length":1,"stats":{"Line":7}},{"line":237,"address":[2768731,2768221,2768054,2767936,2766862,2766775,2767976,2768679],"length":1,"stats":{"Line":14}},{"line":238,"address":[3224637,3224757,3224693,3225156,3224875],"length":1,"stats":{"Line":12}},{"line":239,"address":[4045733,4045657],"length":1,"stats":{"Line":0}},{"line":244,"address":[4044035,4043957],"length":1,"stats":{"Line":9}},{"line":245,"address":[5883489,5883306,5881227,5883963,5884019,5883224,5883184,5881318],"length":1,"stats":{"Line":19}},{"line":246,"address":[4769709,4769927,4770196,4769829,4769761],"length":1,"stats":{"Line":17}},{"line":247,"address":[5883769,5883845],"length":1,"stats":{"Line":0}},{"line":252,"address":[3100997,3101157,3100743,3100177,3100653,3100917],"length":1,"stats":{"Line":16}},{"line":254,"address":[4142332],"length":1,"stats":{"Line":0}},{"line":256,"address":[4044889],"length":1,"stats":{"Line":0}},{"line":269,"address":[4048646,4047216,4046928,4048191,4046966,4047631],"length":1,"stats":{"Line":4}},{"line":270,"address":[3845185,3845322],"length":1,"stats":{"Line":2}},{"line":271,"address":[3103887],"length":1,"stats":{"Line":1}},{"line":272,"address":[4770811,4771064,4771209],"length":1,"stats":{"Line":1}},{"line":273,"address":[3227350,3227537,3227599,3227884,3227994,3228271,3227806],"length":1,"stats":{"Line":5}},{"line":274,"address":[3812573],"length":1,"stats":{"Line":1}},{"line":275,"address":[2658838],"length":1,"stats":{"Line":3}},{"line":277,"address":[4048552],"length":1,"stats":{"Line":1}},{"line":292,"address":[3872688,3872723],"length":1,"stats":{"Line":4}},{"line":293,"address":[4049372,4049235],"length":1,"stats":{"Line":2}},{"line":294,"address":[5886630,5886791,5886477],"length":1,"stats":{"Line":1}},{"line":295,"address":[3847828,3848301,3848411,3848729,3848016,3848223,3847962],"length":1,"stats":{"Line":5}},{"line":296,"address":[3106411],"length":1,"stats":{"Line":1}},{"line":297,"address":[5887173,5887233,5886495,5887270,5887449,5887563],"length":1,"stats":{"Line":3}},{"line":299,"address":[5887625],"length":1,"stats":{"Line":1}},{"line":314,"address":[3515171,3515136],"length":1,"stats":{"Line":10}},{"line":316,"address":[3107698,3107889],"length":1,"stats":{"Line":4}},{"line":317,"address":[4149164],"length":1,"stats":{"Line":3}},{"line":318,"address":[3682447],"length":1,"stats":{"Line":2}},{"line":319,"address":[3509297,3509158],"length":1,"stats":{"Line":14}},{"line":320,"address":[3817651],"length":1,"stats":{"Line":2}},{"line":324,"address":[3849311,3851159,3849514],"length":1,"stats":{"Line":1}},{"line":325,"address":[4150870,4150943],"length":1,"stats":{"Line":2}},{"line":327,"address":[4776877,4776801],"length":1,"stats":{"Line":2}},{"line":332,"address":[6435418],"length":1,"stats":{"Line":1}},{"line":333,"address":[5891362,5891435,5891528],"length":1,"stats":{"Line":3}},{"line":335,"address":[4778208,4777601,4778233],"length":1,"stats":{"Line":3}},{"line":337,"address":[3110897,3111148],"length":1,"stats":{"Line":2}},{"line":341,"address":[4054721],"length":1,"stats":{"Line":1}},{"line":343,"address":[2776825,2776874],"length":1,"stats":{"Line":2}},{"line":345,"address":[4777796],"length":1,"stats":{"Line":1}},{"line":359,"address":[3441888,3441896],"length":1,"stats":{"Line":4}},{"line":360,"address":[4055297,4055178],"length":1,"stats":{"Line":2}},{"line":362,"address":[3111867],"length":1,"stats":{"Line":1}},{"line":363,"address":[3683105],"length":1,"stats":{"Line":2}},{"line":364,"address":[3235481,3235318,3235391],"length":1,"stats":{"Line":3}},{"line":366,"address":[5893181,5893568,5893593],"length":1,"stats":{"Line":1}},{"line":367,"address":[4153552],"length":1,"stats":{"Line":1}},{"line":368,"address":[4056162,4056098],"length":1,"stats":{"Line":0}},{"line":370,"address":[4153610],"length":1,"stats":{"Line":1}},{"line":379,"address":[3872899,3872896],"length":1,"stats":{"Line":15}},{"line":380,"address":[3236153,3236250,3236022,3236088],"length":1,"stats":{"Line":12}},{"line":381,"address":[3822064,3821751,3821853,3822092],"length":1,"stats":{"Line":12}},{"line":383,"address":[2779599],"length":1,"stats":{"Line":3}}],"covered":112,"coverable":124},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","tests","integration_test.rs"],"content":"#[cfg(test)]\nmod tests {\n    use common::Result;\n    use vehicle::VehicleManager;\n    use std::env;\n\n    // Ensure logger is initialized\n    fn init_logger() {\n        let _ = env_logger::builder().is_test(true).try_init();\n    }\n\n    #[tokio::test]\n    async fn test_vehicle_manager_init() -\u003e Result\u003c()\u003e {\n        init_logger();\n        let mut manager = VehicleManager::new();\n        manager.init().await?;\n        // Check that the domain id is set (should be 100 by default)\n        assert_eq!(manager.get_sender().clone().capacity(), 100); // Example check\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_subscribe_unsubscribe_topic() -\u003e Result\u003c()\u003e {\n        init_logger();\n        let mut manager = VehicleManager::new();\n        manager.init().await?;\n        // Subscribe to a dummy topic with a dummy data type\n        manager.subscribe_topic(\"TestTopic\".to_string(), \"TestType\".to_string()).await?;\n        // Unsubscribe afterwards\n        manager.unsubscribe_topic(\"TestTopic\".to_string()).await?;\n        Ok(())\n    }\n\n    #[tokio::test]\n    async fn test_subscribe_using_generated_rs() -\u003e Result\u003c()\u003e {\n        init_logger();\n        let mut manager = VehicleManager::new();\n        manager.init().await?;\n        // List available DDS types from the generated file\n        let generated_types = manager.list_available_types();\n        println!(\"Available generated DDS types: {:?}\", generated_types);\n        \n        if generated_types.is_empty() {\n            println!(\"No generated DDS types available. Skipping typed subscription test.\");\n            return Ok(());\n        }\n        \n        // Use the first available type for testing\n        let use_type = generated_types[0].clone();\n        // Attempt to subscribe using the generated type\n        manager.create_typed_listener(\"GeneratedTestTopic\".to_string(), use_type).await?;\n        println!(\"Successfully subscribed using generated type.\");\n        // Clean up by unsubscribing afterwards\n        manager.unsubscribe_topic(\"GeneratedTestTopic\".to_string()).await?;\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","vehicle","dds","listener.rs"],"content":"use crate::vehicle::dds::DdsData;\nuse common::Result;\nuse std::collections::HashMap;\n\n#[async_trait]\npub trait DdsTopicListener: Send + Sync {\n    fn is_running(\u0026self) -\u003e bool;\n    async fn start(\u0026mut self) -\u003e Result\u003c()\u003e;\n    async fn stop(\u0026mut self) -\u003e Result\u003c()\u003e;\n    fn get_topic_name(\u0026self) -\u003e \u0026str;\n    fn is_topic(\u0026self, topic_name: \u0026str) -\u003e bool;\n}\n\nuse dust_dds::{\n    domain::domain_participant::DomainParticipant,\n    domain::domain_participant_factory::{DomainId, DomainParticipantFactory},\n    infrastructure::{\n        qos::QosKind,\n        qos_policy::{DataRepresentationQosPolicy, XCDR2_DATA_REPRESENTATION},\n        status::{StatusKind, NO_STATUS},\n        time::Duration,\n    },\n    subscription::data_reader::DataReader,\n    subscription::sample_info::{ANY_INSTANCE_STATE, ANY_SAMPLE_STATE, ANY_VIEW_STATE},\n    subscription::subscriber::Subscriber,\n    topic_definition::type_support::{DdsDeserialize, DdsType, TypeSupport},\n};\n\nuse tokio::sync::mpsc::Sender;\nuse tokio::task::JoinHandle;\nuse tokio::time;\n\nuse anyhow::{anyhow, Result as AnyhowResult};\nuse serde_json::{json, Map, Value};\n\nuse async_trait::async_trait;\nuse clap::Parser;\nuse common;\nuse log::{debug, error, info, warn};\nuse once_cell::sync::Lazy;\nuse serde::de::DeserializeOwned;\nuse serde::Serialize;\n\n/// DDS topic listener\n///\n/// Listens to a specific DDS topic and forwards data to the filter system.\npub struct TopicListener {\n    /// Name of the topic\n    pub topic_name: String,\n    /// Data type of the topic\n    data_type_name: String,\n    /// Channel sender for data\n    tx: Sender\u003cDdsData\u003e,\n    /// Domain ID for DDS\n    domain_id: i32,\n    /// Handle to the listener task\n    listener_task: Option\u003cJoinHandle\u003c()\u003e\u003e,\n    /// Flag indicating if the listener is running\n    is_running: bool,\n}\n\nimpl TopicListener {\n    /// Creates a new topic listener\n    ///\n    /// # Arguments\n    ///\n    /// * `topic_name` - Name of the DDS topic\n    /// * `data_type_name` - Data type name of the topic\n    /// * `tx` - Sender for data\n    /// * `domain_id` - DDS domain ID\n    ///\n    /// # Returns\n    ///\n    /// A new TopicListener instance\n    pub fn new(\n        topic_name: String,\n        data_type_name: String,\n        tx: Sender\u003cDdsData\u003e,\n        domain_id: i32,\n    ) -\u003e Self {\n        Self {\n            topic_name,\n            data_type_name,\n            tx,\n            domain_id,\n            listener_task: None,\n            is_running: false,\n        }\n    }\n\n    /// 파일 경로에서 IDL 타입을 추출하여 적절한 리스너 생성\n    pub fn create_idl_listener(\n        topic_name: String,\n        type_name: String,\n        tx: Sender\u003cDdsData\u003e,\n        domain_id: i32,\n    ) -\u003e Box\u003cdyn DdsTopicListener\u003e {\n        // 일반 토픽 리스너 생성\n        Box::new(TopicListener::new(topic_name, type_name, tx, domain_id))\n    }\n}\n\n// Helper function to create an IDL listener\npub fn create_idl_listener(\n    topic_name: String,\n    type_name: String,\n    tx: Sender\u003cDdsData\u003e,\n    domain_id: i32,\n) -\u003e Box\u003cdyn DdsTopicListener\u003e {\n    TopicListener::create_idl_listener(topic_name, type_name, tx, domain_id)\n}\n\n#[async_trait]\nimpl DdsTopicListener for TopicListener {\n    fn is_running(\u0026self) -\u003e bool {\n        return self.is_running;\n    }\n\n    async fn start(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if self.is_running {\n            return Ok(());\n        }\n\n        // Clone values to move into the task\n        let topic_name = self.topic_name.clone();\n        let data_type_name = self.data_type_name.clone();\n        let tx = self.tx.clone();\n        let domain_id = self.domain_id;\n\n        // Spawn the listener task\n        let task = tokio::spawn(async move {\n            if let Err(e) = Self::listener_loop(topic_name, data_type_name, tx, domain_id).await {\n                error!(\"Error in listener loop: {:?}\", e);\n            }\n        });\n\n        // Store the task handle and update state\n        self.listener_task = Some(task);\n        self.is_running = true;\n        Ok(())\n    }\n\n    async fn stop(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if self.is_running {\n            if let Some(task) = self.listener_task.take() {\n                task.abort();\n            }\n            self.is_running = false;\n        }\n        Ok(())\n    }\n\n    fn get_topic_name(\u0026self) -\u003e \u0026str {\n        \u0026self.topic_name\n    }\n\n    fn is_topic(\u0026self, topic_name: \u0026str) -\u003e bool {\n        self.topic_name == topic_name\n    }\n}\n\nimpl TopicListener {\n    /// Main listener loop for processing DDS data\n    async fn listener_loop(\n        topic_name: String,\n        data_type_name: String,\n        tx: Sender\u003cDdsData\u003e,\n        domain_id: i32,\n    ) -\u003e Result\u003c()\u003e {\n        // 도메인 참여자 생성\n        info!(\"Generic listener started for topic '{}'\", topic_name);\n\n        let domain_participant_factory = DomainParticipantFactory::get_instance();\n        let participant = domain_participant_factory\n            .create_participant(domain_id, QosKind::Default, None, NO_STATUS)\n            .map_err(|e| anyhow!(\"Failed to create domain participant: {:?}\", e))?;\n\n        // 구독자 생성\n        let subscriber = participant\n            .create_subscriber(QosKind::Default, None, NO_STATUS)\n            .map_err(|e| anyhow!(\"Failed to create subscriber: {:?}\", e))?;\n\n        // IDL 타입 정보를 유동적으로 처리\n        // 토픽 메타데이터에 따라 데이터 처리를 다르게 함\n        info!(\n            \"Setting up listener for topic {} of type {}\",\n            topic_name, data_type_name\n        );\n\n        // 메시지 수신 루프\n        let mut interval = time::interval(time::Duration::from_millis(100));\n\n        loop {\n            interval.tick().await;\n\n            // 수신된 DDS 메시지를 파싱하여 DdsData 형태로 변환\n            let dds_data = DdsData {\n                name: data_type_name.clone(),\n                value: \"{}\".to_string(), // 실제 값은 메시지 수신 시 채워짐\n                fields: HashMap::new(),\n            };\n\n            // 데이터 전송 채널이 닫히면 루프 종료\n            if tx.send(dds_data).await.is_err() {\n                warn!(\"Channel closed, stopping listener for {}\", topic_name);\n                break;\n            }\n        }\n\n        Ok(())\n    }\n}\n\n/// 타입별 DDS 토픽 리스너 베이스 구현\n///\n/// TypeSupport 특성으로 다양한 DDS 데이터 타입 처리\npub struct GenericTopicListener\u003c\n    T: TypeSupport\n        + Default\n        + DeserializeOwned\n        + Serialize\n        + Send\n        + Sync\n        + for\u003c'de\u003e DdsDeserialize\u003c'de\u003e\n        + 'static,\n\u003e {\n    /// Topic name\n    topic_name: String,\n    /// Data type name\n    data_type_name: String,\n    /// Data transmission channel\n    tx: Sender\u003cDdsData\u003e,\n    /// DDS domain ID\n    domain_id: i32,\n    /// Listener task handle\n    listener_task: Option\u003cJoinHandle\u003c()\u003e\u003e,\n    /// Running state\n    is_running: bool,\n    /// Type marker (for generic type specification)\n    _marker: std::marker::PhantomData\u003cT\u003e,\n}\n\nimpl\u003c\n        T: TypeSupport\n            + Default\n            + DeserializeOwned\n            + Serialize\n            + Send\n            + Sync\n            + for\u003c'de\u003e DdsDeserialize\u003c'de\u003e\n            + 'static,\n    \u003e GenericTopicListener\u003cT\u003e\n{\n    /// 새 타입별 리스너 생성\n    pub fn new(\n        topic_name: String,\n        data_type_name: String,\n        tx: Sender\u003cDdsData\u003e,\n        domain_id: i32,\n    ) -\u003e Self {\n        Self {\n            topic_name,\n            data_type_name,\n            tx,\n            domain_id,\n            listener_task: None,\n            is_running: false,\n            _marker: std::marker::PhantomData,\n        }\n    }\n\n    /// 타입별 리스너 루프\n    async fn typed_listener_loop(\n        topic_name: String,\n        data_type_name: String,\n        tx: Sender\u003cDdsData\u003e,\n        domain_id: i32,\n    ) -\u003e Result\u003c()\u003e {\n        // 도메인 참여자 생성\n        let domain_participant_factory = DomainParticipantFactory::get_instance();\n        let participant = domain_participant_factory\n            .create_participant(domain_id, QosKind::Default, None, NO_STATUS)\n            .map_err(|e| anyhow!(\"Failed to create domain participant: {:?}\", e))?;\n\n        // 구독자 생성\n        let subscriber = participant\n            .create_subscriber(QosKind::Default, None, NO_STATUS)\n            .map_err(|e| anyhow!(\"Failed to create subscriber: {:?}\", e))?;\n        // 토픽 생성\n        let topic = participant\n            .create_topic::\u003cT\u003e(\u0026topic_name, \u0026topic_name, QosKind::Default, None, NO_STATUS)\n            .map_err(|e| anyhow!(\"Failed to create topic: {:?}\", e))?;\n\n        // 데이터 리더 생성\n        let data_reader = subscriber\n            .create_datareader::\u003cT\u003e(\u0026topic, QosKind::Default, None, NO_STATUS)\n            .map_err(|e| anyhow!(\"Failed to create data reader: {:?}\", e))?;\n\n        println!(\n            \"Successfully created data reader for topic '{}'\",\n            topic_name\n        );\n\n        // 메시지 수신 루프\n        let mut interval = time::interval(time::Duration::from_millis(100));\n\n        loop {\n            interval.tick().await;\n\n            // 새 샘플 확인\n            let result = data_reader\n                .take(1, ANY_SAMPLE_STATE, ANY_VIEW_STATE, ANY_INSTANCE_STATE)\n                .map_err(|e| anyhow!(\"Failed to read samples: {:?}\", e));\n\n            match result {\n                Ok(samples) =\u003e {\n                    for sample in samples {\n                        if let Ok(data) = sample.data() {\n                            // 데이터를 JSON으로 직렬화\n                            let json_value = serde_json::to_string(\u0026data)\n                                .map_err(|e| anyhow!(\"Failed to serialize data: {:?}\", e))?;\n\n                            // json_value를 key, value로 파싱해서 fields에 추가\n                            let mut fields = HashMap::new();\n                            if let Ok(map) =\n                                serde_json::from_str::\u003cserde_json::Map\u003cString, Value\u003e\u003e(\u0026json_value)\n                            {\n                                for (k, v) in map {\n                                    fields.insert(k, v.to_string());\n                                }\n                            }\n\n                            // DdsData 객체 생성 및 전송\n                            let dds_data = DdsData {\n                                name: data_type_name.clone(),\n                                value: json_value,\n                                fields,\n                            };\n\n                            // Send data through channel\n                            if tx.send(dds_data).await.is_err() {\n                                warn!(\"Channel closed, stopping listener for {}\", topic_name);\n                                return Ok(());\n                            }\n                        }\n                    }\n                }\n                Err(e) =\u003e {\n                    debug!(\"No new samples available: {:?}\", e);\n                }\n            }\n        }\n    }\n}\n\n#[async_trait]\nimpl\u003c\n        T: TypeSupport\n            + Default\n            + DeserializeOwned\n            + Serialize\n            + Send\n            + Sync\n            + for\u003c'de\u003e DdsDeserialize\u003c'de\u003e\n            + 'static,\n    \u003e DdsTopicListener for GenericTopicListener\u003cT\u003e\n{\n    fn is_running(\u0026self) -\u003e bool {\n        self.is_running\n    }\n\n    async fn start(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if self.is_running {\n            return Ok(());\n        }\n\n        let topic_name = self.topic_name.clone();\n        let data_type_name = self.data_type_name.clone();\n        let tx = self.tx.clone();\n        let domain_id = self.domain_id;\n\n        // 리스너 태스크 시작\n        let task = tokio::spawn(async move {\n            if let Err(e) =\n                Self::typed_listener_loop(topic_name.clone(), data_type_name, tx, domain_id).await\n            {\n                error!(\"Error in typed listener loop for {}: {:?}\", topic_name, e);\n            }\n        });\n\n        self.listener_task = Some(task);\n        self.is_running = true;\n        Ok(())\n    }\n\n    async fn stop(\u0026mut self) -\u003e Result\u003c()\u003e {\n        if self.is_running {\n            if let Some(task) = self.listener_task.take() {\n                task.abort();\n            }\n            self.is_running = false;\n        }\n        Ok(())\n    }\n\n    fn get_topic_name(\u0026self) -\u003e \u0026str {\n        \u0026self.topic_name\n    }\n\n    fn is_topic(\u0026self, topic_name: \u0026str) -\u003e bool {\n        self.topic_name == topic_name\n    }\n}\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::vehicle::dds::listener::GenericTopicListener;\n    use crate::vehicle::dds::listener::{DdsTopicListener, TopicListener};\n    use crate::vehicle::dds::DdsData;\n    use dust_dds_derive::DdsType;\n    use serde::{Deserialize, Serialize};\n    use std::collections::HashMap;\n    use std::time::Duration;\n    use tokio::sync::mpsc;\n    // Temporarily shadow the conflicting `Result` alias\n    type Result\u003cT, E\u003e = std::result::Result\u003cT, E\u003e;\n\n    #[derive(Debug, Clone, PartialEq, Serialize, Deserialize, Default, DdsType)]\n    pub struct DummyType {\n        pub id: i32,\n        pub label: String,\n    }\n    #[derive(Default, Debug, Clone, Deserialize, Serialize, PartialEq, DdsType)]\n    pub struct ADASObstacleDetectionIsWarning {\n        pub value: bool,\n    }\n\n    #[tokio::test]\n    async fn test_generic_listener_start_stop() {\n        let (tx, mut rx) = mpsc::channel::\u003cDdsData\u003e(1);\n        let mut listener = GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::new(\n            \"ADASObstacleDetectionIsWarning\".to_string(),\n            \"ADASObstacleDetectionIsWarning\".to_string(),\n            tx,\n            100,\n        );\n\n        assert!(!listener.is_running());\n        listener.start().await.unwrap();\n        assert!(listener.is_running());\n\n        tokio::time::sleep(Duration::from_millis(2000)).await;\n        drop(rx);\n        listener.stop().await.unwrap();\n        assert!(!listener.is_running());\n    }\n    #[tokio::test]\n    async fn test_topic_listener_creation() {\n        let (tx, _rx) = mpsc::channel(10);\n        let listener = TopicListener::new(\"test_topic\".into(), \"test_type\".into(), tx, 42);\n\n        assert_eq!(listener.get_topic_name(), \"test_topic\");\n        assert!(!listener.is_running());\n        assert!(listener.is_topic(\"test_topic\"));\n        assert!(!listener.is_topic(\"other_topic\"));\n    }\n\n    #[tokio::test]\n    async fn test_topic_listener_start_and_stop() {\n        let (tx, _rx) = mpsc::channel(10);\n        let mut listener = TopicListener::new(\"start_stop\".into(), \"test_type\".into(), tx, 0);\n\n        assert!(!listener.is_running());\n        listener.start().await.unwrap();\n        assert!(listener.is_running());\n\n        listener.stop().await.unwrap();\n        assert!(!listener.is_running());\n    }\n\n    #[tokio::test]\n    async fn test_topic_listener_double_start_idempotent() {\n        let (tx, _rx) = mpsc::channel(10);\n        let mut listener = TopicListener::new(\"double_start\".into(), \"test_type\".into(), tx, 0);\n\n        assert!(!listener.is_running());\n        listener.start().await.unwrap();\n        assert!(listener.is_running());\n\n        // Calling start again should not panic or restart\n        listener.start().await.unwrap();\n        assert!(listener.is_running());\n\n        listener.stop().await.unwrap();\n    }\n    #[tokio::test]\n    async fn test_typed_listener_loop_covers_loop_and_info() {\n        use tokio::sync::mpsc;\n        use tokio::time::{timeout, Duration};\n        let (tx, rx) = mpsc::channel::\u003cDdsData\u003e(1);\n        drop(rx); // This will cause tx.send() to fail, which breaks the loop\n\n        // Call directly (NOT via tokio::spawn)\n        let result = timeout(Duration::from_secs(2), async {\n            GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::typed_listener_loop(\n                \"ADASObstacleDetectionIsWarning\".to_string(),\n                \"ADASObstacleDetectionIsWarning\".to_string(),\n                tx,\n                100,\n            )\n            .await\n        })\n        .await;\n\n        //assert!(result.is_ok(), \"Loop did not complete within timeout\");\n    }\n\n    #[tokio::test]\n    async fn test_topic_listener_double_stop_idempotent() {\n        let (tx, _rx) = mpsc::channel(10);\n        let mut listener = TopicListener::new(\"double_stop\".into(), \"test_type\".into(), tx, 0);\n\n        listener.start().await.unwrap();\n        assert!(listener.is_running());\n\n        listener.stop().await.unwrap();\n        assert!(!listener.is_running());\n\n        // Calling stop again should be safe\n        listener.stop().await.unwrap();\n        assert!(!listener.is_running());\n    }\n\n    #[tokio::test]\n    async fn test_is_topic_behavior() {\n        let (tx, _rx) = mpsc::channel(10);\n        let listener = TopicListener::new(\"match_topic\".into(), \"type\".into(), tx, 0);\n\n        assert!(listener.is_topic(\"match_topic\"));\n        assert!(!listener.is_topic(\"different_topic\"));\n    }\n\n    #[tokio::test]\n    async fn test_topic_listener_channel_closure_cleanup() {\n        let (tx, rx) = mpsc::channel(1);\n        let mut listener = TopicListener::new(\"channel_test\".into(), \"type\".into(), tx, 0);\n\n        listener.start().await.unwrap();\n        drop(rx); // Close the receiver end\n\n        // Wait a bit for task to potentially exit\n        tokio::time::sleep(Duration::from_millis(200)).await;\n\n        // Listener still \"thinks\" it's running until explicitly stopped\n        assert!(listener.is_running());\n\n        listener.stop().await.unwrap();\n        assert!(!listener.is_running());\n    }\n\n    #[tokio::test]\n    async fn test_topic_listener_create_idl_listener() {\n        let (tx, _rx) = mpsc::channel(5);\n        let topic_name = \"idl_topic\".to_string();\n        let type_name = \"idl_type\".to_string();\n        let domain_id = 1;\n\n        let listener = TopicListener::create_idl_listener(\n            topic_name.clone(),\n            type_name.clone(),\n            tx,\n            domain_id,\n        );\n\n        assert!(listener.is_topic(\u0026topic_name));\n        assert_eq!(listener.get_topic_name(), topic_name);\n    }\n\n    #[tokio::test]\n    async fn test_topic_listener_create_idl_wrapper_fn() {\n        let (tx, _rx) = mpsc::channel(5);\n        let listener =\n            super::super::create_idl_listener(\"wrapper_topic\".into(), \"wrapper_type\".into(), tx, 2);\n        assert!(listener.is_topic(\"wrapper_topic\"));\n    }\n    #[tokio::test]\n    async fn test_generic_listener_basic_lifecycle() {\n        let (tx, mut _rx) = mpsc::channel::\u003cDdsData\u003e(5);\n        let mut listener = GenericTopicListener::\u003cDummyType\u003e::new(\n            \"GenericTopic\".to_string(),\n            \"DummyType\".to_string(),\n            tx,\n            0,\n        );\n\n        assert!(!listener.is_running());\n        listener.start().await.unwrap();\n        assert!(listener.is_running());\n\n        listener.stop().await.unwrap();\n        assert!(!listener.is_running());\n    }\n    #[tokio::test]\n    async fn test_multiple_generic_listeners_independent() {\n        let (tx1, _rx1) = mpsc::channel::\u003cDdsData\u003e(5);\n        let (tx2, _rx2) = mpsc::channel::\u003cDdsData\u003e(5);\n\n        let mut listener1 = GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::new(\n            \"ADASObstacleDetectionIsWarning\".to_string(),\n            \"DDS\".to_string(),\n            tx1,\n            100,\n        );\n        let mut listener2 = GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::new(\n            \"ADASObstacleDetectionIsWarning\".to_string(),\n            \"DDS\".to_string(),\n            tx2,\n            100,\n        );\n\n        listener1.start().await.unwrap();\n        listener2.start().await.unwrap();\n\n        assert!(listener1.is_running());\n        assert!(listener2.is_running());\n\n        listener1.stop().await.unwrap();\n        listener2.stop().await.unwrap();\n    }\n    #[tokio::test]\n    async fn test_json_field_extraction() {\n        let dummy = DummyType {\n            id: 42,\n            label: \"test_label\".into(),\n        };\n\n        let json_value = serde_json::to_string(\u0026dummy).unwrap();\n        let parsed: serde_json::Map\u003cString, Value\u003e = serde_json::from_str(\u0026json_value).unwrap();\n\n        let mut fields = HashMap::new();\n        for (k, v) in parsed {\n            fields.insert(k.clone(), v.to_string());\n        }\n\n        assert_eq!(fields.get(\"id\").unwrap(), \"42\");\n        assert_eq!(fields.get(\"label\").unwrap(), \"\\\"test_label\\\"\");\n    }\n    #[tokio::test]\n    async fn test_listener_loop_exits_when_channel_closed() {\n        let (tx, rx) = mpsc::channel(1);\n        let handle = tokio::spawn(async move {\n            TopicListener::listener_loop(\"test\".into(), \"dummy\".into(), tx, 0)\n                .await\n                .unwrap();\n        });\n\n        // Let the task start\n        tokio::time::sleep(Duration::from_millis(200)).await;\n        drop(rx); // Close the receiver to trigger shutdown\n\n        // Let it detect and exit\n        tokio::time::sleep(Duration::from_millis(200)).await;\n\n        // The task should now stop\n        handle.abort(); // Clean up if it's still hanging\n    }\n\n    #[tokio::test]\n    async fn test_start_idempotent_for_topic_listener() {\n        let (tx, _rx) = mpsc::channel(1);\n        let mut listener = TopicListener::new(\n            \"ADASObstacleDetectionIsWarning\".to_string(),\n            \"DDS\".to_string(),\n            tx,\n            100,\n        );\n\n        assert!(!listener.is_running());\n        listener.start().await.unwrap();\n        assert!(listener.is_running());\n\n        listener.start().await.unwrap(); // Should be no-op\n        assert!(listener.is_running());\n\n        listener.stop().await.unwrap();\n    }\n\n    #[tokio::test]\n    async fn test_typed_listener_loop_runs_briefly_and_exits_unit() {\n        use tokio::task::JoinHandle;\n        use tokio::time::{sleep, Duration};\n\n        let (tx, rx) = tokio::sync::mpsc::channel::\u003cDdsData\u003e(1);\n\n        let handle: JoinHandle\u003cResult\u003c(), anyhow::Error\u003e\u003e = tokio::spawn(async move {\n            GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::typed_listener_loop(\n                \"ADASObstacleDetectionIsWarning\".to_string(),\n                \"DDS\".to_string(),\n                tx,\n                100,\n            )\n            .await\n            .map_err(|e| anyhow::anyhow!(e.to_string())) // convert error to string before anyhow\n        });\n\n        sleep(Duration::from_millis(6000)).await;\n\n        drop(rx); // Close receiver to signal exit\n    }\n\n    #[tokio::test]\n    async fn test_start_runs() {\n        use tokio::task::JoinHandle;\n        use tokio::time::{sleep, Duration};\n\n        let (tx, rx) = tokio::sync::mpsc::channel::\u003cDdsData\u003e(1);\n        let mut listener = GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::new(\n            \"ADASObstacleDetectionIsWarning\".to_string(),\n            \"DDS\".to_string(),\n            tx,\n            100,\n        );\n        let handle: JoinHandle\u003cResult\u003c(), anyhow::Error\u003e\u003e = tokio::spawn(async move {\n            listener\n                .start()\n                .await\n                .map_err(|e| anyhow::anyhow!(e.to_string()))\n        }); // convert error to string before anyhow\n\n        sleep(Duration::from_millis(5000)).await;\n\n        drop(rx); // Close receiver to signal exit\n    }\n    #[tokio::test]\n    async fn test_stop_on_listener_with_no_task() {\n        let (tx, _rx) = mpsc::channel::\u003cDdsData\u003e(5);\n        let mut listener = TopicListener::new(\n            \"ADASObstacleDetectionIsWarning\".to_string(),\n            \"DDS\".to_string(),\n            tx,\n            100,\n        );\n        // `stop()` before any `start()`\n        let result = listener.stop().await;\n        assert!(result.is_ok());\n        assert!(!listener.is_running());\n    }\n\n    #[tokio::test]\n    async fn test_generic_listener_topic_checks() {\n        let (tx, _rx) = mpsc::channel::\u003cDdsData\u003e(1);\n        let listener = GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::new(\n            \"ADASObstacleDetectionIsWarning\".to_string(),\n            \"DDS\".to_string(),\n            tx,\n            100,\n        );\n\n        assert_eq!(listener.get_topic_name(), \"ADASObstacleDetectionIsWarning\");\n        assert!(listener.is_topic(\"ADASObstacleDetectionIsWarning\"));\n        assert!(!listener.is_topic(\"wrong_topic\"));\n    }\n    #[tokio::test]\n    async fn test_typed_listener_loop_take_error_logged_and_ignored() {\n        use crate::vehicle::dds::DdsData;\n        use tokio::sync::mpsc;\n        use tokio::time::{sleep, Duration};\n\n        let (tx, rx) = mpsc::channel::\u003cDdsData\u003e(1);\n\n        // Run loop just briefly\n        let handle = tokio::spawn(async move {\n            let _ = GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::typed_listener_loop(\n                \"ADASObstacleDetectionIsWarning\".to_string(),\n                \"DDS\".to_string(),\n                tx,\n                100, // Will work if DDS setup is OK, but reading might fail (no data)\n            )\n            .await;\n        });\n\n        sleep(Duration::from_millis(200)).await;\n        drop(rx);\n    }\n    #[tokio::test]\n    async fn test_typed_listener_loop_exit_triggers_send_err() {\n        use tokio::sync::mpsc::channel;\n        use tokio::time::{sleep, Duration};\n\n        let (tx, rx) = channel::\u003cDdsData\u003e(1);\n\n        // Spawn listener\n        let listener = tokio::spawn(async move {\n            let res = GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::typed_listener_loop(\n                \"ADASObstacleDetectionIsWarning\".to_string(),\n                \"DDS\".to_string(),\n                tx,\n                100,\n            )\n            .await;\n\n            // Explicitly assert result inside task (forces evaluation)\n            assert!(res.is_ok());\n        });\n\n        // Drop rx after delay\n        tokio::spawn(async move {\n            sleep(Duration::from_millis(500)).await;\n            drop(rx);\n        });\n\n        // Wait long enough for tx.send().await.is_err() to be hit\n        sleep(Duration::from_secs(1)).await;\n\n        // Wait for task\n        let _ = listener.await;\n    }\n    #[tokio::test]\n    async fn test_typed_listener_loop_direct_and_exit_cleanly() {\n        use tokio::time::sleep;\n        use tokio::{sync::mpsc, time::Duration};\n\n        let (tx, mut rx) = mpsc::channel::\u003cDdsData\u003e(1);\n\n        // Drop receiver after a short delay to cause tx.send() to fail and exit the loop\n        tokio::spawn(async move {\n            sleep(Duration::from_millis(5000)).await;\n            drop(rx);\n        });\n\n        // Run loop directly — this is critical for tarpaulin to trace it\n        let result = GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::typed_listener_loop(\n            \"ADASObstacleDetectionIsWarning\".to_string(),\n            \"DDS\".to_string(),\n            tx,\n            100,\n        )\n        .await;\n\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":75,"address":[3280576],"length":1,"stats":{"Line":7}},{"line":92,"address":[3585200],"length":1,"stats":{"Line":5}},{"line":99,"address":[3563770],"length":1,"stats":{"Line":11}},{"line":104,"address":[3342912],"length":1,"stats":{"Line":5}},{"line":110,"address":[3642221],"length":1,"stats":{"Line":11}},{"line":115,"address":[6391568],"length":1,"stats":{"Line":3}},{"line":116,"address":[3343029],"length":1,"stats":{"Line":3}},{"line":119,"address":[3339134,3339738,3338848,3338950,3338878,3339090,3339713],"length":1,"stats":{"Line":35}},{"line":120,"address":[3040547],"length":1,"stats":{"Line":14}},{"line":121,"address":[3040574],"length":1,"stats":{"Line":4}},{"line":125,"address":[3235652,3235582],"length":1,"stats":{"Line":21}},{"line":126,"address":[3040636,3040707],"length":1,"stats":{"Line":22}},{"line":127,"address":[3547543,3547607],"length":1,"stats":{"Line":22}},{"line":128,"address":[3378439],"length":1,"stats":{"Line":8}},{"line":131,"address":[4118491,4119310,4117889,4118281,4118446,4118611,4118256],"length":1,"stats":{"Line":27}},{"line":132,"address":[6046313,6046378,6046477,6046773,6046174],"length":1,"stats":{"Line":25}},{"line":133,"address":[3548694,3548722,3548599],"length":1,"stats":{"Line":0}},{"line":138,"address":[4124146,4124118,4124190],"length":1,"stats":{"Line":24}},{"line":139,"address":[3547842],"length":1,"stats":{"Line":9}},{"line":140,"address":[6045958],"length":1,"stats":{"Line":16}},{"line":143,"address":[3379982,3380503,3380043,3379952,3380221,3380177,3380551],"length":1,"stats":{"Line":20}},{"line":144,"address":[3341202,3341490],"length":1,"stats":{"Line":10}},{"line":145,"address":[4125851,4125794],"length":1,"stats":{"Line":12}},{"line":146,"address":[3042752],"length":1,"stats":{"Line":6}},{"line":148,"address":[3341486],"length":1,"stats":{"Line":6}},{"line":150,"address":[6047528],"length":1,"stats":{"Line":5}},{"line":153,"address":[3642432],"length":1,"stats":{"Line":2}},{"line":154,"address":[3564053],"length":1,"stats":{"Line":2}},{"line":157,"address":[6391696],"length":1,"stats":{"Line":2}},{"line":158,"address":[6391714],"length":1,"stats":{"Line":2}},{"line":164,"address":[2740176],"length":1,"stats":{"Line":6}},{"line":171,"address":[4073003,4073163,4073191],"length":1,"stats":{"Line":20}},{"line":173,"address":[3008250,3007925],"length":1,"stats":{"Line":17}},{"line":174,"address":[3346098,3347333,3345936],"length":1,"stats":{"Line":9}},{"line":175,"address":[3345916],"length":1,"stats":{"Line":9}},{"line":176,"address":[4088896,4088911,4085522],"length":1,"stats":{"Line":0}},{"line":179,"address":[3307266,3307373,3308215,3307224,3307474],"length":1,"stats":{"Line":15}},{"line":180,"address":[3497962],"length":1,"stats":{"Line":5}},{"line":181,"address":[6016975,6013778,6016960],"length":1,"stats":{"Line":0}},{"line":185,"address":[3307771,3307674,3307801],"length":1,"stats":{"Line":18}},{"line":191,"address":[3307782,3308127],"length":1,"stats":{"Line":12}},{"line":194,"address":[3205712,3205009,3205627,3202854,3204578],"length":1,"stats":{"Line":27}},{"line":198,"address":[3010928],"length":1,"stats":{"Line":6}},{"line":199,"address":[3205983],"length":1,"stats":{"Line":6}},{"line":200,"address":[4076234],"length":1,"stats":{"Line":5}},{"line":204,"address":[3382437],"length":1,"stats":{"Line":20}},{"line":205,"address":[3348964,3349057],"length":1,"stats":{"Line":6}},{"line":210,"address":[6016296],"length":1,"stats":{"Line":3}},{"line":255,"address":[4077440,4077536,4077632,4077728,4077824],"length":1,"stats":{"Line":7}},{"line":273,"address":[2517968],"length":1,"stats":{"Line":6}},{"line":280,"address":[6033753,6025799,6025945,6033607,6017991,6018137],"length":1,"stats":{"Line":12}},{"line":281,"address":[6026145,6033953,6025983,6020530,6036146,6028338,6018337,6018175,6033791],"length":1,"stats":{"Line":6}},{"line":282,"address":[3311835,3327451,3319643],"length":1,"stats":{"Line":6}},{"line":283,"address":[4113311,4098289,4113535,4113759,4113296,4090481,4113744,4106097,4113520],"length":1,"stats":{"Line":0}},{"line":286,"address":[3526124,3512651,3510769,3518353,3533543,3533585,3518553,3505067,3503185,3525959,3503143,3503385,3510727,3527883,3535467,3533785,3503308,3510892,3510969,3520235,3518311,3526201,3526001,3533708,3518476],"length":1,"stats":{"Line":12}},{"line":287,"address":[4090685,4098493,4106301],"length":1,"stats":{"Line":4}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[3224903,3225083,3217275,3209049,3226129,3209467,3216857,3210513,3224665,3209287,3218321,3217095],"length":1,"stats":{"Line":8}},{"line":291,"address":[3939566,3931648,3931758,3923840,3923950,3939456],"length":1,"stats":{"Line":8}},{"line":292,"address":[4114879,4115088,4114864,4107131,4115103,4099323,4091515,4114640,4114655],"length":1,"stats":{"Line":0}},{"line":295,"address":[3360255,3368063,3352447,3360887,3368695,3360474,3360200,3352559,3368008,3360367,3352392,3368175,3368282,3353079,3352666],"length":1,"stats":{"Line":13}},{"line":296,"address":[3022570,3030378,3014762],"length":1,"stats":{"Line":4}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[3504674,3512336,3527490,3535152,3519920,3512258,3527568,3519842,3535074,3504752],"length":1,"stats":{"Line":10}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[3504826,3527642,3512410,3519994,3535226],"length":1,"stats":{"Line":5}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[3628700,3637212,3634364],"length":1,"stats":{"Line":20}},{"line":311,"address":[3212219,3220027,3227835],"length":1,"stats":{"Line":5}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[3949136,3948912,3948927,3949151,3948703,3948688],"length":1,"stats":{"Line":13}},{"line":315,"address":[3362769,3370577,3354961],"length":1,"stats":{"Line":6}},{"line":316,"address":[4113592,4082856,4105848,4090520,4098184],"length":1,"stats":{"Line":4}},{"line":317,"address":[4094554,4093650,4101458,4102362,4109266,4110170],"length":1,"stats":{"Line":8}},{"line":318,"address":[3025731,3016736,3033539,3024544,3017923,3032352],"length":1,"stats":{"Line":8}},{"line":320,"address":[6038634,6023016,6032369,6038741,6030933,6024559,6023123,6022940,6038558,6040177,6030826,6030750],"length":1,"stats":{"Line":8}},{"line":321,"address":[3018179,3033797,3039804,3039792,3039568,3040028,3025989,3039580,3040016],"length":1,"stats":{"Line":0}},{"line":324,"address":[3316919,3332537,3324729],"length":1,"stats":{"Line":4}},{"line":325,"address":[],"length":0,"stats":{"Line":8}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":12}},{"line":329,"address":[3944374,3928648,3928938,3944556,3944266,3928756,3936458,3936566,3936748],"length":1,"stats":{"Line":4}},{"line":335,"address":[6024162,6039780,6031972],"length":1,"stats":{"Line":4}},{"line":341,"address":[3404165,3412677,3409829],"length":1,"stats":{"Line":17}},{"line":342,"address":[3945158,3937269,3945077,3929540,3929459,3937350],"length":1,"stats":{"Line":4}},{"line":343,"address":[2524903],"length":1,"stats":{"Line":2}},{"line":348,"address":[4102253,4110061,4094445],"length":1,"stats":{"Line":5}},{"line":349,"address":[3927172,3935217,3934980,3942788,3943053,3943025,3927437,3935245,3927409],"length":1,"stats":{"Line":17}},{"line":368,"address":[3237968,3238000,3237984],"length":1,"stats":{"Line":4}},{"line":369,"address":[3380597,3380613,3380629],"length":1,"stats":{"Line":4}},{"line":372,"address":[2527278,2528134,2527350,2527209,2527534,2527248,2528109,2527490],"length":1,"stats":{"Line":27}},{"line":373,"address":[3381091,3382947,3382019],"length":1,"stats":{"Line":7}},{"line":374,"address":[3554010,3550362,3553098,3551274,3552186],"length":1,"stats":{"Line":0}},{"line":377,"address":[6050308,6049310,6048452,6049380,6050238,6048382],"length":1,"stats":{"Line":18}},{"line":378,"address":[3045388,3043603,3043532,3044460,3044531,3045459],"length":1,"stats":{"Line":19}},{"line":379,"address":[3240491,3238635,3238703,3239563,3239631,3240559],"length":1,"stats":{"Line":16}},{"line":380,"address":[3240567,3238711,3239639],"length":1,"stats":{"Line":8}},{"line":383,"address":[3381345,3384785,3382273,3386320,3384944,3383201,3385368,3385102,3387481,3386161,3383726,3386744,3383992,3386478,3383593,3387537,3384969,3386105,3386345,3383568,3384729],"length":1,"stats":{"Line":22}},{"line":384,"address":[3555230,3559262,3558002,3555314,3559346,3557918,3556574,3556658,3560606,3560690],"length":1,"stats":{"Line":0}},{"line":385,"address":[3955897,3955790,3957166,3957335,3957538,3956162,3958542,3955959,3958711,3958914,3958649,3957273],"length":1,"stats":{"Line":20}},{"line":387,"address":[3046747,3049376,3049499,3049471,3048123,3046719,3046624,3048000,3048095],"length":1,"stats":{"Line":0}},{"line":391,"address":[3043910,3045722,3045766,3045694,3044766,3044794,3043838,3043866,3044838],"length":1,"stats":{"Line":18}},{"line":392,"address":[3383426,3382498,3381570],"length":1,"stats":{"Line":10}},{"line":393,"address":[4121014,4121942,4122870],"length":1,"stats":{"Line":10}},{"line":396,"address":[6055760,6055081,6055150,6056029,6055851,6055345,6055211,6056491,6055790,6056359,6054985,6056400,6056430,6056669,6055671,6056311,6055719,6056951,6055985,6055120,6055389,6056625,6056999,6055033],"length":1,"stats":{"Line":16}},{"line":397,"address":[3350370,3350658,3350018,3349730,3349090,3349378],"length":1,"stats":{"Line":8}},{"line":398,"address":[],"length":0,"stats":{"Line":8}},{"line":399,"address":[6056208,6055568,6056848],"length":1,"stats":{"Line":4}},{"line":401,"address":[6056334,6056974,6055694],"length":1,"stats":{"Line":4}},{"line":403,"address":[3350376,3349096,3349736],"length":1,"stats":{"Line":4}},{"line":406,"address":[3564704,3564688,3564672,3564720],"length":1,"stats":{"Line":2}},{"line":407,"address":[3961941,3961909,3961925],"length":1,"stats":{"Line":2}},{"line":410,"address":[3962048,3962000,3961952],"length":1,"stats":{"Line":2}},{"line":411,"address":[3247202,3247298,3247250],"length":1,"stats":{"Line":2}}],"covered":99,"coverable":115},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","vehicle","dds","mod.rs"],"content":"use anyhow::anyhow;\nuse common::Result;\nuse log::{debug, error, info, warn};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::env;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse tokio::sync::mpsc::{self, Receiver, Sender};\nuse tokio::sync::Mutex;\n\npub mod listener;\n\n// Re-export the modules\npub use listener::{create_idl_listener, DdsTopicListener};\n\n// DdsData structure to represent parsed IDL data\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DdsData {\n    pub name: String,\n    pub value: String,\n    pub fields: HashMap\u003cString, String\u003e,\n}\n\n/// DDS Manager - Manages multiple DDS listeners\npub struct DdsManager {\n    /// Active listener map (topic name → listener)\n    listeners: HashMap\u003cString, Box\u003cdyn DdsTopicListener\u003e\u003e,\n    /// Channel for sending DDS data\n    tx: Sender\u003cDdsData\u003e,\n    /// Channel for receiving DDS data\n    rx: Mutex\u003cReceiver\u003cDdsData\u003e\u003e,\n    /// DDS domain ID\n    domain_id: i32,\n}\n\nimpl DdsManager {\n    /// Create new DDS manager\n    pub fn new(tx: Sender\u003cDdsData\u003e) -\u003e Self {\n        // let (tx, rx) = mpsc::channel(100);\n\n        Self {\n            listeners: HashMap::new(),\n            tx,\n            rx: Mutex::new(mpsc::channel(100).1),\n            domain_id: 100,\n        }\n    }\n    /// Scan and process IDL directory at runtime\n    pub async fn scan_idl_directory(\u0026mut self, dir: \u0026Path) -\u003e Result\u003cVec\u003cString\u003e\u003e {\n        info!(\"Scanning IDL directory at runtime: {:?}\", dir);\n        let mut found_types = Vec::new();\n\n        // Check if directory exists\n        if !dir.exists() {\n            return Ok(found_types);\n        }\n\n        // IDL 파일 검색\n        for entry in fs::read_dir(dir)? {\n            let entry = entry?;\n            let path = entry.path();\n\n            if path.is_file() \u0026\u0026 path.extension().map_or(false, |ext| ext == \"idl\") {\n                if let Some(stem) = path.file_stem() {\n                    let type_name = stem.to_string_lossy().to_string();\n                    found_types.push(type_name);\n                }\n            }\n        }\n\n        info!(\"Found {} IDL types at runtime\", found_types.len());\n        Ok(found_types)\n    }\n    /// 타입명에 맞는 특화된 리스너 생성\n    pub async fn create_typed_listener(\n        \u0026mut self,\n        topic_name: String,\n        data_type_name: String,\n    ) -\u003e Result\u003c()\u003e {\n        // 이미 존재하는 리스너인지 확인\n        if self.listeners.contains_key(\u0026topic_name) {\n            warn!(\"Listener for topic '{}' already exists\", topic_name);\n            return Ok(());\n        }\n        print!(\n            \"DDSManager - Creating typed listener for topic '{}'\",\n            topic_name\n        );\n\n        // 레지스트리를 통한 타입별 리스너 생성 시도\n        if let Some(mut typed_listener) = dds_type_registry::create_typed_listener(\n            \u0026data_type_name,\n            topic_name.clone(),\n            self.tx.clone(),\n            self.domain_id,\n        ) {\n            // 리스너 시작\n            typed_listener\n                .start()\n                .await\n                .map_err(|e| anyhow!(\"Failed to start typed listener: {:?}\", e))?;\n\n            println!(\n                \"Started typed listener for {} with specific type {}\",\n                topic_name, data_type_name\n            );\n\n            // 리스너 맵에 추가\n            self.listeners.insert(topic_name, typed_listener);\n            return Ok(());\n        }\n\n        // Create generic listener if no type-specific listener is found\n        warn!(\n            \"No specific type handler for '{}', using generic listener\",\n            data_type_name\n        );\n        self.create_listener(topic_name, data_type_name).await\n    }\n\n    /// Get list of available DDS types\n    pub fn list_available_types(\u0026self) -\u003e Vec\u003cString\u003e {\n        dds_type_metadata::get_available_types()\n    }\n\n    /// Set DDS domain ID\n    pub fn set_domain_id(\u0026mut self, domain_id: i32) {\n        self.domain_id = domain_id;\n    }\n\n    /// Get DDS data sender\n    pub fn get_sender(\u0026self) -\u003e Sender\u003cDdsData\u003e {\n        self.tx.clone()\n    }\n\n    /// Get DDS data receiver\n    pub async fn get_receiver(\u0026mut self) -\u003e \u0026mut Mutex\u003cReceiver\u003cDdsData\u003e\u003e {\n        \u0026mut self.rx\n    }\n\n    /// Create and register listener\n    pub async fn create_listener(\n        \u0026mut self,\n        topic_name: String,\n        data_type_name: String,\n    ) -\u003e Result\u003c()\u003e {\n        // 이미 존재하는 리스너인지 확인\n        if self.listeners.contains_key(\u0026topic_name) {\n            return Ok(());\n        }\n\n        // 관련 IDL 파일 검색\n        // let idl_path = self.find_idl_for_type(\u0026data_type_name)?;\n\n        // 리스너 생성\n        let mut listener = create_idl_listener(\n            topic_name.clone(),\n            data_type_name,\n            self.tx.clone(),\n            self.domain_id,\n        );\n\n        // 리스너 시작\n        listener\n            .start()\n            .await\n            .map_err(|e| anyhow!(\"Failed to start listener: {:?}\", e))?;\n\n        // 리스너 맵에 추가\n        self.listeners.insert(topic_name, listener);\n\n        Ok(())\n    }\n\n    /// 리스너 제거\n    pub async fn remove_listener(\u0026mut self, topic_name: \u0026str) -\u003e Result\u003c()\u003e {\n        if let Some(mut listener) = self.listeners.remove(topic_name) {\n            listener\n                .stop()\n                .await\n                .map_err(|e| anyhow!(\"Failed to stop listener: {:?}\", e))?;\n        }\n\n        Ok(())\n    }\n\n    /// Stop all listeners\n    pub async fn stop_all(\u0026mut self) -\u003e Result\u003c()\u003e {\n        for (_, mut listener) in std::mem::take(\u0026mut self.listeners) {\n            if let Err(e) = listener.stop().await {\n                eprintln!(\"Failed to stop listener: {:?}\", e);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Backward-compatible `init()` that uses no path\n    pub async fn init(\u0026mut self) -\u003e Result\u003c()\u003e {\n        self.init_with_path(None).await\n    }\n\n    /// Flexible version with optional path param\n    pub async fn init_with_path\u003cP: Into\u003cOption\u003cPathBuf\u003e\u003e\u003e(\n        \u0026mut self,\n        settings_path: P,\n    ) -\u003e Result\u003c()\u003e {\n        info!(\"Initializing DDS Manager\");\n        let default_domain_id = 0;\n\n        let settings_path = settings_path.into().unwrap_or_else(|| {\n            env::var(\"PICCOLO_SETTINGS_PATH\")\n                .map(PathBuf::from)\n                .unwrap_or_else(|_| {\n                    PathBuf::from(\"/home/edo/2025/projects/pullpiri/src/settings.yaml\")\n                })\n        });\n\n        info!(\"Reading settings from {:?}\", settings_path);\n        let content = fs::read_to_string(\u0026settings_path)?;\n\n        // JSON 또는 YAML 파싱\n        let settings = serde_json::from_str::\u003cserde_json::Value\u003e(\u0026content)?;\n\n        let domain_id = settings\n            .get(\"dds\")\n            .and_then(|dds| dds.get(\"domain_id\"))\n            .and_then(|id| id.as_i64())\n            .map(|id| id as i32)\n            .unwrap_or(default_domain_id);\n\n        info!(\"Domain ID from settings: {}\", domain_id);\n\n        // Check OUT_DIR value (not used at runtime, only for logging)\n        if let Some(out_dir) = settings\n            .get(\"dds\")\n            .and_then(|dds| dds.get(\"out_dir\"))\n            .and_then(|path| path.as_str())\n        {\n            info!(\"Output directory from settings: {}\", out_dir);\n        }\n\n        self.domain_id = domain_id;\n\n        Ok(())\n    }\n}\n\n// Include generated DDS types at runtime\n#[allow(unused)]\npub mod dds_types {\n    #[allow(unused_variables, unused_imports)]\n    include! {\n        concat!(env!(\"OUT_DIR\"), \"/dds_types.rs\")\n    }\n}\n\n#[allow(unused)]\npub mod dds_type_metadata {\n    // Try including the generated code from build.rs\n    // If no IDL files exist, this will just include an empty file\n    // No placeholder types will be created\n\n    /// Returns a vector of available DDS type names obtained from the generated type metadata.\n    pub fn get_available_types() -\u003e Vec\u003cString\u003e {\n        dds_type_metadata::get_type_metadata()\n            .keys()\n            .cloned()\n            .collect()\n    }\n\n    // Always include the generated type metadata; this file is generated by build.rs.\n\n    pub mod dds_type_metadata {\n        #[allow(unused_variables, unused_imports)]\n        include! {\n            concat!(env!(\"OUT_DIR\"), \"/dds_type_metadata.rs\")\n        }\n    }\n}\n// Include generated type registry\n#[allow(unused)]\npub mod dds_type_registry {\n    use super::*;\n    use crate::vehicle::dds::listener::{create_idl_listener, DdsTopicListener};\n    use tokio::sync::mpsc::Sender;\n\n    // 빌드 중에 생성된 DDS 타입 레지스트리를 조건부로 포함\n    #[cfg(feature = \"dds_type_registry_exists\")]\n    include!(concat!(env!(\"OUT_DIR\"), \"/dds_type_registry.rs\"));\n\n    // 빌드 전이거나 레지스트리가 생성되지 않은 경우 기본 구현 제공\n    #[cfg(not(feature = \"dds_type_registry_exists\"))]\n    pub fn create_typed_listener(\n        type_name: \u0026str,\n        topic_name: String,\n        tx: Sender\u003cDdsData\u003e,\n        domain_id: i32,\n    ) -\u003e Option\u003cBox\u003cdyn DdsTopicListener\u003e\u003e {\n        log::info!(\n            \"No type registry found. Looking for type handler: {}\",\n            type_name\n        );\n        None\n    }\n}\n//Unit Test Cases\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::Path;\n    use tokio::sync::mpsc;\n\n    // Mock implementation of DdsTopicListener for testing\n    struct MockDdsTopicListener {\n        running: bool,\n        topic_name: String,\n    }\n\n    #[async_trait::async_trait]\n    impl DdsTopicListener for MockDdsTopicListener {\n        async fn start(\u0026mut self) -\u003e Result\u003c()\u003e {\n            self.running = true;\n            Ok(())\n        }\n\n        async fn stop(\u0026mut self) -\u003e Result\u003c()\u003e {\n            self.running = false;\n            Ok(())\n        }\n\n        fn is_running(\u0026self) -\u003e bool {\n            self.running\n        }\n\n        fn get_topic_name(\u0026self) -\u003e \u0026str {\n            \u0026self.topic_name\n        }\n\n        fn is_topic(\u0026self, topic: \u0026str) -\u003e bool {\n            self.topic_name == topic\n        }\n    }\n\n    #[tokio::test]\n    async fn test_scan_idl_directory_with_nonexistent_path() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let dir = Path::new(\"/nonexistent/path\");\n        let result = manager.scan_idl_directory(dir).await.unwrap();\n        assert!(result.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_scan_idl_directory_with_empty_directory() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let temp_dir = tempfile::tempdir().unwrap();\n        let result = manager.scan_idl_directory(temp_dir.path()).await.unwrap();\n        assert!(result.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_create_typed_listener_with_existing_listener() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let topic_name = \"test_topic\".to_string();\n        let data_type_name = \"test_type\".to_string();\n\n        manager.listeners.insert(\n            topic_name.clone(),\n            Box::new(MockDdsTopicListener {\n                running: false,\n                topic_name: topic_name.clone(),\n            }),\n        );\n\n        let result = manager\n            .create_typed_listener(topic_name.clone(), data_type_name.clone())\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_remove_listener_with_nonexistent_listener() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let topic_name = \"nonexistent_topic\";\n        let result = manager.remove_listener(topic_name).await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_remove_listener_existing() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let topic = \"existing_topic\";\n\n        manager.listeners.insert(\n            topic.to_string(),\n            Box::new(MockDdsTopicListener {\n                running: true,\n                topic_name: topic.to_string(),\n            }),\n        );\n\n        let result = manager.remove_listener(topic).await;\n        assert!(result.is_ok());\n        assert!(!manager.listeners.contains_key(topic));\n    }\n\n    #[tokio::test]\n    async fn test_stop_all_with_no_listeners() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let result = manager.stop_all().await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_stop_all_with_multiple_listeners() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n\n        for i in 0..3 {\n            let topic = format!(\"topic_{}\", i);\n            manager.listeners.insert(\n                topic.clone(),\n                Box::new(MockDdsTopicListener {\n                    running: true,\n                    topic_name: topic,\n                }),\n            );\n        }\n\n        let result = manager.stop_all().await;\n        assert!(result.is_ok());\n        assert!(manager.listeners.is_empty());\n    }\n\n    #[tokio::test]\n    async fn test_get_sender() {\n        let (tx, _) = mpsc::channel(100);\n        let manager = DdsManager::new(tx.clone());\n        let sender = manager.get_sender();\n        assert_eq!(sender.capacity(), tx.capacity());\n    }\n\n    #[tokio::test]\n    async fn test_get_receiver_returns_mutex_ref() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let receiver = manager.get_receiver().await;\n        let _lock = receiver.lock().await;\n    }\n\n    #[tokio::test]\n    async fn test_create_listener_creates_and_starts_listener() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let topic = \"new_topic\".to_string();\n        let data_type = \"new_type\".to_string();\n\n        let result = manager.create_listener(topic.clone(), data_type).await;\n        assert!(result.is_ok());\n        assert!(manager.listeners.contains_key(\u0026topic));\n    }\n\n    #[tokio::test]\n    async fn test_create_listener_skips_existing() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let topic = \"existing_topic\".to_string();\n\n        manager.listeners.insert(\n            topic.clone(),\n            Box::new(MockDdsTopicListener {\n                running: false,\n                topic_name: topic.clone(),\n            }),\n        );\n\n        let result = manager\n            .create_listener(topic.clone(), \"any_type\".to_string())\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_list_available_types_returns_vec() {\n        let types = dds_type_metadata::get_available_types();\n        assert!(types.is_empty() || types.iter().all(|t| t.is_ascii()));\n    }\n\n    #[tokio::test]\n    async fn test_init_with_invalid_settings_path() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let result = manager.init().await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_init_reads_domain_id() {\n        let (tx, _) = tokio::sync::mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n\n        let temp_file = tempfile::NamedTempFile::new().unwrap();\n        std::fs::write(\n            temp_file.path(),\n            r#\"\n{\n    \"dds\": {\n        \"domain_id\": 42,\n        \"out_dir\": \"/tmp/output\"\n    }\n}\n\"#,\n        )\n        .unwrap();\n\n        let result = manager.init_with_path(Some(temp_file.path().into())).await;\n        assert!(result.is_ok(), \"Init failed: {:?}\", result.unwrap_err());\n        assert_eq!(manager.domain_id, 42);\n    }\n\n    #[tokio::test]\n    async fn test_create_typed_listener_falls_back_to_generic() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n        let result = manager\n            .create_typed_listener(\"unknown_topic\".to_string(), \"UnknownType\".to_string())\n            .await;\n        assert!(result.is_ok());\n    }\n    #[tokio::test]\n    async fn test_scan_idl_directory_with_idl_files() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n\n        let temp_dir = tempfile::tempdir().unwrap();\n        // Create a few .idl files and some non-idl files\n        std::fs::write(temp_dir.path().join(\"example1.idl\"), \"\").unwrap();\n        std::fs::write(temp_dir.path().join(\"example2.idl\"), \"\").unwrap();\n        std::fs::write(temp_dir.path().join(\"ignore.txt\"), \"\").unwrap();\n\n        let result = manager.scan_idl_directory(temp_dir.path()).await.unwrap();\n\n        // Should include only the idl file stems\n        assert_eq!(result.len(), 2);\n        assert!(result.contains(\u0026\"example1\".to_string()));\n        assert!(result.contains(\u0026\"example2\".to_string()));\n        assert!(!result.contains(\u0026\"ignore\".to_string()));\n    }\n    struct DummyListener {\n        running: bool,\n        topic_name: String,\n    }\n\n    #[async_trait::async_trait]\n    impl DdsTopicListener for DummyListener {\n        async fn start(\u0026mut self) -\u003e Result\u003c()\u003e {\n            self.running = true;\n            Ok(())\n        }\n        async fn stop(\u0026mut self) -\u003e Result\u003c()\u003e {\n            self.running = false;\n            Ok(())\n        }\n        fn is_running(\u0026self) -\u003e bool {\n            self.running\n        }\n        fn get_topic_name(\u0026self) -\u003e \u0026str {\n            \u0026self.topic_name\n        }\n        fn is_topic(\u0026self, topic: \u0026str) -\u003e bool {\n            self.topic_name == topic\n        }\n    }\n\n    // Override the dds_type_registry::create_typed_listener temporarily for testing\n    mod dds_type_registry {\n        use super::{DdsTopicListener, DummyListener};\n        use crate::vehicle::DdsData;\n        use anyhow::Result;\n        use std::boxed::Box;\n        use tokio::sync::mpsc::Sender;\n\n        pub fn create_typed_listener(\n            type_name: \u0026str,\n            topic_name: String,\n            _tx: Sender\u003cDdsData\u003e,\n            _domain_id: i32,\n        ) -\u003e Option\u003cBox\u003cdyn DdsTopicListener\u003e\u003e {\n            if type_name == \"KnownType\" {\n                Some(Box::new(DummyListener {\n                    running: false,\n                    topic_name,\n                }))\n            } else {\n                None\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_create_typed_listener_with_registry_some() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n\n        // Use KnownType to get Some(listener)\n        let topic = \"topic_known\".to_string();\n        let data_type = \"KnownType\".to_string();\n\n        let result = manager\n            .create_typed_listener(topic.clone(), data_type)\n            .await;\n        assert!(result.is_ok());\n        assert!(manager.listeners.contains_key(\u0026topic));\n        // The inserted listener should be running after start\n        let listener = manager.listeners.get(\u0026topic).unwrap();\n        assert!(listener.is_running());\n    }\n    struct FailingStopListener {\n        topic_name: String,\n    }\n\n    #[async_trait::async_trait]\n    impl DdsTopicListener for FailingStopListener {\n        async fn start(\u0026mut self) -\u003e Result\u003c()\u003e {\n            Ok(())\n        }\n        async fn stop(\u0026mut self) -\u003e Result\u003c()\u003e {\n            Err(anyhow!(\"Forced stop error\").into())\n        }\n        fn is_running(\u0026self) -\u003e bool {\n            true\n        }\n        fn get_topic_name(\u0026self) -\u003e \u0026str {\n            \u0026self.topic_name\n        }\n        fn is_topic(\u0026self, topic: \u0026str) -\u003e bool {\n            self.topic_name == topic\n        }\n    }\n\n    #[tokio::test]\n    async fn test_stop_all_with_failing_listener() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n\n        let topic = \"fail_stop_topic\".to_string();\n\n        manager.listeners.insert(\n            topic.clone(),\n            Box::new(FailingStopListener {\n                topic_name: topic.clone(),\n            }),\n        );\n\n        let result = manager.stop_all().await;\n        // It should return Ok even though stop() failed internally\n        assert!(result.is_ok());\n        // listeners map should be empty after stop_all\n        assert!(manager.listeners.is_empty());\n    }\n    #[tokio::test]\n    async fn test_init_with_path_default_domain_id() {\n        let (tx, _) = mpsc::channel(100);\n        let mut manager = DdsManager::new(tx);\n\n        let temp_file = tempfile::NamedTempFile::new().unwrap();\n        std::fs::write(temp_file.path(), r#\"{\"dds\":{}}\"#).unwrap();\n\n        let result = manager.init_with_path(Some(temp_file.path().into())).await;\n        assert!(result.is_ok());\n        assert_eq!(manager.domain_id, 0); // default domain_id\n    }\n}\n","traces":[{"line":39,"address":[4169808,4170263,4170200],"length":1,"stats":{"Line":12}},{"line":43,"address":[4414134],"length":1,"stats":{"Line":13}},{"line":45,"address":[3386289,3386371],"length":1,"stats":{"Line":25}},{"line":50,"address":[3621368,3623851,3621152,3623938,3621191,3621346],"length":1,"stats":{"Line":8}},{"line":51,"address":[6362277,6362426,6362398],"length":1,"stats":{"Line":6}},{"line":52,"address":[3534772],"length":1,"stats":{"Line":4}},{"line":55,"address":[3326201,3326287],"length":1,"stats":{"Line":8}},{"line":56,"address":[5118541],"length":1,"stats":{"Line":2}},{"line":60,"address":[3455501,3453621,3453883,3453567],"length":1,"stats":{"Line":12}},{"line":61,"address":[3679609,3680216],"length":1,"stats":{"Line":4}},{"line":62,"address":[3536468],"length":1,"stats":{"Line":2}},{"line":64,"address":[3537325,3536547,3537312,3536670,3536615],"length":1,"stats":{"Line":10}},{"line":65,"address":[4419511,4419916],"length":1,"stats":{"Line":4}},{"line":66,"address":[3680832,3680874],"length":1,"stats":{"Line":4}},{"line":67,"address":[5120390],"length":1,"stats":{"Line":2}},{"line":72,"address":[4418665,4418490],"length":1,"stats":{"Line":4}},{"line":73,"address":[5119112],"length":1,"stats":{"Line":2}},{"line":76,"address":[4414656],"length":1,"stats":{"Line":8}},{"line":82,"address":[3455856,3456006],"length":1,"stats":{"Line":13}},{"line":83,"address":[3539163,3539186,3537787],"length":1,"stats":{"Line":15}},{"line":84,"address":[3268097],"length":1,"stats":{"Line":5}},{"line":86,"address":[3624412,3624491],"length":1,"stats":{"Line":14}},{"line":93,"address":[5121212],"length":1,"stats":{"Line":6}},{"line":94,"address":[3456227,3456293],"length":1,"stats":{"Line":12}},{"line":95,"address":[4420793],"length":1,"stats":{"Line":5}},{"line":96,"address":[6365774],"length":1,"stats":{"Line":7}},{"line":99,"address":[4422546,4422375,4422453,4421080,4421252,4422910],"length":1,"stats":{"Line":4}},{"line":101,"address":[3537664,3538473,3539693,3538538,3539508],"length":1,"stats":{"Line":3}},{"line":102,"address":[3268738,3269792,3269809],"length":1,"stats":{"Line":0}},{"line":104,"address":[5123101],"length":1,"stats":{"Line":1}},{"line":110,"address":[3268932],"length":1,"stats":{"Line":1}},{"line":111,"address":[3540160],"length":1,"stats":{"Line":1}},{"line":115,"address":[3625423,3625231],"length":1,"stats":{"Line":12}},{"line":119,"address":[3505526],"length":1,"stats":{"Line":10}},{"line":123,"address":[6295792],"length":1,"stats":{"Line":2}},{"line":124,"address":[4297745],"length":1,"stats":{"Line":2}},{"line":128,"address":[4103536],"length":1,"stats":{"Line":15}},{"line":129,"address":[4103545],"length":1,"stats":{"Line":13}},{"line":133,"address":[4103552],"length":1,"stats":{"Line":2}},{"line":134,"address":[6295861],"length":1,"stats":{"Line":2}},{"line":138,"address":[3627774,3627839,3627760],"length":1,"stats":{"Line":8}},{"line":139,"address":[3270083],"length":1,"stats":{"Line":2}},{"line":143,"address":[3612192],"length":1,"stats":{"Line":8}},{"line":149,"address":[3270384,3270513],"length":1,"stats":{"Line":15}},{"line":150,"address":[6369254],"length":1,"stats":{"Line":2}},{"line":158,"address":[3332762,3332679],"length":1,"stats":{"Line":16}},{"line":159,"address":[4424366],"length":1,"stats":{"Line":11}},{"line":160,"address":[6369366],"length":1,"stats":{"Line":5}},{"line":161,"address":[3685738],"length":1,"stats":{"Line":11}},{"line":165,"address":[3629227,3629130,3628615,3628735,3629055,3629533],"length":1,"stats":{"Line":26}},{"line":167,"address":[3460304,3460697,3460518,3459776,3460351],"length":1,"stats":{"Line":34}},{"line":168,"address":[3687152,3687169,3686475],"length":1,"stats":{"Line":0}},{"line":171,"address":[5125774],"length":1,"stats":{"Line":12}},{"line":173,"address":[3271680],"length":1,"stats":{"Line":5}},{"line":177,"address":[3239904,3239922],"length":1,"stats":{"Line":13}},{"line":178,"address":[5126935,5126791],"length":1,"stats":{"Line":10}},{"line":179,"address":[5127376,5127447,5127181,5127536,5127023,5127717],"length":1,"stats":{"Line":12}},{"line":181,"address":[4229094],"length":1,"stats":{"Line":9}},{"line":182,"address":[3631361,3631060,3631344],"length":1,"stats":{"Line":0}},{"line":185,"address":[6372135],"length":1,"stats":{"Line":3}},{"line":189,"address":[4297952,4297960],"length":1,"stats":{"Line":8}},{"line":190,"address":[3463296,3464298,3463450,3463402],"length":1,"stats":{"Line":8}},{"line":191,"address":[2958519],"length":1,"stats":{"Line":14}},{"line":192,"address":[3463859,3463970],"length":1,"stats":{"Line":4}},{"line":196,"address":[3632818],"length":1,"stats":{"Line":2}},{"line":200,"address":[4429194,4429445,4429088,4428912,4428947,4429051],"length":1,"stats":{"Line":50}},{"line":201,"address":[3546431,3546640,3546490,3546544],"length":1,"stats":{"Line":26}},{"line":205,"address":[3546896],"length":1,"stats":{"Line":12}},{"line":209,"address":[3547119,3547234,3547317],"length":1,"stats":{"Line":38}},{"line":210,"address":[3275911],"length":1,"stats":{"Line":12}},{"line":212,"address":[],"length":0,"stats":{"Line":37}},{"line":213,"address":[4432397],"length":1,"stats":{"Line":14}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[3693946,3693856],"length":1,"stats":{"Line":12}},{"line":216,"address":[3341040],"length":1,"stats":{"Line":14}},{"line":220,"address":[],"length":0,"stats":{"Line":38}},{"line":221,"address":[],"length":0,"stats":{"Line":40}},{"line":224,"address":[3339280,3339363,3340747],"length":1,"stats":{"Line":4}},{"line":226,"address":[4431021,4431112],"length":1,"stats":{"Line":4}},{"line":228,"address":[6377689,6377680],"length":1,"stats":{"Line":4}},{"line":229,"address":[3468336,3468345],"length":1,"stats":{"Line":4}},{"line":230,"address":[6377744,6377749],"length":1,"stats":{"Line":4}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[3277682,3277591],"length":1,"stats":{"Line":4}},{"line":236,"address":[],"length":0,"stats":{"Line":4}},{"line":238,"address":[3468384,3468393],"length":1,"stats":{"Line":4}},{"line":239,"address":[3468425,3468416],"length":1,"stats":{"Line":4}},{"line":241,"address":[3278084,3278182],"length":1,"stats":{"Line":4}},{"line":244,"address":[3340294],"length":1,"stats":{"Line":2}},{"line":246,"address":[3693136],"length":1,"stats":{"Line":2}},{"line":266,"address":[3716202,3716208,3716064],"length":1,"stats":{"Line":2}},{"line":267,"address":[3716090,3716156],"length":1,"stats":{"Line":4}}],"covered":87,"coverable":92},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","src","vehicle","mod.rs"],"content":"pub mod dds;\n\nuse common::Result;\nuse dds::DdsData;\nuse tokio::sync::mpsc::Sender;\n\n/// Vehicle data management module\n///\n/// Manages vehicle data through DDS communication\npub struct VehicleManager {\n    /// DDS Manager instance\n    dds_manager: dds::DdsManager,\n}\n\nimpl VehicleManager {\n    /// Creates a new VehicleManager\n    ///\n    /// # Returns\n    ///\n    /// A new VehicleManager instance\n    pub fn new(tx: Sender\u003cDdsData\u003e) -\u003e Self {\n        Self {\n            dds_manager: dds::DdsManager::new(tx),\n        }\n    }\n\n    /// Initializes the vehicle data system\n    ///\n    /// Sets up the DDS system and prepares for topic subscriptions\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn init(\u0026mut self) -\u003e Result\u003c()\u003e {\n        // Initialize DDS manager\n        match self.dds_manager.init().await {\n            Ok(_) =\u003e {}\n            Err(e) =\u003e {\n                log::warn!(\"Failed to initialize DDS manager with settings file: {}. Using default settings.\", e);\n                // 기본 설정 적용\n            }\n        }\n        self.set_domain_id(100); // Set default domain ID\n\n        Ok(())\n    }\n\n    /// Subscribes to a vehicle data topic\n    ///\n    /// # Arguments\n    ///\n    /// * `topic_name` - Name of the topic to subscribe to\n    /// * `data_type_name` - Type name of the data\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn subscribe_topic(\n        \u0026mut self,\n        topic_name: String,\n        data_type_name: String,\n    ) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        self.dds_manager\n            .create_typed_listener(topic_name, data_type_name)\n            .await?;\n        // self.dds_manager\n        //     .create_listener(topic_name, data_type_name)\n        //     .await?;\n        Ok(())\n    }\n\n    /// Get list of available DDS types\n    pub fn list_available_types(\u0026self) -\u003e Vec\u003cString\u003e {\n        self.dds_manager.list_available_types()\n    }\n\n    /// Unsubscribes from a vehicle data topic\n    ///\n    /// # Arguments\n    ///\n    /// * `topic_name` - Name of the topic to unsubscribe from\n    ///\n    /// # Returns\n    ///\n    /// * `Result\u003c()\u003e` - Success or error result\n    pub async fn unsubscribe_topic(\u0026mut self, topic_name: String) -\u003e Result\u003c()\u003e {\n        // TODO: Implementation\n        self.dds_manager.remove_listener(\u0026topic_name).await?;\n        Ok(())\n    }\n\n    /// Gets the DDS data sender\n    ///\n    /// # Returns\n    ///\n    /// A sender for DDS data\n    pub fn get_sender(\u0026self) -\u003e tokio::sync::mpsc::Sender\u003cdds::DdsData\u003e {\n        self.dds_manager.get_sender()\n    }\n\n    /// Sets the DDS domain ID\n    ///\n    /// # Arguments\n    ///\n    /// * `domain_id` - Domain ID to use for DDS communication\n\n    pub fn set_domain_id(\u0026mut self, domain_id: i32) {\n        self.dds_manager.set_domain_id(domain_id);\n    }\n}\n//Unit tests for VehicleManager\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tokio::sync::mpsc;\n    #[tokio::test] // Test creation of VehicleManager and validate sender capacity\n    async fn test_vehicle_manager_new() {\n        let (tx, _rx) = mpsc::channel(10);\n        let vehicle_manager = VehicleManager::new(tx);\n        let sender = vehicle_manager.get_sender();\n        assert_eq!(sender.capacity(), 10); // Validate sender's capacity\n    }\n\n    #[tokio::test] // Test successful initialization of VehicleManager\n    async fn test_vehicle_manager_init_success() {\n        let (tx, _rx) = mpsc::channel(10);\n        let mut vehicle_manager = VehicleManager::new(tx);\n        let result = vehicle_manager.init().await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test] // Test subscribing to a topic successfully\n    async fn test_vehicle_manager_subscribe_topic() {\n        let (tx, _rx) = mpsc::channel(10);\n        let mut vehicle_manager = VehicleManager::new(tx);\n        let result = vehicle_manager\n            .subscribe_topic(\"vehicle_data\".to_string(), \"VehicleType\".to_string())\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[tokio::test] // Test unsubscribing from a topic successfully\n    async fn test_vehicle_manager_unsubscribe_topic() {\n        let (tx, _rx) = mpsc::channel(10);\n        let mut vehicle_manager = VehicleManager::new(tx);\n        let result = vehicle_manager\n            .unsubscribe_topic(\"vehicle_data\".to_string())\n            .await;\n        assert!(result.is_ok());\n    }\n\n    #[test] // Test listing all available vehicle types\n    fn test_vehicle_manager_list_available_types() {\n        let (tx, _rx) = mpsc::channel(10);\n        let vehicle_manager = VehicleManager::new(tx);\n        let types = vehicle_manager.list_available_types();\n        assert!(!types.is_empty());\n    }\n\n    #[test] // Test setting the domain ID for VehicleManager\n    fn test_vehicle_manager_set_domain_id() {\n        let (tx, _rx) = mpsc::channel(10);\n        let mut vehicle_manager = VehicleManager::new(tx);\n        vehicle_manager.set_domain_id(200);\n        assert!(true); // Placeholder assertion for domain ID setting\n    }\n}\n","traces":[{"line":21,"address":[3825776],"length":1,"stats":{"Line":12}},{"line":23,"address":[3825800],"length":1,"stats":{"Line":13}},{"line":34,"address":[3825864,3825856],"length":1,"stats":{"Line":50}},{"line":36,"address":[3742340],"length":1,"stats":{"Line":25}},{"line":38,"address":[4174529],"length":1,"stats":{"Line":12}},{"line":39,"address":[4174679,4174561,4174704],"length":1,"stats":{"Line":40}},{"line":43,"address":[4442771],"length":1,"stats":{"Line":12}},{"line":45,"address":[3255796],"length":1,"stats":{"Line":14}},{"line":58,"address":[6521504],"length":1,"stats":{"Line":7}},{"line":64,"address":[4443393,4443980,4443507,4443769,4443875,4443701],"length":1,"stats":{"Line":37}},{"line":66,"address":[3309044],"length":1,"stats":{"Line":15}},{"line":70,"address":[4076586],"length":1,"stats":{"Line":5}},{"line":74,"address":[2985712],"length":1,"stats":{"Line":2}},{"line":75,"address":[2985729],"length":1,"stats":{"Line":2}},{"line":87,"address":[3469448,3469440],"length":1,"stats":{"Line":12}},{"line":89,"address":[3860199,3859584,3859708,3859511,3859458],"length":1,"stats":{"Line":6}},{"line":90,"address":[3642102],"length":1,"stats":{"Line":3}},{"line":98,"address":[6521680],"length":1,"stats":{"Line":2}},{"line":99,"address":[3595477],"length":1,"stats":{"Line":2}},{"line":108,"address":[2985808],"length":1,"stats":{"Line":14}},{"line":109,"address":[4823277],"length":1,"stats":{"Line":13}}],"covered":21,"coverable":21},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","tests","filter_gateway_manager_integration.rs"],"content":"use common::spec::artifact::{Artifact, Scenario};\nuse filtergateway::manager::{FilterGatewayManager, ScenarioParameter};\nuse filtergateway::vehicle::dds::DdsData;\nuse filtergateway::vehicle::VehicleManager;\nuse filtergateway::FilterGatewaySender;\nuse serde_yaml;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::Duration;\nuse tokio::sync::{mpsc, Mutex};\n\nstatic VALID_SCENARIO_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: helloworld_dds\nspec:\n  condition:\n  action: update\n  target: helloworld_dds\n\"#;\n\nstatic VALID_PACKAGE_YAML_SINGLE: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: helloworld_dds\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: helloworld_dds-core\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n\nstatic VALID_MODEL_YAML_SINGLE: \u0026str = r#\"\napiVersion: v1\nkind: Model\nmetadata:\n  name: helloworld_dds-core\n  annotations:\n    io.piccolo.annotations.package-type: helloworld_dds-core\n    io.piccolo.annotations.package-name: helloworld_dds\n    io.piccolo.annotations.package-network: default\n  labels:\n    app: helloworld_dds-core\nspec:\n  hostNetwork: true\n  containers:\n    - name: helloworld_dds\n      image: helloworld\n  terminationGracePeriodSeconds: 0\n\"#;\n\n#[tokio::test]\nasync fn test_initialize_manager_with_valid_scenario() {\n    let (_tx, rx) = mpsc::channel(10);\n    let manager = FilterGatewayManager::new(rx).await;\n\n    common::etcd::put(\"Scenario/helloworld_dds\", VALID_SCENARIO_YAML)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/helloworld_dds\", VALID_PACKAGE_YAML_SINGLE)\n        .await\n        .unwrap();\n    common::etcd::put(\"Model/helloworld_dds-core\", VALID_MODEL_YAML_SINGLE)\n        .await\n        .unwrap();\n\n    let result = manager.initialize().await;\n    assert!(true);\n\n    common::etcd::delete(\"Scenario/helloworld_dds\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/helloworld_dds\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Model/helloworld_dds-core\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_run_manager_with_allow_action() {\n    let (tx, rx) = mpsc::channel(10);\n    let manager = FilterGatewayManager::new(rx).await;\n\n    let scenario: Scenario = serde_yaml::from_str(VALID_SCENARIO_YAML).unwrap();\n    let param = ScenarioParameter {\n        action: 0,\n        scenario,\n    };\n\n    tx.send(param).await.unwrap();\n\n    let handle = tokio::spawn(async move {\n        let _ = manager.run().await;\n    });\n\n    tokio::time::sleep(Duration::from_millis(200)).await;\n    handle.abort();\n}\nstatic VALID_SCENARIO_YAML1: \u0026str = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: helloworld_dds1\nspec:\n  condition:\n  action: update\n  target: helloworld_dds1\n\"#;\n\nstatic VALID_PACKAGE_YAML_SINGLE1: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: helloworld_dds1\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: helloworld_dds-core1\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n\n#[tokio::test]\nasync fn test_run_manager_with_withdraw_action() {\n    let (tx, rx) = mpsc::channel(10);\n    let manager = FilterGatewayManager::new(rx).await;\n\n    common::etcd::put(\"Scenario/helloworld_dds1\", VALID_SCENARIO_YAML1)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/helloworld_dds1\", VALID_PACKAGE_YAML_SINGLE1)\n        .await\n        .unwrap();\n    let scenario: Scenario = serde_yaml::from_str(VALID_SCENARIO_YAML1).unwrap();\n    manager.launch_scenario_filter(scenario).await.unwrap();\n\n    tokio::time::sleep(Duration::from_millis(500)).await;\n\n    let scenario: Scenario = serde_yaml::from_str(VALID_SCENARIO_YAML1).unwrap();\n    tx.send(ScenarioParameter {\n        action: 1,\n        scenario,\n    })\n    .await\n    .unwrap();\n\n    let handle = tokio::spawn(async move {\n        let _ = manager.run().await;\n    });\n\n    common::etcd::delete(\"Scenario/helloworld_dds1\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/helloworld_dds1\")\n        .await\n        .unwrap();\n    handle.abort();\n}\n\nstatic VALID_SCENARIO_YAML2: \u0026str = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: helloworld_dds2\nspec:\n  condition:\n  action: update\n  target: helloworld_dds2\n\"#;\n\nstatic VALID_PACKAGE_YAML_SINGLE2: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: helloworld_dds2\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: helloworld_dds-core2\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n\n#[tokio::test]\nasync fn test_run_manager_with_withdraw_action_none() {\n    let (tx, rx) = mpsc::channel(10);\n    let manager = FilterGatewayManager::new(rx).await;\n\n    common::etcd::put(\"Scenario/helloworld_dds2\", VALID_SCENARIO_YAML2)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/helloworld_dds2\", VALID_PACKAGE_YAML_SINGLE2)\n        .await\n        .unwrap();\n\n    let scenario: Scenario = serde_yaml::from_str(VALID_SCENARIO_YAML2).unwrap();\n    manager.launch_scenario_filter(scenario).await.unwrap();\n    let scenario: Scenario = serde_yaml::from_str(VALID_SCENARIO_YAML2).unwrap();\n    tx.send(ScenarioParameter {\n        action: 3,\n        scenario,\n    })\n    .await\n    .unwrap();\n\n    let handle = tokio::spawn(async move {\n        let _ = manager.run().await;\n    });\n\n    tokio::time::sleep(Duration::from_millis(200)).await;\n    handle.abort();\n\n    common::etcd::delete(\"Scenario/helloworld_dds2\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/helloworld_dds2\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_subscribe_and_unsubscribe_vehicle_data() {\n    let (_tx, rx) = mpsc::channel(10);\n    let manager = FilterGatewayManager::new(rx).await;\n\n    let mut fields = HashMap::new();\n    fields.insert(\"speed\".to_string(), \"100\".to_string());\n\n    let data = DdsData {\n        name: \"test_topic\".to_string(),\n        value: \"TestType\".to_string(),\n        fields,\n    };\n\n    assert!(manager.subscribe_vehicle_data(data).await.is_ok());\n\n    let mut fields2 = HashMap::new();\n    fields2.insert(\"speed\".to_string(), \"100\".to_string());\n    let data2 = DdsData {\n        name: \"test_topic\".to_string(),\n        value: \"TestType\".to_string(),\n        fields: fields2,\n    };\n\n    assert!(manager.unsubscribe_vehicle_data(data2).await.is_ok());\n}\n#[tokio::test]\nasync fn test_initialize_manager_with_invalid_scenario_yaml() {\n    let (_tx, rx) = mpsc::channel(10);\n    let manager = FilterGatewayManager::new(rx).await;\n\n    static INVALID_SCENARIO_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  # missing 'name'\nspec:\n  condition:\n  action: invalid_action\n  target: helloworld_dds\n\"#;\n\n    common::etcd::put(\"Scenario/invalid_scenario\", INVALID_SCENARIO_YAML)\n        .await\n        .unwrap();\n\n    let result = manager.initialize().await;\n    // Should not panic, ideally error or ok handled gracefully\n    assert!(result.is_err() || result.is_ok());\n\n    common::etcd::delete(\"Scenario/invalid_scenario\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_initialize_manager_with_malformed_yaml() {\n    let (_tx, rx) = mpsc::channel(10);\n    let manager = FilterGatewayManager::new(rx).await;\n\n    static MALFORMED_YAML: \u0026str = r#\"\napiVersion: v1\nkind Scenario\nmetadata:\n  name helloworld_dds\nspec:\n  condition:\n  action: update\n  target: helloworld_dds\n\"#;\n\n    common::etcd::put(\"Scenario/malformed\", MALFORMED_YAML)\n        .await\n        .unwrap();\n\n    let result = manager.initialize().await;\n    assert!(result.is_err());\n\n    common::etcd::delete(\"Scenario/malformed\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn test_run_manager_with_invalid_action_value() {\n    let (tx, rx) = mpsc::channel(10);\n    let manager = FilterGatewayManager::new(rx).await;\n\n    let scenario: Scenario = serde_yaml::from_str(VALID_SCENARIO_YAML).unwrap();\n    let param = ScenarioParameter {\n        action: 99,\n        scenario,\n    }; // invalid action\n\n    tx.send(param).await.unwrap();\n\n    let handle = tokio::spawn(async move {\n        let _ = manager.run().await;\n    });\n\n    tokio::time::sleep(std::time::Duration::from_millis(200)).await;\n    handle.abort();\n}\n\n#[tokio::test]\nasync fn test_launch_scenario_filter_with_invalid_scenario() {\n    let (_tx, rx) = mpsc::channel(10);\n    let manager = FilterGatewayManager::new(rx).await;\n\n    static INVALID_SCENARIO_YAML2: \u0026str = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  # missing name\nspec:\n  condition:\n  action: update\n  target: missing_target\n\"#;\n\n    let scenario_res = serde_yaml::from_str::\u003cScenario\u003e(INVALID_SCENARIO_YAML2);\n    assert!(scenario_res.is_err());\n\n    if let Ok(scenario) = scenario_res {\n        let result = manager.launch_scenario_filter(scenario).await;\n        assert!(result.is_err());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","tests","filter_integration.rs"],"content":"use common::spec::artifact::Scenario;\nuse filtergateway::filter::Filter;\nuse filtergateway::grpc::sender::FilterGatewaySender;\nuse filtergateway::vehicle::dds::DdsData;\nuse std::collections::HashMap;\nuse tokio;\n\n// Helper to build a scenario from an expression and value\nfn build_scenario_yaml_with_expression(Scenario_name: \u0026str, expr: \u0026str, value: \u0026str) -\u003e Scenario {\n    let yaml = format!(\n        r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: {Scenario_name}\nspec:\n  condition:\n    express: {expr}\n    value: \"{value}\"\n    operands:\n      type: DDS\n      name: \"temperature\"\n      value: \"TestTopic\"\n  action: update\n  target: test_target\n\"#,\n        expr = expr,\n        value = value\n    );\n    serde_yaml::from_str(\u0026yaml).expect(\"Failed to parse scenario YAML\")\n}\n\n// Helper to build a scenario from raw YAML\nfn build_scenario_from_yaml(yaml: \u0026str) -\u003e Scenario {\n    serde_yaml::from_str(yaml).expect(\"Failed to parse scenario YAML\")\n}\n\n// Build DDS data with topic, field key and value\nfn build_dds_data(topic: \u0026str, key: \u0026str, value: \u0026str) -\u003e DdsData {\n    let mut fields = HashMap::new();\n    fields.insert(key.into(), value.into());\n    DdsData {\n        name: topic.into(),\n        value: value.to_string(),\n        fields,\n    }\n}\n// === Expression Tests ===\n\n#[tokio::test]\nasync fn test_eq_expression_success() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: test_eq\nspec:\n  condition:\n    express: le\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: test_eq\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: test_eq\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: test_eq\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/test_eq\", yaml).await.unwrap();\n    common::etcd::put(\"Package/test_eq\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"test_eq\", \"eq\", \"true\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"true\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"test_eq\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/test_eq\").await.unwrap();\n    common::etcd::delete(\"Package/test_eq\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn test_meet_scenario_condition_data_not_match() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: test_eq1\nspec:\n  condition:\n    express: eq\n    value: \"true\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: test_eq1\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: test_eq1\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: test_eq1\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/test_eq1\", yaml).await.unwrap();\n    common::etcd::put(\"Package/test_eq1\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"test_eq1\", \"eq\", \"true\");\n    let dds = build_dds_data(\"TestTopic_wrong\", \"temperature\", \"true\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"test_eq1\".into(), scenario, true, sender);\n\n    assert!(filter.meet_scenario_condition(\u0026dds).await.is_err());\n    common::etcd::delete(\"Scenario/test_eq1\").await.unwrap();\n    common::etcd::delete(\"Package/test_eq1\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn test_lt_expression_success() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: test_lt\nspec:\n  condition:\n    express: lt\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: test_lt\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: test_lt\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: test_lt\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/test_lt\", yaml).await.unwrap();\n    common::etcd::put(\"Package/test_lt\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"test_lt\", \"lt\", \"10\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"5\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"test_lt\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/test_lt\").await.unwrap();\n    common::etcd::delete(\"Package/test_lt\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn test_meet_scenario_condition_field_parse_error() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: test_field_parse\nspec:\n  condition:\n    express: gt\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: test_field_parse\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: test_field_parse\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: test_field_parse\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/test_field_parse\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/test_field_parse\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"test_field_parse\", \"gt\", \"10\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"abc\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"test_field_parse\".into(), scenario, true, sender);\n\n    let result = filter.meet_scenario_condition(\u0026dds).await;\n    assert!(result.is_err());\n    assert_eq!(result.unwrap_err().to_string(), \"field_value parse error\");\n    common::etcd::delete(\"Scenario/test_field_parse\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/test_field_parse\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_meet_scenario_condition_empty() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: test_field_parse\nspec:\n  condition:\n  action: update\n  target: test_field_parse\n\"#;\n\n    let scenario = build_scenario_from_yaml(yaml);\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"abc\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"test_field_parse\".into(), scenario, true, sender);\n\n    let result = filter.process_data(\u0026dds).await;\n    assert!(true);\n}\n\n#[tokio::test]\nasync fn test_le_expression_success() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: test_le\nspec:\n  condition:\n    express: le\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: test_le\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: test_le\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: test_le\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/test_le\", yaml).await.unwrap();\n    common::etcd::put(\"Package/test_le\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"test_le\", \"le\", \"10\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"10\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"test_le\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/test_le\").await.unwrap();\n    common::etcd::delete(\"Package/test_le\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn test_ge_expression_success() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: test_ge\nspec:\n  condition:\n    express: ge\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: test_ge\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: test_ge\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: test_ge\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/test_ge\", yaml).await.unwrap();\n    common::etcd::put(\"Package/test_ge\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"test_ge\", \"ge\", \"10\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"11\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"test_ge\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/test_ge\").await.unwrap();\n    common::etcd::delete(\"Package/test_ge\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn test_gt_expression_success() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: test_gt\nspec:\n  condition:\n    express: gt\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: test_gt\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: test_gt\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: test_gt\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/test_gt\", yaml).await.unwrap();\n    common::etcd::put(\"Package/test_gt\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"test_gt\", \"gt\", \"10\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"15\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"test_gt\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/test_gt\").await.unwrap();\n    common::etcd::delete(\"Package/test_gt\").await.unwrap();\n}\n\n// === Error Cases ===\n\n#[tokio::test]\nasync fn test_wrong_expression_returns_error() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: invalid_expr\nspec:\n  condition:\n    express: unknown_expr\n    value: \"on\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: invalid_expr\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: invalid_expr\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: invalid_expr\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/invalid_expr\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/invalid_expr\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"invalid_expr\", \"unknown_expr\", \"on\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"on\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"invalid_expr\".into(), scenario, true, sender);\n\n    // Should log error but still return Ok from process_data\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/invalid_expr\").await.unwrap();\n    common::etcd::delete(\"Package/invalid_expr\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn test_topic_mismatch_returns_ok() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: topic_mismatch\nspec:\n  condition:\n    express: eq\n    value: \"true\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: topic_mismatch\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: topic_mismatch\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: topic_mismatch\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/topic_mismatch\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/topic_mismatch\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"topic_mismatch\", \"eq\", \"true\");\n    let dds = build_dds_data(\"WrongTopic\", \"temperature\", \"true\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"topic_mismatch\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/topic_mismatch\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/topic_mismatch\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_gt_condition_not_met() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: test_gt\nspec:\n  condition:\n    express: gt\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: test_gt\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: test_gt\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: test_gt\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/test_gt\", yaml).await.unwrap();\n    common::etcd::put(\"Package/test_gt\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"test_gt\", \"gt\", \"100\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"15\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"test_gt\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/test_gt\").await.unwrap();\n    common::etcd::delete(\"Package/test_gt\").await.unwrap();\n}\n#[tokio::test]\nasync fn test_missing_field_returns_error_logged() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: parse_field_error\nspec:\n  condition:\n    express: eq\n    value: \"true\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: parse_field_error\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: parse_field_error\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: parse_field_error\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/parse_field_error\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/parse_field_error\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"missing_field\", \"eq\", \"true\");\n    let dds = build_dds_data(\"TestTopic\", \"unknown_field\", \"true\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"missing_field\".into(), scenario, true, sender);\n\n    // Logs error, returns Ok\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/parse_field_error\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/parse_field_error\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_parse_error_in_lt_expression() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: parse_field_error\nspec:\n  condition:\n    express: lt\n    value: \"not_a_number\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: parse_field_error\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: parse_field_error\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: parse_field_error\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/parse_field_error\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/parse_field_error\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"parse_error\", \"lt\", \"not_a_number\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"5\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"parse_error\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/parse_field_error\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/parse_field_error\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_parse_error_in_le_expression() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: parse_field_error\nspec:\n  condition:\n    express: le\n    value: \"not_a_number\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: parse_field_error\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: parse_field_error\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: parse_field_error\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/parse_field_error\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/parse_field_error\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"parse_error\", \"le\", \"not_a_number\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"5\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"parse_error\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/parse_field_error\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/parse_field_error\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_parse_error_in_gt_expression() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: parse_field_error\nspec:\n  condition:\n    express: gt\n    value: \"not_a_number\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: parse_field_error\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: parse_field_error\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: parse_field_error\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/parse_field_error\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/parse_field_error\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"parse_error\", \"gt\", \"not_a_number\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"5\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"parse_error\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/parse_field_error\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/parse_field_error\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_parse_error_in_ge_expression() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: parse_field_error\nspec:\n  condition:\n    express: ge\n    value: \"not_a_number\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: parse_field_error\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: parse_field_error\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: parse_field_error\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/parse_field_error\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/parse_field_error\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"parse_error\", \"ge\", \"not_a_number\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"5\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"parse_error\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/parse_field_error\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/parse_field_error\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_parse_error_in_gt_field_value() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: parse_field_error\nspec:\n  condition:\n    express: gt\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: parse_field_error\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: parse_field_error\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: parse_field_error\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/parse_field_error\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/parse_field_error\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"parse_field_error\", \"gt\", \"10\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"not_a_number\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"parse_field_error\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/parse_field_error\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/parse_field_error\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_parse_error_in_lt_field_value() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: parse_field_error\nspec:\n  condition:\n    express: lt\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: parse_field_error\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: parse_field_error\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: parse_field_error\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/parse_field_error\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/parse_field_error\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"parse_field_error\", \"lt\", \"10\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"not_a_number\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"parse_field_error\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/parse_field_error\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/parse_field_error\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_parse_error_in_le_field_value() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: parse_field_error\nspec:\n  condition:\n    express: le\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: parse_field_error\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: parse_field_error\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: parse_field_error\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/parse_field_error\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/parse_field_error\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"parse_field_error\", \"le\", \"10\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"not_a_number\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"parse_field_error\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/parse_field_error\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/parse_field_error\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn test_parse_error_in_ge_field_value() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: parse_field_error\nspec:\n  condition:\n    express: ge\n    value: \"10\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: parse_field_error\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: parse_field_error\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: parse_field_error\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/parse_field_error\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/parse_field_error\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n    let scenario = build_scenario_yaml_with_expression(\"parse_field_error\", \"ge\", \"10\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"not_a_number\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"parse_field_error\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/parse_field_error\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/parse_field_error\")\n        .await\n        .unwrap();\n}\n\n// === Behavior Tests ===\n\n#[tokio::test]\nasync fn test_filter_inactive_skips_processing() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: inactive\nspec:\n  condition:\n    express: eq\n    value: \"on\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: inactive\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: inactive\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: inactive\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n    common::etcd::put(\"Scenario/inactive\", yaml).await.unwrap();\n    common::etcd::put(\"Package/inactive\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n\n    let scenario = build_scenario_yaml_with_expression(\"inactive\", \"eq\", \"on\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"on\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"inactive\".into(), scenario, false, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/inactive\").await.unwrap();\n    common::etcd::delete(\"Package/inactive\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn test_pause_and_resume_filter() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: pause_resume\nspec:\n  condition:\n    express: eq\n    value: \"on\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: pause_resume\n\"#;\n    static VALID_PACKAGE_YAML: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: pause_resume\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: pause_resume\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n\n    let scenario = build_scenario_yaml_with_expression(\"pause_resume\", \"eq\", \"on\");\n    let dds = build_dds_data(\"TestTopic\", \"temperature\", \"on\");\n\n    common::etcd::put(\"Scenario/pause_resume\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/pause_resume\", VALID_PACKAGE_YAML)\n        .await\n        .unwrap();\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"pause_resume\".into(), scenario, true, sender);\n\n    assert!(filter.is_active());\n    filter.pause_scenario_filter().await.unwrap();\n    assert!(!filter.is_active());\n\n    filter.resume_scenario_filter().await.unwrap();\n    assert!(filter.is_active());\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/pause_resume\").await.unwrap();\n    common::etcd::delete(\"Package/pause_resume\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn test_trigger_action_when_condition_met() {\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: helloworld\nspec:\n  condition:\n    express: eq\n    value: \"true\"\n    operands:\n      type: DDS\n      name: status\n      value: TestTopic\n  action: update\n  target: helloworld\n\"#;\n    static VALID_PACKAGE_YAML_SINGLE: \u0026str = r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: helloworld\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: helloworld\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#;\n\n    common::etcd::put(\"Scenario/helloworld\", yaml)\n        .await\n        .unwrap();\n    common::etcd::put(\"Package/helloworld\", VALID_PACKAGE_YAML_SINGLE)\n        .await\n        .unwrap();\n\n    let scenario = build_scenario_from_yaml(yaml);\n    let dds = build_dds_data(\"TestTopic\", \"status\", \"true\");\n\n    let sender = FilterGatewaySender::new();\n    let mut filter = Filter::new(\"helloworld\".into(), scenario, true, sender);\n\n    assert!(filter.process_data(\u0026dds).await.is_ok());\n    common::etcd::delete(\"Scenario/helloworld\").await.unwrap();\n    common::etcd::delete(\"Package/helloworld\").await.unwrap();\n}\n","traces":[{"line":9,"address":[2625696,2626148,2626154],"length":1,"stats":{"Line":3}},{"line":10,"address":[2625755],"length":1,"stats":{"Line":1}},{"line":30,"address":[2626067,2626002],"length":1,"stats":{"Line":5}},{"line":34,"address":[2626176],"length":1,"stats":{"Line":1}},{"line":35,"address":[2626208],"length":1,"stats":{"Line":1}},{"line":39,"address":[2626272,2626868,2626896],"length":1,"stats":{"Line":4}},{"line":40,"address":[2626375],"length":1,"stats":{"Line":2}},{"line":41,"address":[2626407,2626874,2626518,2626484],"length":1,"stats":{"Line":7}},{"line":43,"address":[2626635],"length":1,"stats":{"Line":4}},{"line":44,"address":[2626671],"length":1,"stats":{"Line":2}}],"covered":10,"coverable":10},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","tests","integration_main.rs"],"content":"use common::spec::artifact::Scenario;\nuse filtergateway::manager::{FilterGatewayManager, ScenarioParameter};\nuse filtergateway::vehicle::dds::DdsData;\nuse filtergateway::vehicle::VehicleManager;\nuse filtergateway::FilterGatewaySender;\nuse filtergateway::{initialize, launch_manager};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::mpsc;\nuse tokio::sync::mpsc::{channel, Receiver, Sender};\nuse tokio::sync::Mutex;\nuse tokio::task::LocalSet;\nuse tokio::time::{sleep, Duration};\n\n#[tokio::test]\nasync fn integration_test_launch_manager_and_initialize() {\n    let (tx_grpc, rx_grpc) = channel::\u003cScenarioParameter\u003e(100);\n\n    // Spawn manager on a LocalSet (if needed for non-Send)\n    let local = LocalSet::new();\n    local.spawn_local(async move {\n        let _ = launch_manager(rx_grpc).await;\n    });\n\n    // Spawn initialize\n    let init_fut = initialize(tx_grpc);\n\n    // Run both concurrently\n    tokio::select! {\n        _ = local =\u003e {},\n        _ = init_fut =\u003e {},\n        _ = sleep(Duration::from_millis(500)) =\u003e {},\n    }\n\n    // If reached here, test passed without panic\n    assert!(true);\n}\n/// Test to ensure that the channels are initialized with the correct capacity\n#[tokio::test]\nasync fn test_main_initializes_channels() {\n    let (tx_grpc, rx_grpc): (Sender\u003cScenarioParameter\u003e, Receiver\u003cScenarioParameter\u003e) = channel(100);\n    assert_eq!(tx_grpc.capacity(), 100);\n    assert!(!rx_grpc.is_closed());\n}\n\n/// Test to ensure that the manager thread launches without any panic\n#[tokio::test]\nasync fn test_main_launch_manager() {\n    let (_tx_grpc, rx_grpc): (Sender\u003cScenarioParameter\u003e, Receiver\u003cScenarioParameter\u003e) =\n        channel(100);\n\n    let local = LocalSet::new();\n    local.spawn_local(async move {\n        let _ = launch_manager(rx_grpc).await;\n    });\n\n    tokio::select! {\n        _ = local =\u003e {}\n        _ = sleep(Duration::from_millis(200)) =\u003e {}\n    }\n\n    assert!(true);\n}\n\n/// Test to ensure that the gRPC initialization runs without any panic\n#[tokio::test(flavor = \"multi_thread\")]\nasync fn test_main_initialize_grpc() {\n    let (tx_grpc, _rx_grpc): (Sender\u003cScenarioParameter\u003e, Receiver\u003cScenarioParameter\u003e) =\n        channel(100);\n\n    let local = LocalSet::new();\n    local.spawn_local(async move {\n        let _ = initialize(tx_grpc).await;\n    });\n\n    tokio::select! {\n        _ = local =\u003e {}\n        _ = sleep(Duration::from_millis(200)) =\u003e {}\n    }\n\n    assert!(true);\n}\n\n#[tokio::test]\nasync fn test_launch_filter_with_valid_condition() {\n    let (_tx, rx) = mpsc::channel(1);\n    let manager = FilterGatewayManager::new(rx).await;\n\n    let valid_yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: helloworld\nspec:\n  condition:\n   express: eq\n   value: \"true\"\n   operands:\n     type: DDS\n     name: value\n     value: ADASObstacleDetectionIsWarning\n  action: update\n  target: helloworld\n\"#;\n\n    let scenario: Scenario = serde_yaml::from_str(valid_yaml).unwrap();\n    let scenario1: Scenario = serde_yaml::from_str(valid_yaml).unwrap();\n    let result = manager.launch_scenario_filter(scenario).await;\n    let resul1 = manager.launch_scenario_filter(scenario1).await;\n    assert!(result.is_ok());\n\n    let filters = manager.filters.lock().await;\n    assert!(filters.iter().any(|f| f.scenario_name == \"helloworld\"));\n}\n\n#[tokio::test(flavor = \"multi_thread\")]\nasync fn integration_test_error_path_initialize() {\n    // Create a test YAML Scenario string\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: helloworld\nspec:\n  condition:\n    express: eq\n    value: \"true\"\n    operands:\n      type: DDS\n      name: value\n      value: ADASObstacleDetectionIsWarning\n  action: update\n  target: helloworld\n\"#;\n\n    // Deserialize into Scenario (even with private fields)\n    let scenario: Scenario = serde_yaml::from_str(yaml).expect(\"Failed to parse YAML\");\n\n    let scenario_param = ScenarioParameter {\n        action: 0,\n        scenario,\n    };\n\n    let (tx_grpc, rx_grpc) = channel(100);\n\n    // Send the parameter to the manager\n    tx_grpc.send(scenario_param).await.expect(\"send failed\");\n\n    // Use LocalSet to support non-Send futures\n    let local = LocalSet::new();\n    local.spawn_local(async move {\n        // This runs your real FilterGatewayManager with a real Scenario\n        launch_manager(rx_grpc).await;\n    });\n\n    // Let the manager run for a short time\n    tokio::select! {\n        _ = local =\u003e {},\n        _ = sleep(Duration::from_millis(500)) =\u003e {},\n    }\n\n    // If reached here, test didn't panic or crash\n    assert!(true);\n}\n\n#[tokio::test]\nasync fn integration_test_none_action() {\n    // Create a test YAML Scenario string\n    let yaml = r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: helloworld_new\nspec:\n  condition:\n    express: eq\n    value: \"on\"\n    operands:\n      type: DDS\n      name: status\n      value: ADASObstacleDetectionIsWarning\n  action: update\n  target: helloworld_new\n\"#;\n\n    // Deserialize into Scenario (even with private fields)\n    let scenario: Scenario = serde_yaml::from_str(yaml).expect(\"Failed to parse YAML\");\n\n    let scenario_param = ScenarioParameter {\n        action: 3,\n        scenario,\n    };\n\n    let (tx_grpc, rx_grpc) = channel(100);\n\n    // Send the parameter to the manager\n    tx_grpc.send(scenario_param).await.expect(\"send failed\");\n\n    // Use LocalSet to support non-Send futures\n    let local = LocalSet::new();\n    local.spawn_local(async move {\n        // This runs your real FilterGatewayManager with a real Scenario\n        launch_manager(rx_grpc).await;\n    });\n\n    // Let the manager run for a short time\n    tokio::select! {\n        _ = local =\u003e {},\n        _ = sleep(Duration::from_millis(1000)) =\u003e {},\n    }\n\n    // If reached here, test didn't panic or crash\n    assert!(true);\n}\n\n#[tokio::test]\nasync fn integration_test_initialize_failure_path() {\n    // Insert mock Scenario YAML into etcd\n    common::etcd::put(\n        \"Scenario/antipinch-en\",\n        r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: antipinch-en\nspec:\n  condition:\n    express: unknown_expr\n    value: \"on\"\n    operands:\n      type: DDS\n      name: status\n      value: ADASObstacleDetectionIsWarning\n  action: update\n  target: antipinch-en\n\"#,\n    )\n    .await\n    .unwrap();\n\n    // Insert mock Package YAML into etcd\n    common::etcd::put(\n        \"Package/antipinch-en\",\n        r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: antipinch-en\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: antipinch-en\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#,\n    )\n    .await\n    .unwrap();\n    // Create a closed receiver channel to simulate invalid input\n    let (_tx_grpc, rx_grpc): (_, Receiver\u003cScenarioParameter\u003e) = channel(100);\n\n    // Drop sender immediately — simulate init failure (depends on implementation)\n    drop(_tx_grpc);\n    let _ = sleep(Duration::from_millis(200));\n    // Use LocalSet to spawn the non-Send future\n    let local = LocalSet::new();\n\n    local.spawn_local(async move {\n        // This should hit the `Err(e)` block in `initialize().await`\n        launch_manager(rx_grpc).await;\n    });\n\n    // Let it run for a short while\n    tokio::select! {\n        _ = local =\u003e {},\n        _ = sleep(Duration::from_millis(700)) =\u003e {},\n    }\n\n    // Test passes if no panic occurred and error path was exercised\n    assert!(true);\n    // Cleanup after test\n    common::etcd::delete(\"Scenario/antipinch-en\").await.unwrap();\n    common::etcd::delete(\"Package/antipinch-en\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn integration_test_initialize_failure() {\n    // Insert mock Scenario YAML into etcd\n    common::etcd::put(\n        \"Scenario/antipinch-en1\",\n        r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: antipinch-en1\nspec:\n  condition:\n  action: update\n  target: antipinch-en1\n\"#,\n    )\n    .await\n    .unwrap();\n\n    // Insert mock Package YAML into etcd\n    common::etcd::put(\n        \"Package/antipinch-en1\",\n        r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: antipinch-en1\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: antipinch-en1\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#,\n    )\n    .await\n    .unwrap();\n    // Create a closed receiver channel to simulate invalid input\n    let (_tx_grpc, rx_grpc): (_, Receiver\u003cScenarioParameter\u003e) = channel(100);\n\n    // Drop sender immediately — simulate init failure (depends on implementation)\n    drop(_tx_grpc);\n    let _ = sleep(Duration::from_millis(200));\n    // Use LocalSet to spawn the non-Send future\n    let local = LocalSet::new();\n\n    local.spawn_local(async move {\n        // This should hit the `Err(e)` block in `initialize().await`\n        launch_manager(rx_grpc).await;\n    });\n\n    // Let it run for a short while\n    tokio::select! {\n        _ = local =\u003e {},\n        _ = sleep(Duration::from_millis(2000)) =\u003e {},\n    }\n\n    // Test passes if no panic occurred and error path was exercised\n    assert!(true);\n    // Cleanup after test\n    common::etcd::delete(\"Scenario/antipinch-en1\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/antipinch-en1\").await.unwrap();\n}\n\n#[tokio::test]\nasync fn integration_test_initialize_success() {\n    // Insert mock Scenario YAML into etcd\n    common::etcd::put(\n        \"Scenario/antipinch-enable1\",\n        r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: antipinch-enable1\nspec:\n  condition:\n    express: eq\n    value: \"true\"\n    operands:\n      type: DDS\n      name: value\n      value: ADASObstacleDetectionIsWarning\n  action: update\n  target: antipinch-enable1\n\"#,\n    )\n    .await\n    .unwrap();\n\n    // Insert mock Package YAML into etcd\n    common::etcd::put(\n        \"Package/antipinch-enable1\",\n        r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: antipinch-enable1\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: antipinch-enable1\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#,\n    )\n    .await\n    .unwrap();\n    // Create a closed receiver channel to simulate invalid input\n    let (_tx_grpc, rx_grpc): (_, Receiver\u003cScenarioParameter\u003e) = channel(100);\n\n    // Drop sender immediately — simulate init failure (depends on implementation)\n    drop(_tx_grpc);\n    let _ = sleep(Duration::from_millis(200));\n    // Use LocalSet to spawn the non-Send future\n    let local = LocalSet::new();\n\n    local.spawn_local(async move {\n        // This should hit the `Err(e)` block in `initialize().await`\n        launch_manager(rx_grpc).await;\n    });\n\n    // Let it run for a short while\n    tokio::select! {\n        _ = local =\u003e {},\n        _ = sleep(Duration::from_millis(2000)) =\u003e {},\n    }\n\n    // Test passes if no panic occurred and error path was exercised\n    assert!(true);\n    // Cleanup after test\n    common::etcd::delete(\"Scenario/antipinch-enable1\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/antipinch-enable1\")\n        .await\n        .unwrap();\n}\n\n#[tokio::test]\nasync fn integration_test_initialize_success_path() {\n    // Insert mock Scenario YAML into etcd\n    common::etcd::put(\n        \"Scenario/antipinch-enable\",\n        r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: antipinch-enable\nspec:\n  condition:\n    express: eq\n    value: \"true\"\n    operands:\n      type: DDS\n      name: value\n      value: ADASObstacleDetectionIsWarning\n  action: update\n  target: antipinch-enable\n\"#,\n    )\n    .await\n    .unwrap();\n\n    // Insert mock Package YAML into etcd\n    common::etcd::put(\n        \"Package/antipinch-enable\",\n        r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  name: antipinch-enable\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: antipinch-enable\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#,\n    )\n    .await\n    .unwrap();\n    // Create a closed receiver channel to simulate invalid input\n    let (_tx_grpc, rx_grpc): (_, Receiver\u003cScenarioParameter\u003e) = channel(100);\n\n    // Use LocalSet to spawn the non-Send future\n    let local = LocalSet::new();\n\n    local.spawn_local(async move {\n        // This should hit the `Err(e)` block in `initialize().await`\n        launch_manager(rx_grpc).await;\n    });\n\n    // Let it run for a short while\n    tokio::select! {\n        _ = local =\u003e {},\n        _ = sleep(Duration::from_millis(1000)) =\u003e {},\n    }\n\n    // Test passes if no panic occurred and error path was exercised\n    assert!(true);\n    // Cleanup after test\n    common::etcd::delete(\"Scenario/antipinch-enable\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/antipinch-enable\")\n        .await\n        .unwrap();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","tests","receiver_integration.rs"],"content":"use common::filtergateway::{\n    filter_gateway_connection_client::FilterGatewayConnectionClient, HandleScenarioRequest,\n};\nuse filtergateway::FilterGatewayReceiver;\nuse std::net::SocketAddr;\nuse tokio::sync::mpsc;\nuse tonic::{transport::Server, Request};\n\n#[tokio::test]\n/// Test valid YAML scenario is accepted by the gRPC server and forwarded correctly.\nasync fn test_handle_scenario_with_valid_yaml() {\n    let (tx, mut rx) = mpsc::channel(1);\n    let receiver = FilterGatewayReceiver::new(tx);\n\n    // Start gRPC server on a local port\n    let addr: SocketAddr = \"127.0.0.1:50055\".parse().unwrap();\n    let server = tokio::spawn(async move {\n        Server::builder()\n            .add_service(receiver.into_service())\n            .serve(addr)\n            .await\n            .unwrap();\n    });\n\n    tokio::time::sleep(std::time::Duration::from_millis(200)).await;\n\n    // Create gRPC client\n    let mut client = FilterGatewayConnectionClient::connect(\"http://127.0.0.1:50055\")\n        .await\n        .expect(\"Failed to connect\");\n\n    let scenario_yaml = r#\"\n    apiVersion: v1\n    kind: Scenario\n    metadata:\n      name: helloworld\n    spec:\n      condition:\n      action: update\n      target: helloworld\n    \"#;\n\n    let request = Request::new(HandleScenarioRequest {\n        scenario: scenario_yaml.to_string(),\n        action: 0,\n    });\n\n    // Send the scenario request\n    let response = client.handle_scenario(request).await.unwrap().into_inner();\n\n    // Validate response from gRPC server\n    assert!(response.status);\n    assert_eq!(response.desc, \"Successfully handled scenario\");\n\n    // Confirm the scenario was forwarded through the channel\n    let received_param = rx.recv().await.unwrap();\n    assert_eq!(received_param.action, 0);\n    server.abort();\n}\n\n#[tokio::test]\n/// Test that sending invalid YAML results in an internal gRPC error.\nasync fn test_handle_scenario_with_invalid_yaml() {\n    let (tx, _rx) = mpsc::channel(1);\n    let receiver = FilterGatewayReceiver::new(tx);\n\n    let addr: SocketAddr = \"127.0.0.1:50056\".parse().unwrap();\n    let server = tokio::spawn(async move {\n        Server::builder()\n            .add_service(receiver.into_service())\n            .serve(addr)\n            .await\n            .unwrap();\n    });\n\n    tokio::time::sleep(std::time::Duration::from_millis(200)).await;\n\n    let mut client = FilterGatewayConnectionClient::connect(\"http://127.0.0.1:50056\")\n        .await\n        .expect(\"Failed to connect\");\n\n    let invalid_yaml = r#\"\n    apiVersion: v1\n    kind: Scenario\n    metadata:\n      name: helloworld\n    spec:\n      condition:\n      action: update\n      target: helloworld\n    ---\n    apiVersion: v1\n    kind: Package\n    metadata:\n      label: null\n      name: helloworld\n    spec:\n      pattern:\n        - type: plain\n      models:\n        - name: helloworld-core\n          node: HPC\n          resources:\n            volume:\n            network:\n    \"#; // Invalid YAML due to incomplete resources\n\n    let request = Request::new(HandleScenarioRequest {\n        scenario: invalid_yaml.to_string(),\n        action: 0,\n    });\n\n    // The request should fail due to invalid YAML parsing\n    let result = client.handle_scenario(request).await;\n    assert!(result.is_err());\n\n    server.abort();\n}\n\n#[tokio::test]\n/// Test that empty YAML input is rejected with an error.\nasync fn test_handle_scenario_with_empty_yaml() {\n    let (tx, _rx) = mpsc::channel(1);\n    let receiver = FilterGatewayReceiver::new(tx);\n\n    let addr: SocketAddr = \"127.0.0.1:50057\".parse().unwrap();\n    let server = tokio::spawn(async move {\n        Server::builder()\n            .add_service(receiver.into_service())\n            .serve(addr)\n            .await\n            .unwrap();\n    });\n\n    tokio::time::sleep(std::time::Duration::from_millis(200)).await;\n\n    let mut client = FilterGatewayConnectionClient::connect(\"http://127.0.0.1:50057\")\n        .await\n        .expect(\"Failed to connect\");\n\n    let empty_yaml = \"\";\n\n    let request = Request::new(HandleScenarioRequest {\n        scenario: empty_yaml.to_string(),\n        action: 0,\n    });\n\n    let result = client.handle_scenario(request).await;\n    assert!(result.is_err());\n\n    server.abort();\n}\n\n#[tokio::test]\n/// Test that YAML missing required fields is rejected.\nasync fn test_handle_scenario_with_missing_fields() {\n    let (tx, _rx) = mpsc::channel(1);\n    let receiver = FilterGatewayReceiver::new(tx);\n\n    let addr: SocketAddr = \"127.0.0.1:50058\".parse().unwrap();\n    let server = tokio::spawn(async move {\n        Server::builder()\n            .add_service(receiver.into_service())\n            .serve(addr)\n            .await\n            .unwrap();\n    });\n\n    tokio::time::sleep(std::time::Duration::from_millis(200)).await;\n\n    let mut client = FilterGatewayConnectionClient::connect(\"http://127.0.0.1:50058\")\n        .await\n        .expect(\"Failed to connect\");\n\n    let incomplete_yaml = r#\"\n    apiVersion: v1\n    kind: Scenario\n    metadata:\n      name: helloworld\n    spec:\n      action: update\n    \"#; // Missing \"target\" field\n\n    let request = Request::new(HandleScenarioRequest {\n        scenario: incomplete_yaml.to_string(),\n        action: 0,\n    });\n\n    let result = client.handle_scenario(request).await;\n    assert!(result.is_err());\n\n    server.abort();\n}\n\n#[tokio::test]\nasync fn test_handle_scenario_with_closed_channel_should_fail() {\n    let (tx, rx) = mpsc::channel(1);\n    drop(rx); // Close the receiving end — channel is now closed\n\n    let receiver = FilterGatewayReceiver::new(tx);\n\n    let addr: SocketAddr = \"127.0.0.1:50059\".parse().unwrap();\n    let server = tokio::spawn(async move {\n        Server::builder()\n            .add_service(receiver.into_service())\n            .serve(addr)\n            .await\n            .unwrap();\n    });\n\n    tokio::time::sleep(std::time::Duration::from_millis(200)).await;\n\n    let mut client = FilterGatewayConnectionClient::connect(\"http://127.0.0.1:50059\")\n        .await\n        .expect(\"Failed to connect\");\n\n    let scenario_yaml = r#\"\n    apiVersion: v1\n    kind: Scenario\n    metadata:\n      name: helloworld\n    spec:\n      condition:\n      action: update\n      target: helloworld\n    \"#;\n\n    let request = Request::new(HandleScenarioRequest {\n        scenario: scenario_yaml.to_string(),\n        action: 0,\n    });\n\n    // Expect the request to fail because the channel is closed\n    let result = client.handle_scenario(request).await;\n\n    assert!(\n        result.is_err(),\n        \"Expected gRPC failure due to closed channel\"\n    );\n\n    server.abort();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","tests","sender_integration.rs"],"content":"use common::Result;\nuse filtergateway::FilterGatewaySender;\nuse tokio::time::{sleep, Duration};\n\n/// Test Case: Valid Scenario Name\n/// This test verifies that calling `trigger_action` with a known valid\n/// scenario name (e.g., \"antipinch-enable\") succeeds when the gRPC\n/// server is running and accepts the request.\n#[tokio::test]\nasync fn test_trigger_action_valid_scenario() {\n    // Insert mock Scenario YAML into etcd\n    common::etcd::put(\n        \"Scenario/antipinch-enable\",\n        r#\"\napiVersion: v1\nkind: Scenario\nmetadata:\n  name: antipinch-enable\nspec:\n  condition:\n  action: update\n  target: antipinch-enable\n\"#,\n    )\n    .await\n    .unwrap();\n\n    // Insert mock Package YAML into etcd\n    common::etcd::put(\n        \"Package/antipinch-enable\",\n        r#\"\napiVersion: v1\nkind: Package\nmetadata:\n  label: null\n  name: antipinch-enable\nspec:\n  pattern:\n    - type: plain\n  models:\n    - name: helloworld-core\n      node: HPC\n      resources:\n        volume:\n        network:\n\"#,\n    )\n    .await\n    .unwrap();\n    let mut sender = FilterGatewaySender::new();\n    let result = sender.trigger_action(\"antipinch-enable\".to_string()).await;\n\n    assert!(\n        result.is_ok(),\n        \"Expected valid scenario to succeed, got error: {:?}\",\n        result.err()\n    );\n    // Cleanup after test\n    common::etcd::delete(\"Scenario/antipinch-enable\")\n        .await\n        .unwrap();\n    common::etcd::delete(\"Package/antipinch-enable\")\n        .await\n        .unwrap();\n}\n\n/// Test Case: Empty Scenario Name\n/// This test checks that an empty string passed as the scenario name\n/// is rejected before even attempting to contact the gRPC server.\n#[tokio::test]\nasync fn test_trigger_action_empty_scenario_should_fail() {\n    let mut sender = FilterGatewaySender::new();\n    let result = sender.trigger_action(\"\".to_string()).await;\n\n    // Should fail due to client-side validation\n    assert!(\n        result.is_err(),\n        \"Expected error when triggering with empty scenario\"\n    );\n}\n\n/// Test Case: Whitespace-Only Scenario Name\n/// This test ensures that strings with only spaces are treated as empty\n/// and properly rejected by the client before making a gRPC call.\n#[tokio::test]\nasync fn test_trigger_action_whitespace_only_scenario_should_fail() {\n    let mut sender = FilterGatewaySender::new();\n    let result = sender.trigger_action(\"   \".to_string()).await;\n\n    // Should fail due to client-side input check using `trim().is_empty()`\n    assert!(\n        result.is_err(),\n        \"Expected error when triggering with whitespace-only scenario\"\n    );\n}\n\n/// Test Case: Invalid Scenario That Server Rejects\n/// This test sends a scenario name that is not recognized by the gRPC server.\n/// The server is expected to return an error (e.g., `Status::not_found`).\n#[tokio::test]\nasync fn test_trigger_action_invalid_scenario_server_rejects() {\n    let mut sender = FilterGatewaySender::new();\n    let result = sender\n        .trigger_action(\"non-existent-scenario\".to_string())\n        .await;\n\n    // Should fail if the server checks scenario validity\n    assert!(\n        result.is_err(),\n        \"Expected error from server for unknown scenario\"\n    );\n}\n\n/// Test Case: Unicode Scenario Name\n/// This test verifies that Unicode strings (non-ASCII) are accepted\n/// and handled properly. It should not panic or crash, even if the server\n/// returns an error.\n#[tokio::test]\nasync fn test_trigger_action_unicode_scenario_name() {\n    let mut sender = FilterGatewaySender::new();\n    let result = sender.trigger_action(\"安全模式启动\".to_string()).await;\n\n    // The test passes if the function handles Unicode input gracefully\n    assert!(\n        result.is_ok() || result.is_err(),\n        \"Unicode scenario name should not crash\"\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","filtergateway","tests","topic_listener_integration.rs"],"content":"use dust_dds_derive::DdsType;\nuse filtergateway::vehicle::dds::listener::{\n    DdsTopicListener, GenericTopicListener, TopicListener,\n};\nuse filtergateway::vehicle::dds::DdsData;\nuse serde::{Deserialize, Serialize};\nuse tokio::sync::mpsc;\nuse tokio::time::{sleep, Duration};\n\n#[derive(Default, Debug, Clone, Deserialize, Serialize, PartialEq, DdsType)]\npub struct ADASObstacleDetectionIsWarning {\n    pub value: bool,\n}\n\n#[tokio::test]\nasync fn test_typed_listener_loop_runs_briefly_and_exits() {\n    use tokio::task::JoinHandle;\n    use tokio::time::{sleep, Duration};\n\n    let (tx, rx) = tokio::sync::mpsc::channel::\u003cDdsData\u003e(1);\n    let mut listener = GenericTopicListener::\u003cADASObstacleDetectionIsWarning\u003e::new(\n        \"ADASObstacleDetectionIsWarning\".to_string(),\n        \"DDS\".to_string(),\n        tx,\n        100,\n    );\n    let handle: JoinHandle\u003cResult\u003c(), anyhow::Error\u003e\u003e = tokio::spawn(async move {\n        listener\n            .start()\n            .await\n            .map_err(|e| anyhow::anyhow!(e.to_string())) // convert error to string before anyhow\n    });\n\n    sleep(Duration::from_millis(5000)).await;\n\n    drop(rx); // Close receiver to signal exit\n\n    handle.await; // Cleanup\n}\n#[tokio::test]\nasync fn test_topic_listener_lifecycle_and_data_flow() {\n    // Setup channel to receive DdsData from listener\n    let (tx, mut rx) = mpsc::channel::\u003cDdsData\u003e(10);\n\n    // Create a TopicListener on a test topic and domain\n    let mut listener = TopicListener::new(\n        \"ADASObstacleDetectionIsWarning\".to_string(),\n        \"DDS\".to_string(),\n        tx,\n        100,\n    );\n\n    // Initially listener is not running\n    assert!(!listener.is_running());\n\n    // Start the listener - should succeed and set running\n    listener.start().await.expect(\"Failed to start listener\");\n    assert!(listener.is_running());\n\n    // Starting again should be idempotent (no error, no double start)\n    listener.start().await.expect(\"Failed on repeated start\");\n    assert!(listener.is_running());\n\n    // Wait some time to allow the listener loop to run and send data\n    sleep(Duration::from_millis(500)).await;\n\n    // Now stop the listener, should succeed and set is_running false\n    listener.stop().await.expect(\"Failed to stop listener\");\n    assert!(!listener.is_running());\n\n    // Stopping again is allowed (idempotent)\n    listener.stop().await.expect(\"Failed on repeated stop\");\n    assert!(!listener.is_running());\n}\n\n#[tokio::test]\nasync fn test_listener_detects_closed_channel_and_exits() {\n    // Setup channel but drop receiver immediately to simulate closed channel\n    let (tx, rx) = mpsc::channel::\u003cDdsData\u003e(10);\n    drop(rx); // Receiver dropped -\u003e sending will fail\n\n    let mut listener = TopicListener::new(\n        \"closed_channel_topic\".to_string(),\n        \"type_closed\".to_string(),\n        tx,\n        0,\n    );\n\n    listener.start().await.expect(\"Failed to start listener\");\n    assert!(listener.is_running());\n\n    // Give some time for listener_loop to detect closed channel and exit\n    sleep(Duration::from_millis(500)).await;\n\n    // Since channel is closed, listener loop should end and stop itself\n    // However, your code does not auto-stop on channel close, so listener.is_running remains true.\n    // Let's stop it manually for clean test exit.\n    listener.stop().await.expect(\"Failed to stop listener\");\n    assert!(!listener.is_running());\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","statemanager","src","grpc","mod.rs"],"content":"mod receiver;\nmod sender;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","statemanager","src","grpc","receiver.rs"],"content":"/*\n * SPDX-FileCopyrightText: Copyright 2024 LG Electronics Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nuse common::statemanager::state_manager_connection_server::StateManagerConnection;\nuse common::statemanager::{Action, Response};\n\npub struct StateManagerGrpcServer {}\n\n#[tonic::async_trait]\nimpl StateManagerConnection for StateManagerGrpcServer {\n    async fn send_action(\n        \u0026self,\n        request: tonic::Request\u003cAction\u003e,\n    ) -\u003e Result\u003ctonic::Response\u003cResponse\u003e, tonic::Status\u003e {\n        let req = request.into_inner();\n        let command = req.action;\n\n        Err(tonic::Status::new(tonic::Code::Unavailable, command))\n    }\n}\n","traces":[{"line":17,"address":[1544708],"length":1,"stats":{"Line":0}},{"line":18,"address":[1544715],"length":1,"stats":{"Line":0}},{"line":20,"address":[1544747],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":3},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","statemanager","src","grpc","sender.rs"],"content":"/*\n * SPDX-FileCopyrightText: Copyright 2024 LG Electronics Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nuse common::actioncontroller::{\n    action_controller_connection_client::ActionControllerConnectionClient, connect_server,\n    ReconcileRequest, ReconcileResponse,\n};\nuse tonic::{Request, Response, Status};\n\npub async fn _send(condition: ReconcileRequest) -\u003e Result\u003cResponse\u003cReconcileResponse\u003e, Status\u003e {\n    let mut client = ActionControllerConnectionClient::connect(connect_server())\n        .await\n        .unwrap();\n    client.reconcile(Request::new(condition)).await\n}\n","traces":[{"line":12,"address":[1530880,1530883],"length":1,"stats":{"Line":0}},{"line":13,"address":[1543267,1543129,1543536,1543557,1543294],"length":1,"stats":{"Line":0}},{"line":14,"address":[1543287,1543175,1543321,1543371,1543538],"length":1,"stats":{"Line":0}},{"line":16,"address":[1543821,1543193,1543588,1543732],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","acrn","new_ak","new","cicd_pullpiri","src","player","statemanager","src","main.rs"],"content":"pub mod grpc;\n\nfn main() {\n    println!(\"Hello, world!\");\n}\n","traces":[{"line":3,"address":[1542864],"length":1,"stats":{"Line":0}},{"line":4,"address":[1542868],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>